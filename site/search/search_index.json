{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Portico","text":"<p>Portico is a Python framework that gives you the building blocks to create AI-powered applications that don't turn into spaghetti code as they grow.</p>"},{"location":"#what-is-portico","title":"What is Portico?","text":"<p>Think of Portico as a set of well-tested, production-ready components for the stuff every AI app needs: authentication, databases, LLM integrations, caching, file storage, and more. But instead of just handing you a pile of code, Portico enforces a clean architecture that keeps your application maintainable as it scales from MVP to production.</p> <p>The secret? Hexagonal architecture (also called \"ports and adapters\"). Sounds fancy, but the idea is simple: your business logic shouldn't care whether you're using OpenAI or Anthropic, PostgreSQL or SQLite, Redis or in-memory caching. You should be able to swap these out without rewriting your entire application.</p>"},{"location":"#the-four-building-blocks","title":"The Four Building Blocks","text":"<p>Portico organizes code into four clear layers. Once you understand these, everything else clicks into place:</p>"},{"location":"#1-kits-your-business-logic","title":"1. Kits - Your Business Logic","text":"<p>Kits are where your application logic lives. Think of them as services that do the actual work of your application:</p> <ul> <li><code>AuthKit</code> - Login, logout, session management</li> <li><code>UserKit</code> - User creation, updates, profiles</li> <li><code>LLMKit</code> - Talking to AI models</li> <li><code>RAGKit</code> - Retrieval-augmented generation</li> <li><code>CacheKit</code> - Smart caching strategies</li> </ul> <p>The key rule: Kits never import specific implementations. They only depend on ports (interfaces). This means your business logic stays clean and testable.</p> <pre><code># Kits depend on interfaces, not implementations\nclass LLMKit:\n    def __init__(self, llm_provider: LLMProvider):  # Interface, not OpenAI or Anthropic\n        self.provider = llm_provider\n\n    async def generate(self, prompt: str) -&gt; str:\n        return await self.provider.complete(prompt)\n</code></pre>"},{"location":"#2-ports-the-contracts","title":"2. Ports - The Contracts","text":"<p>Ports are interfaces (using Python's <code>ABC</code> or <code>Protocol</code>) that define what your application needs, without saying how it should work.</p> <pre><code>class LLMProvider(ABC):\n    @abstractmethod\n    async def complete(self, prompt: str) -&gt; str:\n        \"\"\"Generate a completion for the given prompt.\"\"\"\n        pass\n</code></pre> <p>That's it. Just a contract. The kit uses this interface, and adapters implement it.</p> <p>Why this matters: Your business logic (<code>LLMKit</code>) has no idea if it's talking to OpenAI, Anthropic, or a local model. It just knows it can call <code>.complete()</code> and get a response.</p>"},{"location":"#3-adapters-the-implementations","title":"3. Adapters - The Implementations","text":"<p>Adapters are the concrete implementations of ports. This is where you integrate with external services:</p> <ul> <li><code>OpenAIProvider</code> - Implements <code>LLMProvider</code> using OpenAI's API</li> <li><code>AnthropicProvider</code> - Implements <code>LLMProvider</code> using Anthropic's API</li> <li><code>PostgresRepository</code> - Implements database repositories with PostgreSQL</li> <li><code>RedisCacheAdapter</code> - Implements caching with Redis</li> </ul> <pre><code>class OpenAIProvider(LLMProvider):\n    def __init__(self, api_key: str):\n        self.client = OpenAI(api_key=api_key)\n\n    async def complete(self, prompt: str) -&gt; str:\n        response = await self.client.completions.create(\n            model=\"gpt-4\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        return response.choices[0].message.content\n</code></pre> <p>The magic: Swap <code>OpenAIProvider</code> for <code>AnthropicProvider</code> and your entire app just works with a different AI provider. No changes to business logic needed.</p>"},{"location":"#4-compose-wiring-it-all-together","title":"4. Compose - Wiring It All Together","text":"<p>The <code>compose</code> module is the only place in Portico that imports adapters. This is your \"composition root\" - where you decide which concrete implementations to use.</p> <pre><code>from portico import compose\n\n# Define your stack\napp = compose.webapp(\n    auth=compose.auth(),\n    user=compose.user(),\n    llm=compose.llm(provider=\"openai\", api_key=\"...\"),\n    cache=compose.cache(adapter=\"redis\", url=\"...\"),\n    database=compose.database(adapter=\"postgres\", url=\"...\")\n)\n\n# Use it in your routes\n@app.route(\"/generate\")\nasync def generate(request):\n    result = await app.llm.generate(request.prompt)\n    return {\"result\": result}\n</code></pre> <p>Ready to dive in? Check out the philosophy to understand the design principles, or explore the example applications to see Portico in action.</p>"},{"location":"philosophy/","title":"Philosophy","text":"<p>Portico is built on the principles of hexagonal architecture (also known as ports and adapters). This isn't just academic theory - it's a practical approach to building applications that stay maintainable as they grow from prototype to production.</p>"},{"location":"philosophy/#core-principles","title":"Core Principles","text":""},{"location":"philosophy/#separation-of-concerns","title":"Separation of Concerns","text":"<p>Your business logic should be independent of implementation details. Whether you're using OpenAI or Anthropic, PostgreSQL or SQLite, Redis or in-memory caching - these are deployment decisions, not architecture decisions. Your core application logic shouldn't change when you swap out infrastructure.</p>"},{"location":"philosophy/#dependency-inversion","title":"Dependency Inversion","text":"<p>Kits (your business logic) depend on ports (interfaces), never on adapters (implementations). This inversion means you can test your logic without external dependencies, swap implementations without code changes, and keep your architecture clean as complexity grows.</p>"},{"location":"philosophy/#composition-root","title":"Composition Root","text":"<p>There's exactly one place in your codebase where concrete implementations are chosen: the <code>compose</code> module. This forces architectural discipline and makes it obvious where dependencies are wired together. If a kit imports an adapter directly, the build fails. Architecture is enforced by tooling, not just documentation.</p>"},{"location":"philosophy/#why-this-approach-wins","title":"Why This Approach Wins","text":""},{"location":"philosophy/#1-swap-implementations-instantly","title":"1. Swap implementations instantly","text":"<p>Need to switch from OpenAI to Anthropic? Change one line in your config. Want to test with SQLite locally but use PostgreSQL in production? Same code, different adapter.</p> <pre><code># Development\nconfig = {\n    \"llm\": compose.llm(provider=\"openai\", api_key=\"...\"),\n    \"database\": compose.database(adapter=\"sqlite\", path=\"./dev.db\")\n}\n\n# Production\nconfig = {\n    \"llm\": compose.llm(provider=\"anthropic\", api_key=\"...\"),\n    \"database\": compose.database(adapter=\"postgres\", url=\"...\")\n}\n</code></pre>"},{"location":"philosophy/#2-test-your-logic-without-external-dependencies","title":"2. Test your logic without external dependencies","text":"<p>Since kits only depend on ports, you can test your business logic with fake implementations:</p> <pre><code>class FakeLLMProvider(LLMProvider):\n    async def complete(self, prompt: str) -&gt; str:\n        return \"Fake response for testing\"\n\n# Test your business logic without calling real APIs\nkit = LLMKit(FakeLLMProvider())\nresult = await kit.generate(\"test prompt\")\nassert result == \"Fake response for testing\"\n</code></pre>"},{"location":"philosophy/#3-your-codebase-stays-clean","title":"3. Your codebase stays clean","text":"<p>Without architecture boundaries, dependencies creep everywhere. Three months later, your auth code is importing database models, your API routes are calling external services directly, and changing anything breaks everything.</p> <p>Portico enforces clean boundaries:</p> <ul> <li>Kits \u2192 can only import Ports</li> <li>Ports \u2192 can't import anything except standard library</li> <li>Adapters \u2192 implement Ports, can import external libraries</li> <li>Compose \u2192 the only place that wires Kits + Adapters together</li> </ul> <p>These rules are checked on every build. Your architecture stays clean automatically.</p>"},{"location":"philosophy/#4-start-simple-scale-when-ready","title":"4. Start simple, scale when ready","text":"<p>Begin with in-memory caching and SQLite. When you need to scale, swap in Redis and PostgreSQL. Same business logic, zero rewrites.</p> <pre><code># Week 1 - MVP\ncompose.cache(adapter=\"memory\")  # Good enough\n\n# Month 3 - Growth\ncompose.cache(adapter=\"redis\", url=\"redis://...\")  # Same interface, better performance\n</code></pre>"},{"location":"philosophy/#what-this-means-in-practice","title":"What This Means in Practice","text":""},{"location":"philosophy/#for-prototyping","title":"For Prototyping","text":"<p>Start with the simplest possible implementations. In-memory caching, SQLite databases, fake LLM providers for testing. Focus on your business logic and user experience, not infrastructure decisions.</p>"},{"location":"philosophy/#for-testing","title":"For Testing","text":"<p>Test your business logic in isolation. No need to spin up databases, mock external APIs, or configure complex test fixtures. Your kits work with any implementation of their ports.</p>"},{"location":"philosophy/#for-production","title":"For Production","text":"<p>When you're ready to scale, swap in production-grade implementations. Redis for caching, PostgreSQL for persistence, real LLM providers. Your business logic doesn't change - only your composition root configuration.</p>"},{"location":"philosophy/#for-maintenance","title":"For Maintenance","text":"<p>Six months from now, when you need to add a new feature or fix a bug, you'll find code that's organized by concern, not by technology. Auth logic lives in AuthKit, not scattered across route handlers, database models, and middleware.</p>"},{"location":"philosophy/#the-trade-offs","title":"The Trade-offs","text":"<p>Hexagonal architecture isn't free. You write more files (ports, adapters, kits instead of just \"code\"). You have a level of indirection between your business logic and external services. You need to think about interfaces upfront.</p> <p>But here's the thing: if you're using Portico, we've already done this work for you. The ports are defined. The adapters are implemented. The kits are built and tested. You get all the benefits of hexagonal architecture without having to design and build it yourself.</p> <p>The payoff is huge:</p> <ul> <li>Flexibility - Change implementations without touching business logic</li> <li>Testability - Test without external dependencies</li> <li>Clarity - Clear boundaries between concerns</li> <li>Maintainability - Architecture that scales with complexity</li> </ul> <p>Portico makes this trade-off for you: we invest in the upfront structure so you get long-term maintainability out of the box.</p> <p>Ready to see this in action? Check out the example applications or dive into the documentation.</p>"},{"location":"adapters/","title":"Adapters","text":"<p>In Portico's hexagonal architecture, adapters are the concrete implementations that connect your business logic to the outside world. While ports define what operations are needed and kits orchestrate business logic, adapters provide the how - the actual integration with databases, APIs, cloud services, and external systems.</p>"},{"location":"adapters/#what-is-an-adapter","title":"What is an Adapter?","text":"<p>An adapter is a concrete implementation of a port interface that handles all the technology-specific details of working with external systems. Think of adapters as translators between your clean domain models and the messy realities of third-party APIs, database schemas, and infrastructure services.</p> <p>In traditional applications, external integrations often pollute business logic:</p> <pre><code># Traditional approach - business logic mixed with infrastructure\n\nfrom openai import OpenAI\nfrom redis import Redis\nimport sqlalchemy\n\nclass ChatService:\n    def __init__(self):\n        # Direct dependencies on external libraries\n        self.openai_client = OpenAI(api_key=\"...\")\n        self.redis = Redis(host=\"localhost\")\n        self.db = sqlalchemy.create_engine(\"postgresql://...\")\n\n    async def generate_response(self, prompt: str) -&gt; str:\n        # Check cache with Redis-specific code\n        cached = self.redis.get(f\"chat:{prompt}\")\n        if cached:\n            return cached.decode()\n\n        # Call OpenAI with SDK-specific code\n        response = self.openai_client.chat.completions.create(\n            model=\"gpt-4\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        result = response.choices[0].message.content\n\n        # Store with Redis-specific code\n        self.redis.set(f\"chat:{prompt}\", result, ex=3600)\n\n        return result\n</code></pre> <p>This approach creates several problems:</p> <ul> <li>Tight coupling to specific technologies (Redis, OpenAI)</li> <li>Testing requires running Redis and mocking OpenAI</li> <li>Switching providers means rewriting the service</li> <li>Configuration details mixed with business logic</li> </ul> <p>With adapters, infrastructure is isolated:</p> <pre><code># Adapter approach - business logic stays clean\n\nfrom portico.ports.cache import CacheAdapter, CacheKey\nfrom portico.ports.llm import ChatCompletionProvider, ChatCompletionRequest\n\nclass ChatService:\n    def __init__(\n        self,\n        llm_provider: ChatCompletionProvider,  # Port interface\n        cache: CacheAdapter  # Port interface\n    ):\n        self.llm = llm_provider\n        self.cache = cache\n\n    async def generate_response(self, prompt: str) -&gt; str:\n        # Check cache using port interface\n        cache_key = CacheKey(key=f\"chat:{prompt}\")\n        cached = await self.cache.get(cache_key)\n        if cached:\n            return cached.value\n\n        # Call LLM using port interface\n        request = ChatCompletionRequest(\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        response = await self.llm.complete(request)\n        result = response.content\n\n        # Store using port interface\n        await self.cache.set(cache_key, result, ttl=3600)\n\n        return result\n</code></pre> <p>The service has no idea if it's using OpenAI or Anthropic, Redis or Memcached. All infrastructure details are in adapters that implement the port interfaces.</p>"},{"location":"adapters/#why-adapters-matter","title":"Why Adapters Matter","text":"<p>Adapters provide several critical benefits:</p>"},{"location":"adapters/#swap-implementations-freely","title":"Swap Implementations Freely","text":"<p>Need to switch from OpenAI to Anthropic? Change one line in your composition root:</p> <pre><code># Before\napp = compose.webapp(\n    kits=[compose.llm(provider=\"openai\", api_key=\"sk-...\")]\n)\n\n# After - same business logic, different implementation\napp = compose.webapp(\n    kits=[compose.llm(provider=\"anthropic\", api_key=\"sk-ant-...\")]\n)\n</code></pre> <p>Your kits don't change at all. The adapter handles all provider-specific details.</p>"},{"location":"adapters/#test-without-external-dependencies","title":"Test Without External Dependencies","text":"<p>Adapters make testing fast and reliable:</p> <pre><code># Fake adapter for testing\nclass FakeLLMProvider(ChatCompletionProvider):\n    async def complete(self, request: ChatCompletionRequest) -&gt; ChatCompletionResponse:\n        return ChatCompletionResponse(content=\"Fake response for testing\")\n\n# Test without calling real API\nfake_llm = FakeLLMProvider()\nservice = ChatService(llm_provider=fake_llm, cache=fake_cache)\n\nresponse = await service.generate_response(\"test prompt\")\nassert response == \"Fake response for testing\"\n</code></pre> <p>No API keys, no network calls, no flaky tests.</p>"},{"location":"adapters/#start-simple-scale-later","title":"Start Simple, Scale Later","text":"<p>Use lightweight implementations during development, production-grade ones in deployment:</p> <pre><code># Development - in-memory, no external services\napp = compose.webapp(\n    database_url=\"sqlite:///dev.db\",\n    kits=[\n        compose.cache(backend=\"memory\"),\n        compose.llm(provider=\"openai\", api_key=\"test-key\"),\n    ]\n)\n\n# Production - distributed, resilient\napp = compose.webapp(\n    database_url=\"postgresql://prod-db/myapp\",\n    kits=[\n        compose.cache(backend=\"redis\", redis_url=\"redis://prod-cache\"),\n        compose.llm(provider=\"openai\", api_key=os.environ[\"OPENAI_KEY\"]),\n    ]\n)\n</code></pre> <p>Same business logic, different infrastructure.</p>"},{"location":"adapters/#adapter-anatomy","title":"Adapter Anatomy","text":"<p>Every Portico adapter follows consistent structural patterns that make them predictable and composable.</p>"},{"location":"adapters/#1-port-interface-implementation","title":"1. Port Interface Implementation","text":"<p>Adapters implement port interfaces using Python's abstract base classes:</p> <pre><code>from portico.ports.cache import CacheAdapter, CacheKey, CacheEntry\nfrom typing import Optional\nimport redis.asyncio as redis\n\nclass RedisCacheAdapter(CacheAdapter):\n    \"\"\"Redis-backed cache implementation.\n\n    Implements the CacheAdapter port using Redis for distributed caching.\n    \"\"\"\n\n    def __init__(self, redis_url: str, db: int = 0):\n        \"\"\"Initialize Redis connection.\n\n        Args:\n            redis_url: Redis connection string (redis://host:port)\n            db: Redis database number (default: 0)\n        \"\"\"\n        self.redis_url = redis_url\n        self.db = db\n        self._client: Optional[redis.Redis] = None\n\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        \"\"\"Retrieve value from Redis cache.\"\"\"\n        client = await self._get_client()\n        value = await client.get(key.key)\n\n        if value:\n            return CacheEntry(\n                key=key.key,\n                value=self._deserialize(value),\n                ttl=await client.ttl(key.key)\n            )\n        return None\n\n    async def set(self, key: CacheKey, value: Any, ttl: Optional[int] = None) -&gt; None:\n        \"\"\"Store value in Redis cache.\"\"\"\n        client = await self._get_client()\n        serialized = self._serialize(value)\n        await client.set(key.key, serialized, ex=ttl)\n\n    async def _get_client(self) -&gt; redis.Redis:\n        \"\"\"Lazy connection initialization.\"\"\"\n        if not self._client:\n            self._client = redis.Redis.from_url(self.redis_url, db=self.db)\n        return self._client\n\n    def _serialize(self, value: Any) -&gt; bytes:\n        \"\"\"Convert Python object to bytes for storage.\"\"\"\n        return pickle.dumps(value)\n\n    def _deserialize(self, data: bytes) -&gt; Any:\n        \"\"\"Convert stored bytes back to Python object.\"\"\"\n        return pickle.loads(data)\n</code></pre> <p>Key characteristics:</p> <ul> <li>Inherits from port interface (<code>CacheAdapter</code>)</li> <li>Implements all abstract methods required by the port</li> <li>Handles technology specifics (Redis connection, serialization)</li> <li>Converts between domain and tech models (CacheKey \u2194 Redis keys)</li> <li>Manages resources (connection pooling, cleanup)</li> </ul>"},{"location":"adapters/#2-configuration","title":"2. Configuration","text":"<p>Adapters accept configuration through constructors:</p> <pre><code>class OpenAIProvider(ChatCompletionProvider):\n    \"\"\"OpenAI LLM provider implementation.\"\"\"\n\n    def __init__(\n        self,\n        api_key: str,\n        default_model: str = \"gpt-4o-mini\",\n        timeout: int = 30,\n        max_retries: int = 3\n    ):\n        \"\"\"Initialize OpenAI client.\n\n        Args:\n            api_key: OpenAI API key\n            default_model: Default model to use if not specified in request\n            timeout: Request timeout in seconds\n            max_retries: Number of retry attempts on failure\n        \"\"\"\n        self.api_key = api_key\n        self.default_model = default_model\n        self.timeout = timeout\n        self.max_retries = max_retries\n\n        # Initialize SDK client\n        from openai import AsyncOpenAI\n        self.client = AsyncOpenAI(\n            api_key=api_key,\n            timeout=timeout,\n            max_retries=max_retries\n        )\n</code></pre> <p>Configuration is:</p> <ul> <li>Passed at construction time (not loaded internally)</li> <li>Validated early (fail fast if misconfigured)</li> <li>Type-safe (with type hints)</li> <li>Documented (with docstrings)</li> </ul>"},{"location":"adapters/#3-domain-model-translation","title":"3. Domain Model Translation","text":"<p>Adapters translate between domain models (defined in ports) and technology models (from SDKs/libraries):</p> <pre><code>class OpenAIProvider(ChatCompletionProvider):\n    async def complete(\n        self,\n        request: ChatCompletionRequest  # Domain model from port\n    ) -&gt; ChatCompletionResponse:  # Domain model to port\n        \"\"\"Generate chat completion using OpenAI.\"\"\"\n\n        # Translate domain request to OpenAI SDK format\n        openai_messages = [\n            {\n                \"role\": msg.role.value.lower(),  # Convert enum to string\n                \"content\": msg.content\n            }\n            for msg in request.messages\n        ]\n\n        # Call OpenAI SDK with provider-specific format\n        response = await self.client.chat.completions.create(\n            model=request.model or self.default_model,\n            messages=openai_messages,\n            temperature=request.temperature,\n            max_tokens=request.max_tokens,\n        )\n\n        # Translate OpenAI response to domain model\n        return ChatCompletionResponse(\n            content=response.choices[0].message.content,\n            model=response.model,\n            usage=Usage(\n                prompt_tokens=response.usage.prompt_tokens,\n                completion_tokens=response.usage.completion_tokens,\n                total_tokens=response.usage.total_tokens\n            )\n        )\n</code></pre> <p>This translation layer: - Shields business logic from SDK changes - Normalizes across providers (OpenAI and Anthropic have different APIs) - Enforces domain contracts (Pydantic validation on domain models) - Makes testing easier (mock domain models, not SDK responses)</p>"},{"location":"adapters/#4-error-handling","title":"4. Error Handling","text":"<p>Adapters catch technology-specific errors and translate them to domain exceptions:</p> <pre><code>from portico.exceptions import LLMError, LLMRateLimitError, LLMInvalidRequestError\nfrom openai import OpenAIError, RateLimitError, APIError\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass OpenAIProvider(ChatCompletionProvider):\n    async def complete(self, request: ChatCompletionRequest) -&gt; ChatCompletionResponse:\n        try:\n            # Call OpenAI SDK\n            response = await self.client.chat.completions.create(...)\n            return self._to_domain_response(response)\n\n        except RateLimitError as e:\n            # Translate to domain exception\n            logger.warning(\"openai_rate_limit\", error=str(e))\n            raise LLMRateLimitError(\n                \"OpenAI rate limit exceeded. Please try again later.\"\n            ) from e\n\n        except APIError as e:\n            # Translate to domain exception\n            logger.error(\"openai_api_error\", status=e.status_code, error=str(e))\n            if e.status_code == 400:\n                raise LLMInvalidRequestError(\n                    f\"Invalid request to OpenAI: {e.message}\"\n                ) from e\n            raise LLMError(f\"OpenAI API error: {e.message}\") from e\n\n        except OpenAIError as e:\n            # Catch-all for SDK errors\n            logger.error(\"openai_error\", error=str(e))\n            raise LLMError(f\"OpenAI error: {str(e)}\") from e\n\n        except Exception as e:\n            # Unexpected errors\n            logger.error(\"unexpected_error\", error=str(e), error_type=type(e).__name__)\n            raise LLMError(f\"Unexpected error: {str(e)}\") from e\n</code></pre> <p>Error handling provides: - Domain-specific exceptions that kits understand - Consistent error interface across different adapters - Logging for debugging and monitoring - Error chaining (<code>from e</code>) to preserve stack traces - Graceful degradation where appropriate</p>"},{"location":"adapters/#5-resource-management","title":"5. Resource Management","text":"<p>Adapters manage external resources (connections, clients, file handles):</p> <pre><code>class RedisCacheAdapter(CacheAdapter):\n    def __init__(self, redis_url: str):\n        self.redis_url = redis_url\n        self._client: Optional[redis.Redis] = None\n\n    async def _get_client(self) -&gt; redis.Redis:\n        \"\"\"Lazy initialization of Redis connection.\"\"\"\n        if not self._client:\n            self._client = redis.Redis.from_url(\n                self.redis_url,\n                encoding=\"utf-8\",\n                decode_responses=False,\n                socket_connect_timeout=5,\n                socket_keepalive=True,\n            )\n        return self._client\n\n    async def close(self) -&gt; None:\n        \"\"\"Clean up resources on shutdown.\"\"\"\n        if self._client:\n            await self._client.close()\n            self._client = None\n\n    async def __aenter__(self):\n        \"\"\"Context manager support.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Ensure cleanup on context exit.\"\"\"\n        await self.close()\n</code></pre> <p>Resource patterns: - Lazy initialization (connect only when needed) - Connection pooling (reuse connections) - Cleanup methods (<code>close()</code>, <code>__aexit__</code>) - Context managers for automatic cleanup - Timeouts to prevent hanging</p>"},{"location":"adapters/#6-performance-tracking","title":"6. Performance Tracking","text":"<p>Many adapters track metrics for monitoring and optimization:</p> <pre><code>class MemoryCacheAdapter(CacheAdapter):\n    def __init__(self, max_size: int = 1000):\n        self.max_size = max_size\n        self._cache: Dict[str, CacheEntry] = {}\n\n        # Performance counters\n        self._hits = 0\n        self._misses = 0\n        self._evictions = 0\n        self._compressions = 0\n\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        entry = self._cache.get(key.key)\n\n        if entry:\n            self._hits += 1  # Track hit\n            return entry\n        else:\n            self._misses += 1  # Track miss\n            return None\n\n    async def get_stats(self) -&gt; CacheStats:\n        \"\"\"Export performance metrics.\"\"\"\n        total_requests = self._hits + self._misses\n        hit_rate = self._hits / total_requests if total_requests &gt; 0 else 0.0\n\n        return CacheStats(\n            total_entries=len(self._cache),\n            total_hits=self._hits,\n            total_misses=self._misses,\n            total_evictions=self._evictions,\n            hit_rate=hit_rate,\n            compression_count=self._compressions\n        )\n</code></pre> <p>Metrics help with: - Performance monitoring (hit rates, latency) - Capacity planning (eviction rates, entry counts) - Cost optimization (API call counts, token usage) - Debugging (failure rates, retry counts)</p>"},{"location":"adapters/#adapter-types","title":"Adapter Types","text":"<p>Portico adapters fall into several categories based on what they integrate with:</p>"},{"location":"adapters/#infrastructure-adapters","title":"Infrastructure Adapters","text":"<p>These integrate with foundational infrastructure services:</p> <p>Caching: Memory, Redis, hybrid two-tier caching Storage: Local filesystem, cloud storage (GCS), database BLOBs Notifications: Email, SMS, push notifications Session: Cookie-based, database-backed, distributed</p> <p>Infrastructure adapters typically: - Implement simple, focused operations (get, set, delete) - Provide multiple implementation choices (local, cloud, distributed) - Support configuration tuning (TTL, size limits, compression) - Include development alternatives (memory-based for testing)</p>"},{"location":"adapters/#external-service-adapters","title":"External Service Adapters","text":"<p>These integrate with third-party APIs and services:</p> <p>LLM Providers: OpenAI, Anthropic, local models Embedding Providers: OpenAI embeddings, custom models Managed Platforms: Graphlit (RAG), Pinecone (vectors) Payment Gateways: Stripe, PayPal (in your apps)</p> <p>External service adapters typically: - Wrap SDK clients from vendor libraries - Handle authentication (API keys, OAuth) - Implement retry logic for network failures - Translate rate limits to domain exceptions - Normalize responses across providers</p>"},{"location":"adapters/#data-access-adapters","title":"Data Access Adapters","text":"<p>These implement repository interfaces for database operations:</p> <p>User Repository: CRUD operations for users Group Repository: Hierarchical group management Audit Repository: Event logging and queries File Metadata Repository: File tracking</p> <p>Data access adapters typically: - Use SQLAlchemy for ORM operations - Manage transactions and sessions - Convert ORM models to domain models - Handle database-specific SQL and constraints</p>"},{"location":"adapters/#processing-adapters","title":"Processing Adapters","text":"<p>These perform data transformation and analysis:</p> <p>Document Processor: Parse and chunk documents Template Renderer: Jinja2 template rendering Job Scheduler: Cron-based job triggering</p> <p>Processing adapters typically: - Implement algorithms (chunking strategies, rendering) - Use specialized libraries (Jinja2, parsers) - Provide configuration options (chunk size, strategies) - Return structured results (processed documents, rendered templates)</p>"},{"location":"adapters/#how-adapters-relate-to-ports-and-kits","title":"How Adapters Relate to Ports and Kits","text":"<p>Adapters complete the hexagonal architecture by implementing the port interfaces that kits depend on:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Application Layer (Routes, CLI)        \u2502\n\u2502  - FastAPI routes                       \u2502\n\u2502  - CLI commands                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502 Calls\n                  \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Kits (Business Logic)                  \u2502\n\u2502  - Services orchestrate workflows       \u2502\n\u2502  - Repositories abstract data access    \u2502\n\u2502  - Depend on PORT INTERFACES            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502 Uses\n                  \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Ports (Interfaces)                     \u2502\n\u2502  - Define contracts (ABC/Protocol)      \u2502\n\u2502  - Domain models (Pydantic)             \u2502\n\u2502  - No implementation                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2191 Implements\n                  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Adapters (Implementations)             \u2502\n\u2502  - Concrete implementations             \u2502\n\u2502  - Technology-specific code             \u2502\n\u2502  - External library integration         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"adapters/#the-composition-root-pattern","title":"The Composition Root Pattern","text":"<p>Here's the critical architectural rule: Kits never import adapters directly. Only the composition root (<code>compose.py</code>) imports and instantiates adapters:</p> <pre><code># portico/compose.py - The ONLY place adapters are imported\n\ndef cache(**config):\n    \"\"\"Factory function for cache kit.\"\"\"\n    # Adapter import - ONLY happens here!\n    from portico.adapters.cache import RedisCacheAdapter, MemoryCacheAdapter\n    from portico.kits.cache import CacheKit\n\n    def factory(database: Database, events: EventBus):\n        # Choose adapter based on configuration\n        if config.get(\"backend\") == \"redis\":\n            adapter = RedisCacheAdapter(\n                redis_url=config[\"redis_url\"],\n                db=config.get(\"db\", 0)\n            )\n        else:\n            adapter = MemoryCacheAdapter(\n                max_size=config.get(\"max_memory_items\", 1000)\n            )\n\n        # Inject adapter into kit\n        return CacheKit.create(database, events, config, cache_adapter=adapter)\n\n    return factory\n</code></pre> <p>This pattern: - Enforces clean architecture (kits can't accidentally couple to adapters) - Centralizes configuration (one place to change implementations) - Makes swapping easy (change one line to use different adapter) - Enables testing (inject fake adapters in tests)</p> <p>The pattern is enforced by tooling - if a kit imports an adapter, <code>make check-imports</code> fails:</p> <pre><code>$ make check-imports\nERROR: Contract violated: Kits cannot import adapters\n  portico/kits/cache/service.py imports portico.adapters.cache.RedisCacheAdapter\n</code></pre>"},{"location":"adapters/#kits-depend-on-ports-not-adapters","title":"Kits Depend on Ports, Not Adapters","text":"<pre><code># \u2705 CORRECT - Kit imports port\nfrom portico.ports.cache import CacheAdapter, CacheKey\n\nclass CacheService:\n    def __init__(self, cache_adapter: CacheAdapter):  # Interface!\n        self.adapter = cache_adapter\n\n    async def get(self, key: str):\n        cache_key = CacheKey(key=key)\n        return await self.adapter.get(cache_key)\n\n# \u274c WRONG - Kit imports adapter\nfrom portico.adapters.cache import RedisCacheAdapter  # Violation!\n\nclass CacheService:\n    def __init__(self):\n        self.adapter = RedisCacheAdapter(redis_url=\"...\")  # Coupled!\n</code></pre>"},{"location":"adapters/#testing-adapters","title":"Testing Adapters","text":"<p>Adapters are tested at multiple levels to ensure correctness and reliability.</p>"},{"location":"adapters/#unit-testing-adapters","title":"Unit Testing Adapters","text":"<p>Test adapter logic in isolation with mocked external dependencies:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock, patch\nfrom portico.adapters.llm import OpenAIProvider\nfrom portico.ports.llm import ChatCompletionRequest, Message, MessageRole\n\n@pytest.mark.asyncio\nasync def test_openai_provider_complete():\n    \"\"\"Test OpenAI adapter translates domain models correctly.\"\"\"\n\n    # Mock OpenAI SDK response\n    mock_response = Mock()\n    mock_response.choices = [Mock(message=Mock(content=\"Test response\"))]\n    mock_response.model = \"gpt-4o-mini\"\n    mock_response.usage = Mock(\n        prompt_tokens=10,\n        completion_tokens=5,\n        total_tokens=15\n    )\n\n    # Patch OpenAI SDK\n    with patch(\"openai.AsyncOpenAI\") as mock_client_class:\n        mock_client = AsyncMock()\n        mock_client.chat.completions.create.return_value = mock_response\n        mock_client_class.return_value = mock_client\n\n        # Test adapter\n        provider = OpenAIProvider(api_key=\"test-key\")\n        request = ChatCompletionRequest(\n            messages=[Message(role=MessageRole.USER, content=\"Hello\")]\n        )\n\n        response = await provider.complete(request)\n\n        # Verify domain model translation\n        assert response.content == \"Test response\"\n        assert response.model == \"gpt-4o-mini\"\n        assert response.usage.total_tokens == 15\n</code></pre>"},{"location":"adapters/#integration-testing-adapters","title":"Integration Testing Adapters","text":"<p>Test adapters against real external services (with test credentials):</p> <pre><code>import pytest\nfrom portico.adapters.cache import RedisCacheAdapter\nfrom portico.ports.cache import CacheKey\n\n@pytest.mark.integration\n@pytest.mark.asyncio\nasync def test_redis_cache_adapter_integration():\n    \"\"\"Test Redis adapter with real Redis instance.\"\"\"\n\n    # Use test Redis instance\n    adapter = RedisCacheAdapter(redis_url=\"redis://localhost:6379/15\")\n\n    try:\n        # Test operations\n        key = CacheKey(key=\"test:integration\")\n\n        # Set value\n        await adapter.set(key, \"test value\", ttl=60)\n\n        # Get value\n        entry = await adapter.get(key)\n        assert entry is not None\n        assert entry.value == \"test value\"\n\n        # Delete value\n        deleted = await adapter.delete(key)\n        assert deleted is True\n\n        # Verify deleted\n        entry = await adapter.get(key)\n        assert entry is None\n\n    finally:\n        # Cleanup\n        await adapter.close()\n</code></pre>"},{"location":"adapters/#testing-kits-with-fake-adapters","title":"Testing Kits with Fake Adapters","text":"<p>The real power comes from testing kits with fake adapters:</p> <pre><code>from portico.ports.cache import CacheAdapter, CacheKey, CacheEntry\nfrom typing import Dict, Optional\n\nclass FakeCacheAdapter(CacheAdapter):\n    \"\"\"In-memory fake for testing kits.\"\"\"\n\n    def __init__(self):\n        self._data: Dict[str, CacheEntry] = {}\n\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        return self._data.get(key.key)\n\n    async def set(self, key: CacheKey, value: Any, ttl: Optional[int] = None) -&gt; None:\n        self._data[key.key] = CacheEntry(key=key.key, value=value, ttl=ttl)\n\n    async def delete(self, key: CacheKey) -&gt; bool:\n        if key.key in self._data:\n            del self._data[key.key]\n            return True\n        return False\n\n# Test kit with fake\n@pytest.mark.asyncio\nasync def test_user_service_with_cache():\n    fake_cache = FakeCacheAdapter()\n    fake_user_repo = FakeUserRepository()\n\n    service = UserService(\n        user_repository=fake_user_repo,\n        cache=fake_cache\n    )\n\n    # Test caching behavior without running Redis\n    user = await service.get_user(user_id)\n    assert fake_cache._data  # Cache was populated\n\n    # Second call hits cache\n    cached_user = await service.get_user(user_id)\n    assert cached_user == user\n</code></pre> <p>Fake adapters are fast (no network), deterministic (no flaky tests), and easy to control (inject specific behaviors).</p>"},{"location":"adapters/#adapter-composition","title":"Adapter Composition","text":"<p>Adapters are composed in your application through the <code>compose.webapp()</code> function:</p>"},{"location":"adapters/#basic-composition","title":"Basic Composition","text":"<pre><code>from portico import compose\n\napp = compose.webapp(\n    database_url=\"postgresql://localhost/myapp\",\n    kits=[\n        compose.cache(backend=\"redis\", redis_url=\"redis://localhost:6379\"),\n        compose.llm(provider=\"openai\", api_key=\"sk-...\"),\n        compose.file(storage_backend=\"gcs\", gcs_bucket=\"my-bucket\"),\n    ]\n)\n</code></pre> <p>The compose system: 1. Reads configuration from kit factory functions 2. Instantiates adapters based on config 3. Injects adapters into kits via dependency injection 4. Returns configured application with all kits wired up</p>"},{"location":"adapters/#multiple-adapters-per-port","title":"Multiple Adapters per Port","text":"<p>Some kits may use multiple adapters:</p> <pre><code># RAG kit uses multiple adapters\napp = compose.webapp(\n    kits=[\n        compose.rag(\n            # Each adapter implements a different port\n            use_managed_rag=False,  # DIY RAG mode\n            vector_store_type=\"memory\",\n            embedding_provider=\"openai\",\n            embedding_api_key=\"sk-...\",\n            document_processor_config={\n                \"chunking_strategy\": \"paragraph\",\n                \"chunk_size\": 1000,\n            }\n        )\n    ]\n)\n</code></pre> <p>The RAG kit receives: - VectorStore adapter (MemoryVectorStore) - EmbeddingProvider adapter (OpenAIEmbeddingProvider) - DocumentProcessor adapter (BasicDocumentProcessor)</p> <p>All injected through the composition root.</p>"},{"location":"adapters/#environment-specific-composition","title":"Environment-Specific Composition","text":"<p>Use environment variables to configure adapters differently per environment:</p> <pre><code>import os\n\n# Determine environment\nis_production = os.environ.get(\"ENV\") == \"production\"\n\napp = compose.webapp(\n    database_url=os.environ[\"DATABASE_URL\"],\n    kits=[\n        # Use Redis in production, memory in development\n        compose.cache(\n            backend=\"redis\" if is_production else \"memory\",\n            redis_url=os.environ.get(\"REDIS_URL\") if is_production else None,\n        ),\n\n        # Use different LLM models per environment\n        compose.llm(\n            provider=\"openai\",\n            api_key=os.environ[\"OPENAI_KEY\"],\n            model=\"gpt-4\" if is_production else \"gpt-4o-mini\"\n        ),\n    ]\n)\n</code></pre> <p>Same application code, different adapters per environment.</p>"},{"location":"adapters/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":""},{"location":"adapters/#lazy-initialization","title":"Lazy Initialization","text":"<p>Initialize expensive resources only when first needed:</p> <pre><code>class DatabaseAdapter:\n    def __init__(self, connection_url: str):\n        self.connection_url = connection_url\n        self._engine: Optional[Engine] = None\n\n    async def _get_engine(self) -&gt; Engine:\n        \"\"\"Lazy initialization of database engine.\"\"\"\n        if not self._engine:\n            self._engine = create_async_engine(\n                self.connection_url,\n                pool_size=10,\n                max_overflow=20\n            )\n        return self._engine\n\n    async def query(self, sql: str):\n        engine = await self._get_engine()  # Initialize on first use\n        # ... execute query\n</code></pre> <p>Benefits: - Faster startup (don't connect to everything immediately) - Conditional usage (only connect if feature is used) - Easier testing (adapter can be created without real connections)</p>"},{"location":"adapters/#connection-pooling","title":"Connection Pooling","text":"<p>Reuse connections for performance:</p> <pre><code>class RedisCacheAdapter:\n    def __init__(self, redis_url: str, pool_size: int = 10):\n        self.redis_url = redis_url\n        self.pool = redis.ConnectionPool.from_url(\n            redis_url,\n            max_connections=pool_size,\n            decode_responses=False\n        )\n        self._client = redis.Redis(connection_pool=self.pool)\n\n    async def close(self):\n        \"\"\"Clean up connection pool.\"\"\"\n        await self._client.close()\n        await self.pool.disconnect()\n</code></pre>"},{"location":"adapters/#graceful-degradation","title":"Graceful Degradation","text":"<p>Handle failures gracefully when possible:</p> <pre><code>class HybridCacheAdapter:\n    \"\"\"Two-tier cache: memory (L1) + Redis (L2).\"\"\"\n\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        # Try L1 (memory) first\n        entry = await self.memory_cache.get(key)\n        if entry:\n            return entry\n\n        # Try L2 (Redis) second\n        try:\n            entry = await self.redis_cache.get(key)\n            if entry:\n                # Warm L1 cache\n                await self.memory_cache.set(key, entry.value, ttl=entry.ttl)\n            return entry\n        except RedisError:\n            # Redis down - degrade gracefully to memory-only\n            logger.warning(\"redis_unavailable\", key=key.key)\n            return None  # Cache miss, not error\n</code></pre>"},{"location":"adapters/#configuration-validation","title":"Configuration Validation","text":"<p>Validate configuration early to fail fast:</p> <pre><code>class GCSFileStorageAdapter:\n    def __init__(\n        self,\n        bucket_name: str,\n        project_id: str,\n        credentials_path: Optional[str] = None\n    ):\n        # Validate required config\n        if not bucket_name:\n            raise ValueError(\"bucket_name is required\")\n        if not project_id:\n            raise ValueError(\"project_id is required\")\n\n        # Validate credentials path exists\n        if credentials_path and not os.path.exists(credentials_path):\n            raise ValueError(f\"Credentials file not found: {credentials_path}\")\n\n        self.bucket_name = bucket_name\n        self.project_id = project_id\n        self.credentials_path = credentials_path\n</code></pre>"},{"location":"adapters/#domain-exception-translation","title":"Domain Exception Translation","text":"<p>Always translate technology exceptions to domain exceptions:</p> <pre><code>from portico.exceptions import CacheError, CacheConnectionError\n\nclass RedisCacheAdapter:\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        try:\n            value = await self.client.get(key.key)\n            # ... process value\n        except redis.ConnectionError as e:\n            logger.error(\"redis_connection_error\", error=str(e))\n            raise CacheConnectionError(\n                \"Failed to connect to Redis\"\n            ) from e\n        except redis.RedisError as e:\n            logger.error(\"redis_error\", error=str(e))\n            raise CacheError(\n                f\"Redis operation failed: {str(e)}\"\n            ) from e\n</code></pre> <p>This allows kits to handle errors without knowing about Redis.</p>"},{"location":"adapters/#async-context-managers","title":"Async Context Managers","text":"<p>Provide context managers for resource cleanup:</p> <pre><code>class DatabaseAdapter:\n    async def __aenter__(self):\n        \"\"\"Initialize resources.\"\"\"\n        await self._connect()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Clean up resources.\"\"\"\n        await self._disconnect()\n\n# Usage\nasync with DatabaseAdapter(url=\"...\") as db:\n    result = await db.query(\"SELECT ...\")\n    # Resources cleaned up automatically\n</code></pre>"},{"location":"adapters/#logging-and-observability","title":"Logging and Observability","text":"<p>Include structured logging for debugging and monitoring:</p> <pre><code>import logging\nimport structlog\n\nlogger = structlog.get_logger(__name__)\n\nclass OpenAIProvider:\n    async def complete(self, request: ChatCompletionRequest) -&gt; ChatCompletionResponse:\n        logger.info(\n            \"llm_request\",\n            provider=\"openai\",\n            model=request.model or self.default_model,\n            message_count=len(request.messages)\n        )\n\n        try:\n            response = await self.client.chat.completions.create(...)\n\n            logger.info(\n                \"llm_response\",\n                model=response.model,\n                prompt_tokens=response.usage.prompt_tokens,\n                completion_tokens=response.usage.completion_tokens\n            )\n\n            return self._to_domain(response)\n\n        except Exception as e:\n            logger.error(\n                \"llm_error\",\n                provider=\"openai\",\n                error=str(e),\n                error_type=type(e).__name__\n            )\n            raise\n</code></pre>"},{"location":"adapters/#summary","title":"Summary","text":"<p>Adapters are the implementation layer of Portico's hexagonal architecture:</p> <ul> <li>Adapters implement ports - Concrete implementations of abstract interfaces</li> <li>Adapters handle technology - All external library and API integration</li> <li>Adapters translate models - Convert between domain and technology formats</li> <li>Adapters manage resources - Connections, cleanup, pooling</li> <li>Adapters are swappable - Change implementations without touching kits</li> <li>Adapters are testable - Unit test with mocks, integration test with real services</li> <li>Adapters are isolated - Only imported in compose.py, never in kits</li> </ul> <p>When building with Portico:</p> <ol> <li>Implement port interfaces - Inherit from port ABC/Protocol</li> <li>Accept configuration - Via constructor parameters</li> <li>Translate models - Domain \u2194 Technology conversions</li> <li>Handle errors gracefully - Translate to domain exceptions</li> <li>Manage resources - Lazy init, pooling, cleanup</li> <li>Add observability - Structured logging and metrics</li> <li>Test at multiple levels - Unit, integration, and fake adapters</li> </ol> <p>Understanding adapters completes your knowledge of Portico's architecture. They're the bridge between clean domain logic and the messy reality of external systems - and they keep that mess from leaking into your business logic.</p>"},{"location":"kits/","title":"Kits","text":"<p>In Portico's hexagonal architecture, kits are the business logic layer - the heart of your application where domain rules, workflows, and use cases live. While ports define what operations are possible and adapters provide how they're implemented, kits orchestrate these capabilities to deliver actual business value.</p>"},{"location":"kits/#what-is-a-kit","title":"What is a Kit?","text":"<p>A kit is a cohesive package of business logic that solves a specific domain problem. Think of it as a service layer that knows about your business rules but remains agnostic about infrastructure details.</p> <p>In traditional layered applications, business logic often gets scattered across controllers, models, and utility functions:</p> <pre><code># Traditional approach - business logic scattered everywhere\n\n# In routes.py\n@app.post(\"/users\")\nasync def create_user(username: str, email: str, password: str):\n    # Validation here\n    if len(password) &lt; 8:\n        raise ValueError(\"Password too short\")\n\n    # Hashing here\n    password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n\n    # Database here\n    user = User(username=username, email=email, password_hash=password_hash)\n    session.add(user)\n    await session.commit()\n\n    # Audit logging here\n    audit_log(f\"User {username} created\")\n\n    return user\n</code></pre> <p>With kits, business logic is centralized and testable:</p> <pre><code># Kit approach - business logic in service layer\n\nclass UserService:\n    def __init__(self, user_repository: UserRepository, events: EventBus, config: UserKitConfig):\n        self.repository = user_repository\n        self.events = events\n        self.config = config\n\n    async def create_user(self, user_data: CreateUserRequest) -&gt; User:\n        # Validation (using config)\n        self._validate_password(user_data.password)\n\n        # Business logic\n        password_hash = self._hash_password(user_data.password)\n        user = await self.repository.create(user_data, password_hash)\n\n        # Event publishing (other kits can react)\n        await self.events.publish(UserCreatedEvent(user_id=user.id, email=user.email))\n\n        return user\n\n# In routes.py - thin controller\n@app.post(\"/users\")\nasync def create_user(request: CreateUserRequest):\n    user = await app.kits.user.service.create_user(request)\n    return user\n</code></pre> <p>The kit approach means:</p> <ul> <li>Business logic is testable without running a web server</li> <li>Validation rules are centralized in one place</li> <li>Domain events decouple systems (audit kit can listen for UserCreatedEvent)</li> <li>Routes are thin - they just translate HTTP to domain operations</li> </ul>"},{"location":"kits/#kit-anatomy","title":"Kit Anatomy","text":"<p>Every Portico kit typically contains several components working together:</p>"},{"location":"kits/#1-service-layer","title":"1. Service Layer","text":"<p>The service is where your business logic lives. Services orchestrate operations, enforce business rules, and coordinate between repositories and external systems:</p> <pre><code>class UserService:\n    \"\"\"Service containing user management business logic.\"\"\"\n\n    def __init__(\n        self,\n        user_repository: UserRepository,\n        events: EventBus,\n        config: UserKitConfig\n    ):\n        self.repository = user_repository\n        self.events = events\n        self.config = config\n\n    async def create_user(self, user_data: CreateUserRequest) -&gt; User:\n        \"\"\"Create a new user with validation and event publishing.\"\"\"\n        # Business rule: validate password strength\n        if len(user_data.password) &lt; self.config.password_min_length:\n            raise ValueError(f\"Password must be at least {self.config.password_min_length} characters\")\n\n        # Business rule: ensure email uniqueness\n        existing = await self.repository.get_by_email(user_data.email)\n        if existing:\n            raise ValueError(\"Email already registered\")\n\n        # Execute operation\n        password_hash = self._hash_password(user_data.password)\n        user = await self.repository.create(user_data, password_hash)\n\n        # Publish domain event\n        await self.events.publish(UserCreatedEvent(user_id=user.id, email=user.email))\n\n        return user\n\n    def _hash_password(self, password: str) -&gt; str:\n        \"\"\"Private helper for password hashing.\"\"\"\n        return bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()\n</code></pre> <p>Services depend on port interfaces, never concrete implementations. This means the service can work with any repository that implements the <code>UserRepository</code> interface.</p>"},{"location":"kits/#2-repository-layer","title":"2. Repository Layer","text":"<p>Repositories handle data persistence. They implement the repository pattern, abstracting database operations behind a clean interface:</p> <pre><code>class UserRepository:\n    \"\"\"Repository for user persistence operations.\"\"\"\n\n    def __init__(self, database: Database):\n        self.database = database\n        self.session_factory = database.session_factory\n\n    async def create(self, user_data: CreateUserRequest, password_hash: str) -&gt; User:\n        \"\"\"Persist a new user to the database.\"\"\"\n        async with self.database.transaction() as session:\n            user_model = UserModel(\n                id=uuid4(),\n                username=user_data.username,\n                email=user_data.email,\n                password_hash=password_hash,\n                created_at=datetime.now(UTC)\n            )\n            session.add(user_model)\n            await session.flush()\n            await session.refresh(user_model)\n\n            # Convert ORM model to domain model\n            return user_model.to_domain()\n\n    async def get_by_email(self, email: str) -&gt; Optional[User]:\n        \"\"\"Retrieve user by email address.\"\"\"\n        async with self.database.session() as session:\n            result = await session.execute(\n                select(UserModel).where(UserModel.email == email)\n            )\n            user_model = result.scalar_one_or_none()\n            return user_model.to_domain() if user_model else None\n</code></pre> <p>Repositories:</p> <ul> <li>Hide database implementation details from services</li> <li>Use ORM models internally but return domain models (Pydantic)</li> <li>Handle transactions and session management</li> <li>Convert between persistence and domain layers</li> </ul>"},{"location":"kits/#3-configuration","title":"3. Configuration","text":"<p>Each kit has a configuration class that defines its settings:</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import Optional\n\n@dataclass\nclass UserKitConfig:\n    \"\"\"Configuration for User Kit.\"\"\"\n    password_min_length: int = 8\n    password_max_length: int = 128\n    username_pattern: str = r\"^[a-zA-Z0-9_]{3,50}$\"\n    allow_duplicate_emails: bool = False\n    default_status: str = \"active\"\n\n    # Optional integrations\n    audit_user_actions: bool = True\n    cache_user_lookups: bool = True\n    cache_ttl_seconds: int = 300\n</code></pre> <p>Configuration:</p> <ul> <li>Uses dataclasses for simplicity and validation</li> <li>Provides sensible defaults so kits work out of the box</li> <li>Typed and documented for IDE autocomplete</li> <li>Validated at kit initialization time</li> </ul>"},{"location":"kits/#4-domain-events","title":"4. Domain Events","text":"<p>Kits publish domain events when significant business activities occur:</p> <pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom uuid import UUID\nfrom portico.events import Event\n\n@dataclass\nclass UserCreatedEvent(Event):\n    \"\"\"Published when a new user is created.\"\"\"\n    user_id: UUID\n    email: str\n    username: str\n    timestamp: datetime = field(default_factory=lambda: datetime.now(UTC))\n\n@dataclass\nclass UserLoggedInEvent(Event):\n    \"\"\"Published when a user successfully authenticates.\"\"\"\n    user_id: UUID\n    session_id: UUID\n    ip_address: Optional[str]\n    timestamp: datetime = field(default_factory=lambda: datetime.now(UTC))\n</code></pre> <p>Events enable loose coupling between kits:</p> <pre><code># User kit publishes event\nawait self.events.publish(UserCreatedEvent(user_id=user.id, email=user.email))\n\n# Audit kit subscribes to event\n@subscribe_to(UserCreatedEvent)\nasync def log_user_creation(event: UserCreatedEvent):\n    await audit_kit.service.log_event(\n        action=AuditAction.CREATE,\n        resource_type=\"user\",\n        resource_id=event.user_id,\n        user_id=event.user_id\n    )\n</code></pre>"},{"location":"kits/#5-kit-class","title":"5. Kit Class","text":"<p>The kit class is the container that packages everything together:</p> <pre><code>from typing import List\nfrom sqlalchemy import Table\n\nclass UserKit:\n    \"\"\"User management kit providing user CRUD and authentication.\"\"\"\n\n    # SQLAlchemy models for database tables\n    models: List[type] = [UserModel]\n\n    def __init__(\n        self,\n        database: Database,\n        events: EventBus,\n        config: Optional[UserKitConfig] = None\n    ):\n        self.database = database\n        self.events = events\n        self.config = config or UserKitConfig()\n\n        # Initialize repository\n        self.repository = UserRepository(database=database)\n\n        # Initialize service\n        self.service = UserService(\n            user_repository=self.repository,\n            events=events,\n            config=self.config\n        )\n\n    @classmethod\n    def create(\n        cls,\n        database: Database,\n        events: EventBus,\n        config: Optional[dict] = None,\n        **kwargs\n    ) -&gt; \"UserKit\":\n        \"\"\"Factory method for creating kit with config validation.\"\"\"\n        validated_config = UserKitConfig(**(config or {}))\n        return cls(database, events, validated_config, **kwargs)\n</code></pre> <p>The kit class provides:</p> <ul> <li>Single entry point to all kit functionality</li> <li>Factory method for validated construction</li> <li>Model registration so compose.webapp() can create tables</li> <li>Service and repository access for application code</li> </ul>"},{"location":"kits/#kit-patterns","title":"Kit Patterns","text":"<p>Portico kits follow consistent patterns that make them predictable and composable.</p>"},{"location":"kits/#stateful-vs-stateless-kits","title":"Stateful vs Stateless Kits","text":""},{"location":"kits/#stateful-kits","title":"Stateful Kits","text":"<p>Stateful kits manage persistent domain entities and include database models:</p> <pre><code>class UserKit:\n    \"\"\"Stateful kit - manages User entities in database.\"\"\"\n\n    models = [UserModel]  # Defines database tables\n\n    def __init__(self, database, events, config):\n        self.database = database\n        self.repository = UserRepository(database)  # Has repository\n        self.service = UserService(self.repository, events, config)\n</code></pre> <p>Stateful kits typically:</p> <ul> <li>Define ORM models (SQLAlchemy) for database persistence</li> <li>Implement repositories for data access</li> <li>Manage entity lifecycle (create, read, update, delete)</li> <li>Publish domain events when entities change</li> </ul> <p>Examples: User Kit, Group Kit, RBAC Kit, Audit Kit</p>"},{"location":"kits/#stateless-kits","title":"Stateless Kits","text":"<p>Stateless kits orchestrate operations without managing persistent entities:</p> <pre><code>class CacheKit:\n    \"\"\"Stateless kit - provides caching service.\"\"\"\n\n    # No models attribute (no database tables)\n\n    def __init__(self, database, events, config, cache_adapter: CacheAdapter):\n        self.config = config\n        self.service = CacheService(cache_adapter, config)  # Wraps adapter\n</code></pre> <p>Stateless kits typically:</p> <ul> <li>No ORM models (don't create database tables)</li> <li>Wrap external services behind clean interfaces</li> <li>Provide infrastructure capabilities (caching, LLM calls, file storage)</li> <li>Depend on adapters injected at initialization</li> </ul> <p>Examples: Cache Kit, LLM Kit, RAG Kit, Settings Kit</p>"},{"location":"kits/#dependency-injection","title":"Dependency Injection","text":"<p>Kits receive all dependencies through constructor parameters, never by importing them directly:</p> <pre><code># \u2705 CORRECT - Dependencies injected via constructor\nclass AuthKit:\n    def __init__(\n        self,\n        database: Database,\n        events: EventBus,\n        config: AuthKitConfig,\n        user_kit: UserKit  # Injected by compose.webapp()\n    ):\n        self.user_kit = user_kit\n        self.service = AuthenticationService(\n            user_repository=user_kit.repository,  # Uses injected dependency\n            events=events,\n            config=config\n        )\n</code></pre> <pre><code># \u274c WRONG - Importing other kits directly\nfrom portico.kits.user import UserKit  # Circular import risk!\n\nclass AuthKit:\n    def __init__(self, database, events, config):\n        self.user_kit = UserKit(database, events)  # Creates own instance!\n</code></pre> <p>The composition root (<code>compose.webapp()</code>) handles dependency resolution:</p> <pre><code>app = compose.webapp(\n    kits=[\n        compose.user(),      # Creates UserKit first\n        compose.auth(),      # Creates AuthKit with UserKit injected\n    ]\n)\n</code></pre>"},{"location":"kits/#repository-pattern","title":"Repository Pattern","text":"<p>The repository pattern is fundamental to stateful kits. It separates data access from business logic:</p> <pre><code># Port interface (what operations are available)\nclass UserRepository(ABC):\n    @abstractmethod\n    async def create(self, user_data: CreateUserRequest) -&gt; User:\n        pass\n\n    @abstractmethod\n    async def get_by_id(self, user_id: UUID) -&gt; Optional[User]:\n        pass\n\n# Kit repository implementation\nclass UserRepository:\n    \"\"\"Concrete implementation using SQLAlchemy.\"\"\"\n\n    def __init__(self, database: Database):\n        self.database = database\n\n    async def create(self, user_data: CreateUserRequest, password_hash: str) -&gt; User:\n        # Implementation uses ORM models\n        async with self.database.transaction() as session:\n            user_model = UserModel(...)\n            session.add(user_model)\n            await session.flush()\n            return user_model.to_domain()  # Return domain model\n</code></pre> <p>This pattern provides:</p> <ul> <li>Abstraction - Business logic doesn't know about SQLAlchemy</li> <li>Testability - Easy to create fake repositories for testing</li> <li>Consistency - All data access goes through repositories</li> <li>Separation - ORM models stay in repository, domain models in service</li> </ul>"},{"location":"kits/#event-driven-communication","title":"Event-Driven Communication","text":"<p>Kits communicate through domain events instead of direct calls:</p> <pre><code># User Kit publishes event\nclass UserService:\n    async def delete_user(self, user_id: UUID) -&gt; None:\n        await self.repository.delete(user_id)\n\n        # Publish event - User Kit doesn't know who cares\n        await self.events.publish(UserDeletedEvent(user_id=user_id))\n\n# Other kits subscribe to events\nclass GroupService:\n    async def handle_user_deleted(self, event: UserDeletedEvent):\n        \"\"\"Automatically remove user from all groups.\"\"\"\n        await self.repository.remove_user_from_all_groups(event.user_id)\n\nclass SessionService:\n    async def handle_user_deleted(self, event: UserDeletedEvent):\n        \"\"\"Automatically delete user's sessions.\"\"\"\n        await self.repository.delete_user_sessions(event.user_id)\n</code></pre> <p>This decouples kits - User Kit doesn't need to know about Groups or Sessions, they react independently to the same event.</p>"},{"location":"kits/#configuration-validation","title":"Configuration Validation","text":"<p>Kits validate configuration at initialization time, failing fast if misconfigured:</p> <pre><code>@dataclass\nclass AuthKitConfig:\n    session_secret: str\n    session_cookie_name: str = \"session_token\"\n    session_ttl_seconds: int = 3600\n\n    def __post_init__(self):\n        # Validate session secret length\n        if len(self.session_secret) &lt; 32:\n            raise ValueError(\"session_secret must be at least 32 characters\")\n\n        # Validate TTL\n        if self.session_ttl_seconds &lt; 60:\n            raise ValueError(\"session_ttl_seconds must be at least 60\")\n\n# This fails immediately at startup\napp = compose.webapp(\n    kits=[\n        compose.auth(session_secret=\"too-short\")  # Raises ValueError\n    ]\n)\n</code></pre> <p>This prevents invalid configurations from reaching production.</p>"},{"location":"kits/#how-kits-relate-to-ports-and-adapters","title":"How Kits Relate to Ports and Adapters","text":"<p>Kits sit at the center of hexagonal architecture, using ports while remaining independent of adapters:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Application (Routes, Controllers)      \u2502\n\u2502  - Thin layer                           \u2502\n\u2502  - Translates HTTP to kit calls         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n                  \u2502 Uses\n                  \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Kits (Business Logic)                  \u2502\n\u2502  - Services with business rules         \u2502\n\u2502  - Repositories for data access         \u2502\n\u2502  - Depend on PORTS (interfaces)         \u2502\n\u2502  - Publish domain events                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n                  \u2502 Depends on\n                  \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Ports (Interfaces)                     \u2502\n\u2502  - Define contracts                     \u2502\n\u2502  - No implementation                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2191\n                  \u2502 Implemented by\n                  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Adapters (Implementations)             \u2502\n\u2502  - PostgreSQL, Redis, OpenAI, etc.      \u2502\n\u2502  - Injected into kits by compose        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kits/#kits-depend-on-ports","title":"Kits Depend on Ports","text":"<pre><code># Kit imports port interface\nfrom portico.ports.cache import CacheAdapter, CacheKey, CacheEntry\n\nclass UserService:\n    def __init__(\n        self,\n        user_repository: UserRepository,\n        cache: CacheAdapter,  # Port interface, not Redis/Memcached\n        events: EventBus\n    ):\n        self.repository = user_repository\n        self.cache = cache\n\n    async def get_user(self, user_id: UUID) -&gt; Optional[User]:\n        # Service uses port interface\n        cache_key = CacheKey(key=f\"user:{user_id}\")\n        cached = await self.cache.get(cache_key)\n\n        if cached:\n            return User(**cached.value)\n\n        user = await self.repository.get_by_id(user_id)\n        if user:\n            await self.cache.set(cache_key, user.dict(), ttl=300)\n\n        return user\n</code></pre> <p>The service has no idea if it's using Redis, Memcached, or in-memory caching. It only knows the <code>CacheAdapter</code> interface.</p>"},{"location":"kits/#adapters-are-injected-by-compose","title":"Adapters are Injected by Compose","text":"<pre><code># compose.py - The only place that imports adapters\ndef cache(**config):\n    from portico.adapters.cache import RedisCacheAdapter  # Adapter import\n    from portico.kits.cache import CacheKit\n\n    def factory(database, events):\n        # Choose adapter based on config\n        if config.get(\"backend\") == \"redis\":\n            adapter = RedisCacheAdapter(redis_url=config[\"redis_url\"])\n        else:\n            adapter = MemoryCacheAdapter()\n\n        # Inject adapter into kit\n        return CacheKit.create(database, events, config, cache_adapter=adapter)\n\n    return factory\n</code></pre>"},{"location":"kits/#kits-stay-adapter-agnostic","title":"Kits Stay Adapter-Agnostic","text":"<pre><code># \u2705 CORRECT - Kit depends on port\nfrom portico.ports.llm import ChatCompletionProvider\n\nclass LLMService:\n    def __init__(self, provider: ChatCompletionProvider):\n        self.provider = provider  # Could be OpenAI, Anthropic, etc.\n\n# \u274c WRONG - Kit imports adapter\nfrom portico.adapters.llm import OpenAIProvider\n\nclass LLMService:\n    def __init__(self):\n        self.provider = OpenAIProvider()  # Coupled to OpenAI!\n</code></pre> <p>This architectural rule is enforced by <code>import-linter</code> - the build fails if a kit imports an adapter.</p>"},{"location":"kits/#testing-kits","title":"Testing Kits","text":"<p>One of the biggest benefits of the kit architecture is testability. Because kits depend on interfaces, you can test them without external dependencies.</p>"},{"location":"kits/#testing-with-fake-implementations","title":"Testing with Fake Implementations","text":"<pre><code>from portico.ports.user import UserRepository, User, CreateUserRequest\nfrom uuid import uuid4\n\nclass FakeUserRepository(UserRepository):\n    \"\"\"In-memory fake for testing.\"\"\"\n\n    def __init__(self):\n        self.users = {}\n\n    async def create(self, user_data: CreateUserRequest, password_hash: str) -&gt; User:\n        user = User(\n            id=uuid4(),\n            username=user_data.username,\n            email=user_data.email,\n            created_at=datetime.now(UTC)\n        )\n        self.users[user.id] = user\n        return user\n\n    async def get_by_email(self, email: str) -&gt; Optional[User]:\n        return next((u for u in self.users.values() if u.email == email), None)\n\n# Test without real database\n@pytest.mark.asyncio\nasync def test_create_user():\n    # Arrange\n    fake_repo = FakeUserRepository()\n    fake_events = FakeEventBus()\n    config = UserKitConfig(password_min_length=8)\n\n    service = UserService(\n        user_repository=fake_repo,\n        events=fake_events,\n        config=config\n    )\n\n    # Act\n    user = await service.create_user(\n        CreateUserRequest(username=\"alice\", email=\"alice@example.com\", password=\"secret123\")\n    )\n\n    # Assert\n    assert user.username == \"alice\"\n    assert user.email == \"alice@example.com\"\n\n    # Verify event published\n    assert len(fake_events.published) == 1\n    assert isinstance(fake_events.published[0], UserCreatedEvent)\n</code></pre>"},{"location":"kits/#testing-business-rules","title":"Testing Business Rules","text":"<p>You can test business logic in isolation:</p> <pre><code>@pytest.mark.asyncio\nasync def test_password_too_short():\n    service = UserService(FakeUserRepository(), FakeEventBus(), UserKitConfig(password_min_length=10))\n\n    with pytest.raises(ValueError, match=\"Password must be at least 10 characters\"):\n        await service.create_user(\n            CreateUserRequest(username=\"alice\", email=\"alice@example.com\", password=\"short\")\n        )\n\n@pytest.mark.asyncio\nasync def test_duplicate_email():\n    fake_repo = FakeUserRepository()\n    service = UserService(fake_repo, FakeEventBus(), UserKitConfig())\n\n    # Create first user\n    await service.create_user(\n        CreateUserRequest(username=\"alice\", email=\"alice@example.com\", password=\"secret123\")\n    )\n\n    # Try to create second user with same email\n    with pytest.raises(ValueError, match=\"Email already registered\"):\n        await service.create_user(\n            CreateUserRequest(username=\"alice2\", email=\"alice@example.com\", password=\"secret456\")\n        )\n</code></pre>"},{"location":"kits/#integration-testing","title":"Integration Testing","text":"<p>For integration tests, use real implementations but with test databases:</p> <pre><code>@pytest.mark.integration\nasync def test_user_creation_with_real_database():\n    # Use test database\n    database = Database(url=\"sqlite+aiosqlite:///:memory:\")\n    await database.create_tables([UserModel])\n\n    events = EventBus()\n    config = UserKitConfig()\n\n    # Real repository with test database\n    repository = UserRepository(database=database)\n    service = UserService(repository, events, config)\n\n    # Test with real database\n    user = await service.create_user(\n        CreateUserRequest(username=\"alice\", email=\"alice@example.com\", password=\"secret123\")\n    )\n\n    # Verify persistence\n    retrieved = await repository.get_by_email(\"alice@example.com\")\n    assert retrieved.id == user.id\n</code></pre>"},{"location":"kits/#kit-composition","title":"Kit Composition","text":"<p>Kits are composed through the <code>compose.webapp()</code> function, which handles all the complexity of dependency resolution and initialization.</p>"},{"location":"kits/#basic-composition","title":"Basic Composition","text":"<pre><code>from portico import compose\n\napp = compose.webapp(\n    database_url=\"postgresql://localhost/myapp\",\n    kits=[\n        compose.user(password_min_length=8),\n        compose.auth(\n            session_secret=\"your-32-char-secret-here-at-least\",\n            session_ttl_seconds=3600\n        ),\n        compose.group(),\n        compose.rbac(),\n    ]\n)\n\n# Access kits in your application\nuser_kit = app.kits[\"user\"]\nauth_kit = app.kits[\"auth\"]\n</code></pre>"},{"location":"kits/#kit-dependencies","title":"Kit Dependencies","text":"<p>The compose system automatically resolves dependencies between kits:</p> <pre><code># AuthKit depends on UserKit\nclass AuthKit:\n    def __init__(self, database, events, config, user_kit: UserKit):\n        # user_kit is automatically injected by compose.webapp()\n        self.user_kit = user_kit\n\n# You just declare what you need\napp = compose.webapp(\n    kits=[\n        compose.user(),   # Created first\n        compose.auth(),   # Receives user_kit automatically\n    ]\n)\n</code></pre> <p>The compose system: 1. Inspects signatures to find dependencies 2. Resolves by name - parameter <code>user_kit</code> matches kit name <code>\"user\"</code> 3. Resolves by type - if a parameter type matches a kit class 4. Fails fast if dependencies can't be satisfied</p>"},{"location":"kits/#conditional-features","title":"Conditional Features","text":"<p>You can compose kits conditionally based on configuration:</p> <pre><code>kits = [\n    compose.user(),\n    compose.auth(),\n]\n\n# Add optional features\nif config.enable_rbac:\n    kits.extend([compose.group(), compose.rbac()])\n\nif config.enable_audit:\n    kits.append(compose.audit())\n\nif config.enable_caching:\n    kits.append(compose.cache(backend=\"redis\", redis_url=config.redis_url))\n\napp = compose.webapp(database_url=config.database_url, kits=kits)\n</code></pre>"},{"location":"kits/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":""},{"location":"kits/#service-methods-should-be-focused","title":"Service Methods Should Be Focused","text":"<p>Each service method should do one thing well:</p> <pre><code># \u2705 GOOD - Focused methods\nclass UserService:\n    async def create_user(self, user_data: CreateUserRequest) -&gt; User:\n        \"\"\"Create a new user.\"\"\"\n        ...\n\n    async def update_user(self, user_id: UUID, updates: UpdateUserRequest) -&gt; User:\n        \"\"\"Update an existing user.\"\"\"\n        ...\n\n    async def delete_user(self, user_id: UUID) -&gt; None:\n        \"\"\"Delete a user.\"\"\"\n        ...\n\n# \u274c BAD - One method does too much\nclass UserService:\n    async def manage_user(self, action: str, user_id: UUID, data: dict):\n        \"\"\"Do everything.\"\"\"\n        if action == \"create\":\n            ...\n        elif action == \"update\":\n            ...\n        elif action == \"delete\":\n            ...\n</code></pre>"},{"location":"kits/#validate-early-fail-fast","title":"Validate Early, Fail Fast","text":"<p>Validate inputs at the service boundary:</p> <pre><code>class UserService:\n    async def create_user(self, user_data: CreateUserRequest) -&gt; User:\n        # Validate before doing anything\n        if len(user_data.password) &lt; self.config.password_min_length:\n            raise ValueError(f\"Password too short\")\n\n        if not re.match(self.config.username_pattern, user_data.username):\n            raise ValueError(\"Invalid username format\")\n\n        # Now proceed with business logic\n        ...\n</code></pre>"},{"location":"kits/#use-domain-models-not-dictionaries","title":"Use Domain Models, Not Dictionaries","text":"<p>Always use Pydantic models for type safety:</p> <pre><code># \u2705 GOOD - Type-safe domain models\nasync def create_user(self, user_data: CreateUserRequest) -&gt; User:\n    user = await self.repository.create(user_data)\n    return user  # Returns User (Pydantic model)\n\n# \u274c BAD - Passing dictionaries\nasync def create_user(self, user_data: dict) -&gt; dict:\n    user = await self.repository.create(user_data)\n    return {\"id\": str(user.id), \"username\": user.username}\n</code></pre>"},{"location":"kits/#publish-events-for-side-effects","title":"Publish Events for Side Effects","text":"<p>Use events instead of direct calls for side effects:</p> <pre><code># \u2705 GOOD - Event-driven side effects\nclass UserService:\n    async def delete_user(self, user_id: UUID) -&gt; None:\n        await self.repository.delete(user_id)\n\n        # Publish event - other kits react independently\n        await self.events.publish(UserDeletedEvent(user_id=user_id))\n\n# \u274c BAD - Direct coupling to other kits\nclass UserService:\n    def __init__(self, user_repo, group_kit, session_kit, audit_kit):\n        # Too many dependencies!\n        ...\n\n    async def delete_user(self, user_id: UUID) -&gt; None:\n        await self.repository.delete(user_id)\n        await self.group_kit.remove_from_all_groups(user_id)\n        await self.session_kit.delete_sessions(user_id)\n        await self.audit_kit.log_deletion(user_id)\n</code></pre>"},{"location":"kits/#keep-configuration-immutable","title":"Keep Configuration Immutable","text":"<p>Treat configuration as immutable after initialization:</p> <pre><code>@dataclass(frozen=True)  # Immutable\nclass UserKitConfig:\n    password_min_length: int = 8\n    allow_duplicate_emails: bool = False\n</code></pre>"},{"location":"kits/#repository-methods-should-be-atomic","title":"Repository Methods Should Be Atomic","text":"<p>Each repository method should be a complete, atomic operation:</p> <pre><code># \u2705 GOOD - Atomic operation\nclass UserRepository:\n    async def create(self, user_data: CreateUserRequest, password_hash: str) -&gt; User:\n        async with self.database.transaction() as session:\n            # Everything happens in one transaction\n            user_model = UserModel(...)\n            session.add(user_model)\n            await session.flush()\n            return user_model.to_domain()\n\n# \u274c BAD - Leaky abstraction\nclass UserRepository:\n    async def begin_transaction(self):\n        ...\n\n    async def add_user(self, user_model):\n        ...\n\n    async def commit_transaction(self):\n        ...\n</code></pre>"},{"location":"kits/#summary","title":"Summary","text":"<p>Kits are the business logic layer of Portico:</p> <ul> <li>Kits contain services - Business logic and workflow orchestration</li> <li>Kits use repositories - Abstract data access behind clean interfaces</li> <li>Kits depend on ports - Never import adapters directly</li> <li>Kits publish events - Enable loose coupling between domains</li> <li>Kits are testable - Inject fake implementations for fast tests</li> <li>Kits are composable - Compose system handles dependency injection</li> </ul> <p>When building with Portico:</p> <ol> <li>Put business logic in services - Not in routes or models</li> <li>Use repositories for data access - Keep ORM details isolated</li> <li>Depend on port interfaces - Never import adapters</li> <li>Publish domain events - For side effects and cross-kit communication</li> <li>Validate configuration early - Fail fast at initialization</li> <li>Test with fakes - Fast, isolated unit tests</li> <li>Test with real databases - Integration tests for data access</li> </ol> <p>Understanding kits is essential to building maintainable applications with Portico. They're where your domain expertise lives, isolated from infrastructure concerns and easy to test.</p>"},{"location":"ports/","title":"Ports","text":"<p>In Portico's hexagonal architecture, ports are the stable, framework-free interfaces that define the contract between your business logic and the outside world. They are pure domain abstractions - no implementation details, no external dependencies, just clear interfaces that express what your application needs.</p>"},{"location":"ports/#what-is-a-port","title":"What is a Port?","text":"<p>A port is an abstract interface that defines a capability your application requires without specifying how that capability is implemented. Think of ports as the \"shape\" of a dependency - they describe what operations are available and what data flows in and out, but not where that data comes from or how the operations work internally.</p> <p>In traditional applications, you might write code like this:</p> <pre><code># Direct dependency on implementation\nfrom redis import Redis\n\nclass UserService:\n    def __init__(self):\n        self.cache = Redis(host='localhost')  # Coupled to Redis!\n\n    async def get_user(self, user_id: str):\n        cached = self.cache.get(f\"user:{user_id}\")\n        if cached:\n            return json.loads(cached)\n        # ... fetch from database\n</code></pre> <p>With ports, you instead depend on an abstract interface:</p> <pre><code># Dependency on interface (port)\nfrom portico.ports.cache import CacheAdapter\n\nclass UserService:\n    def __init__(self, cache: CacheAdapter):  # Depends on port!\n        self.cache = cache\n\n    async def get_user(self, user_id: str):\n        cache_key = CacheKey(key=f\"user:{user_id}\")\n        cached = await self.cache.get(cache_key)\n        if cached:\n            return cached.value\n        # ... fetch from database\n</code></pre> <p>The second example depends on <code>CacheAdapter</code> (a port), not <code>Redis</code> (an implementation). This means:</p> <ul> <li>You can swap Redis for Memcached without changing <code>UserService</code></li> <li>You can test with an in-memory cache without running Redis</li> <li>Your business logic stays clean and focused on domain concerns</li> </ul>"},{"location":"ports/#port-anatomy","title":"Port Anatomy","text":"<p>Every Portico port typically contains three types of components:</p>"},{"location":"ports/#1-domain-models","title":"1. Domain Models","text":"<p>These are the core entities and value objects that represent concepts in your domain. They're built with Pydantic for validation and serialization:</p> <pre><code>from pydantic import BaseModel, Field\nfrom uuid import UUID, uuid4\nfrom datetime import datetime\n\nclass User(BaseModel):\n    \"\"\"Domain model representing a user in the system.\"\"\"\n    id: UUID = Field(default_factory=uuid4)\n    username: str\n    email: str\n    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))\n\n    # Domain methods that express business logic\n    def is_active(self) -&gt; bool:\n        \"\"\"Check if user account is active.\"\"\"\n        return self.status == UserStatus.ACTIVE\n</code></pre> <p>Domain models are frozen in time - they represent a snapshot of data at a point in time. They can have domain methods that express business logic, but they don't perform I/O operations.</p>"},{"location":"ports/#2-requestresponse-models","title":"2. Request/Response Models","text":"<p>These define the shape of data flowing into and out of operations:</p> <pre><code>class CreateUserRequest(BaseModel):\n    \"\"\"Request model for creating a new user.\"\"\"\n    username: str = Field(min_length=3, max_length=50)\n    email: str = Field(pattern=r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\")\n    password: str = Field(min_length=8)\n\n    # Pydantic validators ensure data quality\n    @field_validator('username')\n    def username_must_be_alphanumeric(cls, v):\n        if not v.isalnum():\n            raise ValueError('Username must be alphanumeric')\n        return v\n</code></pre> <p>These models use Pydantic's validation to ensure data integrity at the boundary of your system.</p>"},{"location":"ports/#3-abstract-interfaces","title":"3. Abstract Interfaces","text":"<p>These define the operations available for a particular capability:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Optional\n\nclass UserRepository(ABC):\n    \"\"\"Port defining user persistence operations.\"\"\"\n\n    @abstractmethod\n    async def create(self, request: CreateUserRequest) -&gt; User:\n        \"\"\"Create a new user.\n\n        Args:\n            request: User creation data\n\n        Returns:\n            Created user with generated ID and timestamps\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_id(self, user_id: UUID) -&gt; Optional[User]:\n        \"\"\"Retrieve user by ID.\n\n        Args:\n            user_id: Unique user identifier\n\n        Returns:\n            User if found, None otherwise\n        \"\"\"\n        pass\n</code></pre> <p>Interfaces use Python's <code>ABC</code> (Abstract Base Class) to enforce that implementations provide all required methods.</p>"},{"location":"ports/#port-types","title":"Port Types","text":"<p>Portico uses semantic naming conventions to indicate what kind of operations a port provides:</p>"},{"location":"ports/#repository","title":"Repository","text":"<p>Pattern: <code>{Entity}Repository</code> Purpose: Persistence and retrieval of domain entities Examples: <code>UserRepository</code>, <code>GroupRepository</code>, <code>PermissionRepository</code></p> <p>Repositories abstract database operations. They provide CRUD (Create, Read, Update, Delete) operations and domain-specific queries:</p> <pre><code>class UserRepository(ABC):\n    @abstractmethod\n    async def create(self, request: CreateUserRequest) -&gt; User:\n        \"\"\"Persist a new user.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_email(self, email: str) -&gt; Optional[User]:\n        \"\"\"Find user by email address.\"\"\"\n        pass\n\n    @abstractmethod\n    async def update(self, user_id: UUID, request: UpdateUserRequest) -&gt; User:\n        \"\"\"Update existing user.\"\"\"\n        pass\n</code></pre>"},{"location":"ports/#provider","title":"Provider","text":"<p>Pattern: <code>{Capability}Provider</code> Purpose: External service integration for computational operations Examples: <code>ChatCompletionProvider</code>, <code>EmbeddingProvider</code></p> <p>Providers integrate with external services, typically for AI/ML capabilities:</p> <pre><code>class ChatCompletionProvider(ABC):\n    @abstractmethod\n    async def complete(\n        self,\n        request: ChatCompletionRequest\n    ) -&gt; ChatCompletionResponse:\n        \"\"\"Generate chat completion using an LLM service.\"\"\"\n        pass\n</code></pre>"},{"location":"ports/#adapter","title":"Adapter","text":"<p>Pattern: <code>{Capability}Adapter</code> Purpose: Technology-specific integration for infrastructure Examples: <code>CacheAdapter</code>, <code>FileStorageAdapter</code>, <code>AuditAdapter</code>, <code>NotificationAdapter</code></p> <p>Adapters integrate with infrastructure services like caching, storage, logging, and notifications:</p> <pre><code>class CacheAdapter(ABC):\n    @abstractmethod\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        \"\"\"Retrieve cached value.\"\"\"\n        pass\n\n    @abstractmethod\n    async def set(self, key: CacheKey, value: Any, ttl: Optional[int] = None) -&gt; None:\n        \"\"\"Store value in cache with optional TTL.\"\"\"\n        pass\n</code></pre> <p>Note</p> <p>Don't confuse \"adapter\" in the port name (like <code>CacheAdapter</code>) with the architectural concept of adapters. <code>CacheAdapter</code> is a port (interface). The adapter (implementation) would be something like <code>RedisCacheAdapter</code> or <code>MemoryCacheAdapter</code>.</p>"},{"location":"ports/#registry","title":"Registry","text":"<p>Pattern: <code>{Entity}Registry</code> Purpose: Registration and lookup of configured entities Examples: <code>TemplateRegistry</code>, <code>SettingsRegistry</code></p> <p>Registries manage collections of configured items, typically loaded at startup:</p> <pre><code>class TemplateRegistry(ABC):\n    @abstractmethod\n    async def register(self, template: Template) -&gt; None:\n        \"\"\"Register a template for later use.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_by_name(self, name: str) -&gt; Optional[Template]:\n        \"\"\"Retrieve registered template by name.\"\"\"\n        pass\n</code></pre>"},{"location":"ports/#storage","title":"Storage","text":"<p>Pattern: <code>{Capability}Storage</code> Purpose: Low-level data persistence (typically non-relational) Examples: <code>SessionStorage</code>, <code>VectorStore</code></p> <p>Storage ports define persistence operations for specific data structures:</p> <pre><code>class SessionStorage(ABC):\n    @abstractmethod\n    async def store_session(self, session: SessionData) -&gt; None:\n        \"\"\"Persist session data.\"\"\"\n        pass\n\n    @abstractmethod\n    async def get_session(self, token: str) -&gt; Optional[SessionData]:\n        \"\"\"Retrieve session by token.\"\"\"\n        pass\n</code></pre>"},{"location":"ports/#processor","title":"Processor","text":"<p>Pattern: <code>{Operation}Processor</code> Purpose: Data transformation and analysis Examples: <code>DocumentProcessor</code></p> <p>Processors transform data from one format to another or extract structured information:</p> <pre><code>class DocumentProcessor(ABC):\n    @abstractmethod\n    async def process_document(\n        self,\n        content: DocumentContent\n    ) -&gt; ProcessedDocument:\n        \"\"\"Process raw document into structured chunks.\"\"\"\n        pass\n</code></pre>"},{"location":"ports/#port-categories-by-domain","title":"Port Categories by Domain","text":"<p>Portico's ports can be grouped by the business domain they serve:</p>"},{"location":"ports/#user-access-management","title":"User &amp; Access Management","text":"<p>Ports for managing users, groups, permissions, and authentication:</p> <ul> <li>User Port (<code>user.py</code>) - User CRUD, authentication, role management</li> <li>Group Port (<code>group.py</code>) - Organizational hierarchies and group membership</li> <li>Permissions Port (<code>permissions.py</code>) - Role-based access control (RBAC)</li> <li>Session Port (<code>session.py</code>) - Session token management</li> </ul> <p>Common Pattern: These ports often work together. For example, authentication uses the User port to verify credentials, then creates a session using the Session port.</p>"},{"location":"ports/#infrastructure-services","title":"Infrastructure Services","text":"<p>Ports for external infrastructure like caching, storage, and notifications:</p> <ul> <li>Cache Port (<code>cache.py</code>) - High-performance caching with TTL and tag-based invalidation</li> <li>File Storage Port (<code>file_storage.py</code>) - File upload, download, and metadata management</li> <li>Notification Port (<code>notification.py</code>) - Email and SMS delivery with template support</li> <li>Audit Port (<code>audit.py</code>) - Activity logging and compliance tracking</li> </ul> <p>Common Pattern: These are typically used as cross-cutting concerns. Kits inject these adapters to add caching, notifications, or audit logging to business operations.</p>"},{"location":"ports/#ai-machine-learning","title":"AI &amp; Machine Learning","text":"<p>Ports for integrating with LLM and vector/embedding services:</p> <ul> <li>LLM Port (<code>llm.py</code>) - Chat completions, conversations, and prompt management</li> <li>Embedding Port (<code>embedding.py</code>) - Text vectorization for semantic search</li> <li>Vector Store Port (<code>vector_store.py</code>) - Vector similarity search and document retrieval</li> <li>Document Processor Port (<code>document_processor.py</code>) - Document chunking and analysis</li> <li>Managed RAG Port (<code>managed_rag.py</code>) - Integrated RAG platforms (Graphlit, etc.)</li> </ul> <p>Common Pattern: RAG (Retrieval-Augmented Generation) workflows chain these together: documents are processed into chunks, chunks are embedded, embeddings are stored in a vector store, and retrieved chunks augment LLM prompts.</p>"},{"location":"ports/#background-processing","title":"Background Processing","text":"<p>Ports for asynchronous job processing and scheduling:</p> <ul> <li>Job Port (<code>job.py</code>) - Job lifecycle and status tracking (domain models)</li> <li>Job Queue Port (<code>job_queue.py</code>) - Queue operations (enqueue, dequeue, acknowledge)</li> <li>Job Handler Port (<code>job_handler.py</code>) - Business logic for processing jobs</li> <li>Job Trigger Port (<code>job_trigger.py</code>) - Event sources that create jobs (cron, webhooks, etc.)</li> <li>Job Creator Port (<code>job_creator.py</code>) - Interface for creating jobs (used by triggers)</li> </ul> <p>Common Pattern: Triggers detect events and use the Job Creator port to enqueue jobs. Jobs are pulled from the queue and dispatched to the appropriate handler based on <code>job_type</code>.</p>"},{"location":"ports/#configuration-templates","title":"Configuration &amp; Templates","text":"<p>Ports for managing application configuration and templating:</p> <ul> <li>Template Port (<code>template.py</code>) - Jinja2 template registry and rendering</li> <li>Settings Port (<code>settings.py</code>) - Application configuration from multiple sources</li> <li>Config Schema Port (<code>config.py</code>) - Declarative configuration schema building</li> </ul> <p>Common Pattern: Templates are used throughout Portico - for LLM prompts, notification emails, and HTML rendering. Settings provide runtime configuration.</p>"},{"location":"ports/#organization-structure","title":"Organization &amp; Structure","text":"<p>Ports for representing organizational hierarchies and permissions:</p> <ul> <li>Organization Port (<code>organization.py</code>) - Hierarchical organization models and permission matrices</li> </ul> <p>Common Pattern: This port provides read models (data structures) for visualizing org charts and permission reports, typically used by organization management kits.</p>"},{"location":"ports/#common-design-patterns","title":"Common Design Patterns","text":""},{"location":"ports/#async-first","title":"Async-First","text":"<p>Nearly all port operations are async to support high-concurrency web applications:</p> <pre><code>class UserRepository(ABC):\n    @abstractmethod\n    async def create(self, request: CreateUserRequest) -&gt; User:\n        \"\"\"Async allows non-blocking I/O.\"\"\"\n        pass\n</code></pre> <p>Even if your initial adapter implementation is synchronous (like SQLite), defining the port as async allows you to swap in async implementations (like PostgreSQL with asyncpg) without changing business logic.</p>"},{"location":"ports/#pydantic-models-for-validation","title":"Pydantic Models for Validation","text":"<p>All data crossing port boundaries uses Pydantic models:</p> <pre><code>class CreateUserRequest(BaseModel):\n    username: str = Field(min_length=3, max_length=50)\n    email: str = Field(pattern=r\"^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$\")\n\n    @field_validator('email')\n    def normalize_email(cls, v):\n        return v.lower().strip()\n</code></pre> <p>This ensures:</p> <ul> <li>Data integrity: Invalid data is rejected at the boundary</li> <li>Documentation: Field types and constraints are self-documenting</li> <li>Serialization: Easy conversion to/from JSON, dict, etc.</li> </ul>"},{"location":"ports/#optional-user-ownership","title":"Optional User Ownership","text":"<p>Many domain models support optional user ownership for multi-tenant scenarios:</p> <pre><code>class Template(BaseModel):\n    id: UUID\n    name: str\n    content: str\n    user_id: Optional[UUID] = None  # If None, template is global\n    is_public: bool = False  # If True, visible to all users\n</code></pre> <p>This pattern allows:</p> <ul> <li>Global resources: <code>user_id = None</code> for system-wide templates</li> <li>User-owned resources: <code>user_id = &lt;uuid&gt;</code> for user-specific items</li> <li>Sharing: <code>is_public = True</code> to share user-owned resources</li> </ul>"},{"location":"ports/#metadata-fields-for-extensibility","title":"Metadata Fields for Extensibility","text":"<p>Most domain models include a <code>metadata: Dict[str, Any]</code> field:</p> <pre><code>class FileMetadata(BaseModel):\n    id: UUID\n    filename: str\n    content_type: str\n    size_bytes: int\n    metadata: Dict[str, Any] = Field(default_factory=dict)  # Extensible!\n</code></pre> <p>This allows you to attach custom data without modifying the port schema.</p>"},{"location":"ports/#pagination-support","title":"Pagination Support","text":"<p>List operations typically support limit/offset pagination:</p> <pre><code>class UserRepository(ABC):\n    @abstractmethod\n    async def list_users(\n        self,\n        limit: int = 100,\n        offset: int = 0\n    ) -&gt; list[User]:\n        \"\"\"Retrieve paginated user list.\"\"\"\n        pass\n</code></pre>"},{"location":"ports/#namespace-isolation","title":"Namespace Isolation","text":"<p>Infrastructure ports often support namespaces for multi-tenancy:</p> <pre><code>class VectorStoreConfig(BaseModel):\n    namespace: Optional[str] = None  # Isolate by tenant\n\n# Each tenant's data is isolated\ntenant_a_store = VectorStore(config=VectorStoreConfig(namespace=\"tenant_a\"))\ntenant_b_store = VectorStore(config=VectorStoreConfig(namespace=\"tenant_b\"))\n</code></pre>"},{"location":"ports/#how-ports-relate-to-adapters-and-kits","title":"How Ports Relate to Adapters and Kits","text":"<p>Ports sit at the center of Portico's hexagonal architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Kits (Business Logic)                  \u2502\n\u2502  - Depend on PORTS (interfaces)         \u2502\n\u2502  - Never import adapters directly       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2502\n                  \u2502 Uses\n                  \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Ports (Interfaces)                     \u2502\n\u2502  - Define what operations exist         \u2502\n\u2502  - Domain models, enums, requests       \u2502\n\u2502  - No implementation, no external deps  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2191\n                  \u2502 Implements\n                  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Adapters (Implementations)             \u2502\n\u2502  - Implement port interfaces            \u2502\n\u2502  - Integrate with external services     \u2502\n\u2502  - Can import SDKs, databases, etc.     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"ports/#ports-define-the-contract","title":"Ports Define the Contract","text":"<pre><code># portico/ports/cache.py\nfrom abc import ABC, abstractmethod\n\nclass CacheAdapter(ABC):\n    \"\"\"Port: defines WHAT caching operations are available.\"\"\"\n\n    @abstractmethod\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        pass\n\n    @abstractmethod\n    async def set(self, key: CacheKey, value: Any, ttl: Optional[int]) -&gt; None:\n        pass\n</code></pre>"},{"location":"ports/#adapters-implement-the-contract","title":"Adapters Implement the Contract","text":"<pre><code># portico/adapters/cache/redis_adapter.py\nfrom redis.asyncio import Redis\nfrom portico.ports.cache import CacheAdapter\n\nclass RedisCacheAdapter(CacheAdapter):\n    \"\"\"Adapter: implements HOW caching works with Redis.\"\"\"\n\n    def __init__(self, redis_url: str):\n        self.redis = Redis.from_url(redis_url)\n\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        value = await self.redis.get(key.key)\n        if value:\n            return CacheEntry(value=json.loads(value))\n        return None\n\n    async def set(self, key: CacheKey, value: Any, ttl: Optional[int]) -&gt; None:\n        await self.redis.set(key.key, json.dumps(value), ex=ttl)\n</code></pre>"},{"location":"ports/#kits-use-the-port","title":"Kits Use the Port","text":"<pre><code># portico/kits/user/service.py\nfrom portico.ports.user import UserRepository\nfrom portico.ports.cache import CacheAdapter\n\nclass UserService:\n    \"\"\"Kit: uses ports to implement business logic.\"\"\"\n\n    def __init__(\n        self,\n        user_repository: UserRepository,  # Port dependency!\n        cache: CacheAdapter  # Port dependency!\n    ):\n        self.users = user_repository\n        self.cache = cache\n\n    async def get_user(self, user_id: UUID) -&gt; Optional[User]:\n        # Try cache first\n        cache_key = CacheKey(key=f\"user:{user_id}\")\n        cached = await self.cache.get(cache_key)\n        if cached:\n            return User(**cached.value)\n\n        # Cache miss - fetch from repository\n        user = await self.users.get_by_id(user_id)\n        if user:\n            await self.cache.set(cache_key, user.dict(), ttl=300)\n\n        return user\n</code></pre> <p>Notice how <code>UserService</code> has no idea whether it's using Redis or Memcached for caching, or PostgreSQL or SQLite for persistence. It only knows the port interfaces.</p>"},{"location":"ports/#composition-root-wires-it-together","title":"Composition Root Wires It Together","text":"<pre><code># portico/compose.py\ndef cache(**config):\n    \"\"\"Factory function that creates cache kit with chosen adapter.\"\"\"\n    from portico.adapters.cache import RedisCacheAdapter\n    from portico.kits.cache import CacheKit\n\n    def factory(database, events):\n        # THIS is where the adapter is chosen\n        adapter = RedisCacheAdapter(redis_url=config[\"redis_url\"])\n        return CacheKit.create(database, events, config, adapter)\n\n    return factory\n</code></pre> <p>The <code>compose.py</code> module is the only place in Portico where adapters are imported and instantiated. This enforces clean architecture - kits can never accidentally import adapters.</p>"},{"location":"ports/#how-to-use-ports","title":"How to Use Ports","text":""},{"location":"ports/#when-writing-business-logic-kits","title":"When Writing Business Logic (Kits)","text":"<p>Import and depend on ports, never adapters:</p> <pre><code># \u2705 CORRECT - Import port\nfrom portico.ports.user import UserRepository, CreateUserRequest\n\nclass SignupService:\n    def __init__(self, users: UserRepository):  # Depend on interface\n        self.users = users\n\n    async def signup(self, username: str, email: str, password: str):\n        request = CreateUserRequest(\n            username=username,\n            email=email,\n            password=password\n        )\n        return await self.users.create(request)\n</code></pre> <pre><code># \u274c WRONG - Import adapter\nfrom portico.adapters.storage.postgres import PostgresUserRepository  # NO!\n\nclass SignupService:\n    def __init__(self):\n        self.users = PostgresUserRepository()  # Couples to PostgreSQL!\n</code></pre>"},{"location":"ports/#when-implementing-a-custom-adapter","title":"When Implementing a Custom Adapter","text":"<p>Implement the port interface:</p> <pre><code>from portico.ports.cache import CacheAdapter, CacheKey, CacheEntry\nfrom typing import Optional, Any\nimport memcache\n\nclass MemcachedAdapter(CacheAdapter):\n    \"\"\"Custom adapter implementing the CacheAdapter port.\"\"\"\n\n    def __init__(self, servers: list[str]):\n        self.client = memcache.Client(servers)\n\n    async def get(self, key: CacheKey) -&gt; Optional[CacheEntry]:\n        value = self.client.get(key.key)\n        if value:\n            return CacheEntry(value=value, key=key.key)\n        return None\n\n    async def set(self, key: CacheKey, value: Any, ttl: Optional[int] = None) -&gt; None:\n        self.client.set(key.key, value, time=ttl or 0)\n\n    # ... implement other required methods\n</code></pre>"},{"location":"ports/#when-testing","title":"When Testing","text":"<p>Use fake/mock implementations of ports:</p> <pre><code>from portico.ports.user import UserRepository, User, CreateUserRequest\nfrom uuid import uuid4\n\nclass FakeUserRepository(UserRepository):\n    \"\"\"In-memory fake for testing.\"\"\"\n\n    def __init__(self):\n        self.users = {}\n\n    async def create(self, request: CreateUserRequest) -&gt; User:\n        user = User(\n            id=uuid4(),\n            username=request.username,\n            email=request.email\n        )\n        self.users[user.id] = user\n        return user\n\n    async def get_by_id(self, user_id: UUID) -&gt; Optional[User]:\n        return self.users.get(user_id)\n\n# Now test your service without real database\ndef test_signup():\n    fake_users = FakeUserRepository()\n    service = SignupService(users=fake_users)\n\n    user = await service.signup(\"alice\", \"alice@example.com\", \"secret123\")\n    assert user.username == \"alice\"\n</code></pre>"},{"location":"ports/#summary","title":"Summary","text":"<p>Ports are the foundation of Portico's clean architecture:</p> <ul> <li>Ports are interfaces - They define what operations exist without specifying how they work</li> <li>Ports contain domain models - Pydantic models represent your business entities</li> <li>Ports are technology-agnostic - No databases, no SDKs, no implementation details</li> <li>Ports enable testing - Mock implementations for fast, isolated tests</li> <li>Ports enable flexibility - Swap implementations without changing business logic</li> </ul> <p>When building with Portico:</p> <ol> <li>Depend on ports in your business logic (kits)</li> <li>Implement ports when creating custom adapters</li> <li>Never import adapters directly - let the composition root wire dependencies</li> </ol> <p>Understanding ports is essential to working effectively with Portico's hexagonal architecture. They are the contracts that keep your codebase clean, testable, and maintainable as your application grows.</p>"},{"location":"ports/audit/","title":"Audit Port","text":""},{"location":"ports/audit/#overview","title":"Overview","text":"<p>The Audit Port defines the contract for audit logging operations in Portico applications.</p> <p>Purpose: Abstract audit logging operations to enable compliance, security tracking, and activity monitoring with pluggable storage backends.</p> <p>Domain: Security, compliance, observability</p> <p>Key Capabilities:</p> <ul> <li>Comprehensive event logging with rich metadata</li> <li>User activity tracking and reporting</li> <li>Resource history and change tracking</li> <li>Flexible querying with multiple filter criteria</li> <li>Compliance reporting and summary statistics</li> <li>Retention policy management and cleanup</li> <li>Group-scoped audit trails for multi-tenant applications</li> <li>Transactional audit logging for data consistency</li> </ul> <p>Port Type: Adapter</p> <p>When to Use:</p> <ul> <li>Applications requiring compliance with audit regulations (SOC 2, HIPAA, GDPR)</li> <li>Systems needing security event tracking and forensics</li> <li>Multi-tenant applications requiring isolated audit trails</li> <li>Applications tracking user activity and resource changes</li> <li>Systems requiring detailed activity reporting and analytics</li> </ul>"},{"location":"ports/audit/#domain-models","title":"Domain Models","text":""},{"location":"ports/audit/#auditevent","title":"AuditEvent","text":"<p>Represents an audit event with comprehensive metadata for compliance and security tracking. Immutable record.</p> Field Type Required Default Description <code>id</code> <code>UUID</code> No Auto-generated Unique event identifier <code>user_id</code> <code>Optional[UUID]</code> No <code>None</code> User who performed the action <code>group_id</code> <code>Optional[UUID]</code> No <code>None</code> Group scope for multi-tenant isolation <code>action</code> <code>AuditAction</code> Yes - Action performed (CREATE, UPDATE, DELETE, etc.) <code>resource_type</code> <code>str</code> Yes - Type of resource affected <code>resource_id</code> <code>Optional[str]</code> No <code>None</code> Identifier of the affected resource <code>details</code> <code>Dict[str, Any]</code> No <code>{}</code> Additional context and metadata <code>ip_address</code> <code>Optional[str]</code> No <code>None</code> Client IP address <code>user_agent</code> <code>Optional[str]</code> No <code>None</code> Client user agent string <code>timestamp</code> <code>datetime</code> No Current UTC time When the event occurred <code>session_id</code> <code>Optional[str]</code> No <code>None</code> Session identifier <code>success</code> <code>bool</code> No <code>True</code> Whether the action succeeded <code>error_message</code> <code>Optional[str]</code> No <code>None</code> Error message if action failed <p>Example:</p> <pre><code>from portico.ports.audit import AuditEvent, AuditAction\n\nevent = AuditEvent(\n    user_id=user_id,\n    group_id=group_id,\n    action=AuditAction.UPDATE,\n    resource_type=\"document\",\n    resource_id=\"doc-456\",\n    details={\n        \"field_changed\": \"title\",\n        \"old_value\": \"Draft\",\n        \"new_value\": \"Final\"\n    },\n    ip_address=\"192.168.1.100\",\n    success=True\n)\n</code></pre>"},{"location":"ports/audit/#auditquery","title":"AuditQuery","text":"<p>Query parameters for searching and filtering audit events.</p> Field Type Required Default Description <code>user_id</code> <code>Optional[UUID]</code> No <code>None</code> Filter by single user <code>user_ids</code> <code>Optional[List[UUID]]</code> No <code>None</code> Filter by multiple users <code>group_id</code> <code>Optional[UUID]</code> No <code>None</code> Filter by single group <code>group_ids</code> <code>Optional[List[UUID]]</code> No <code>None</code> Filter by multiple groups <code>action</code> <code>Optional[AuditAction]</code> No <code>None</code> Filter by single action <code>actions</code> <code>Optional[List[str]]</code> No <code>None</code> Filter by multiple actions <code>resource_type</code> <code>Optional[str]</code> No <code>None</code> Filter by single resource type <code>resource_types</code> <code>Optional[List[str]]</code> No <code>None</code> Filter by multiple resource types <code>resource_id</code> <code>Optional[str]</code> No <code>None</code> Filter by specific resource <code>start_date</code> <code>Optional[datetime]</code> No <code>None</code> Events after this timestamp <code>end_date</code> <code>Optional[datetime]</code> No <code>None</code> Events before this timestamp <code>success</code> <code>Optional[bool]</code> No <code>None</code> Filter by success/failure status <code>limit</code> <code>int</code> No <code>100</code> Maximum results (1-1000) <code>offset</code> <code>int</code> No <code>0</code> Pagination offset <p>Example:</p> <pre><code>from portico.ports.audit import AuditQuery, AuditAction\nfrom datetime import datetime, timedelta\n\n# Query failed login attempts in last 7 days\nquery = AuditQuery(\n    action=AuditAction.LOGIN,\n    success=False,\n    start_date=datetime.now() - timedelta(days=7),\n    limit=50\n)\n\n# Query group activity\nquery = AuditQuery(\n    group_id=group_id,\n    resource_types=[\"document\", \"template\"],\n    start_date=datetime(2024, 1, 1),\n    end_date=datetime(2024, 12, 31)\n)\n</code></pre>"},{"location":"ports/audit/#auditsummary","title":"AuditSummary","text":"<p>Summary statistics for audit events over a time period.</p> Field Type Required Default Description <code>total_events</code> <code>int</code> Yes - Total number of events in period <code>events_by_action</code> <code>Dict[str, int]</code> Yes - Count of events grouped by action <code>events_by_user</code> <code>Dict[str, int]</code> Yes - Count of events grouped by user <code>events_by_resource_type</code> <code>Dict[str, int]</code> Yes - Count of events grouped by resource type <code>events_by_group</code> <code>Dict[str, int]</code> Yes - Count of events grouped by group <code>success_rate</code> <code>float</code> Yes - Percentage of successful events (0.0-1.0) <code>time_range</code> <code>tuple[datetime, datetime]</code> Yes - Start and end timestamps of summary period <p>Example:</p> <pre><code>summary = await audit_adapter.generate_summary(\n    start_date=datetime(2024, 1, 1),\n    end_date=datetime(2024, 1, 31)\n)\n\nprint(f\"Total events: {summary.total_events}\")\nprint(f\"Success rate: {summary.success_rate:.2%}\")\nprint(f\"Events by action: {summary.events_by_action}\")\n</code></pre>"},{"location":"ports/audit/#enumerations","title":"Enumerations","text":""},{"location":"ports/audit/#auditaction","title":"AuditAction","text":"<p>Standard audit actions for consistent logging across the application.</p> Value Description <code>CREATE</code> Resource creation <code>READ</code> Resource access/retrieval <code>UPDATE</code> Resource modification <code>DELETE</code> Resource deletion <code>LOGIN</code> User login <code>LOGOUT</code> User logout <code>EXPORT</code> Data export <code>IMPORT</code> Data import <code>APPROVE</code> Approval action <code>REJECT</code> Rejection action <p>Example:</p> <pre><code>from portico.ports.audit import AuditAction\n\nevent = AuditEvent(\n    action=AuditAction.CREATE,\n    resource_type=\"user\",\n    # ...\n)\n</code></pre>"},{"location":"ports/audit/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/audit/#auditadapter","title":"AuditAdapter","text":"<p>The <code>AuditAdapter</code> abstract base class defines the contract for all audit logging backends.</p> <p>Location: <code>portico.ports.audit.AuditAdapter</code></p>"},{"location":"ports/audit/#key-methods","title":"Key Methods","text":""},{"location":"ports/audit/#log_event","title":"log_event","text":"<pre><code>async def log_event(event: AuditEvent) -&gt; None\n</code></pre> <p>Logs an audit event to storage. Primary method for recording audit trails.</p> <p>Parameters:</p> <ul> <li><code>event</code>: The audit event to log</li> </ul> <p>Example:</p> <pre><code>event = AuditEvent(\n    user_id=user_id,\n    action=AuditAction.UPDATE,\n    resource_type=\"profile\",\n    resource_id=str(user_id),\n    details={\n        \"field\": \"email\",\n        \"old\": \"old@example.com\",\n        \"new\": \"new@example.com\"\n    }\n)\n\nawait audit_adapter.log_event(event)\n</code></pre> <p>Note: This method should never raise exceptions to prevent audit failures from breaking application flow.</p>"},{"location":"ports/audit/#search_events","title":"search_events","text":"<pre><code>async def search_events(query: AuditQuery) -&gt; List[AuditEvent]\n</code></pre> <p>Searches audit events by criteria with pagination support.</p> <p>Parameters:</p> <ul> <li><code>query</code>: Search criteria including filters and pagination</li> </ul> <p>Returns: List of audit events matching the query criteria.</p> <p>Example:</p> <pre><code>from portico.ports.audit import AuditQuery, AuditAction\n\n# Find all failed login attempts\nquery = AuditQuery(\n    action=AuditAction.LOGIN,\n    success=False,\n    limit=100\n)\nevents = await audit_adapter.search_events(query)\n\n# Find user activity in date range\nquery = AuditQuery(\n    user_id=user_id,\n    start_date=datetime(2024, 1, 1),\n    end_date=datetime(2024, 1, 31),\n    limit=1000\n)\nevents = await audit_adapter.search_events(query)\n</code></pre>"},{"location":"ports/audit/#other-methods","title":"Other Methods","text":""},{"location":"ports/audit/#get_user_activity","title":"get_user_activity","text":"<pre><code>async def get_user_activity(user_id: UUID, days: int = 30) -&gt; List[AuditEvent]\n</code></pre> <p>Retrieves recent activity for a specific user within the specified time period.</p>"},{"location":"ports/audit/#get_resource_history","title":"get_resource_history","text":"<pre><code>async def get_resource_history(resource_type: str, resource_id: str) -&gt; List[AuditEvent]\n</code></pre> <p>Retrieves complete audit history for a specific resource.</p>"},{"location":"ports/audit/#generate_summary","title":"generate_summary","text":"<pre><code>async def generate_summary(start_date: datetime, end_date: datetime) -&gt; AuditSummary\n</code></pre> <p>Generates audit summary statistics for a date range.</p>"},{"location":"ports/audit/#cleanup_old_events","title":"cleanup_old_events","text":"<pre><code>async def cleanup_old_events(older_than_days: int) -&gt; int\n</code></pre> <p>Removes audit events older than the specified number of days. Returns count removed.</p>"},{"location":"ports/audit/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/audit/#security-event-tracking","title":"Security Event Tracking","text":"<pre><code>from portico.ports.audit import AuditEvent, AuditAction, AuditAdapter\n\nasync def track_login_attempt(\n    username: str,\n    success: bool,\n    ip_address: str,\n    user_agent: str,\n    audit: AuditAdapter,\n    user_id: Optional[UUID] = None,\n    error_message: Optional[str] = None\n):\n    event = AuditEvent(\n        user_id=user_id if success else None,\n        action=AuditAction.LOGIN,\n        resource_type=\"authentication\",\n        resource_id=username,\n        ip_address=ip_address,\n        user_agent=user_agent,\n        success=success,\n        error_message=error_message,\n        details={\"username\": username}\n    )\n\n    await audit.log_event(event)\n\n    # Check for suspicious activity\n    if not success:\n        recent_failures = await audit.search_events(AuditQuery(\n            action=AuditAction.LOGIN,\n            success=False,\n            resource_id=username,\n            start_date=datetime.now() - timedelta(hours=1)\n        ))\n\n        if len(recent_failures) &gt;= 5:\n            logger.warning(\n                \"multiple_failed_logins\",\n                username=username,\n                attempts=len(recent_failures)\n            )\n</code></pre>"},{"location":"ports/audit/#compliance-reporting","title":"Compliance Reporting","text":"<pre><code>from datetime import datetime, timedelta\n\nasync def generate_compliance_report(\n    audit: AuditAdapter,\n    start_date: datetime,\n    end_date: datetime\n) -&gt; dict:\n    \"\"\"Generate compliance report for auditors.\"\"\"\n\n    # Get summary statistics\n    summary = await audit.generate_summary(start_date, end_date)\n\n    # Get all failed actions for review\n    failures = await audit.search_events(AuditQuery(\n        success=False,\n        start_date=start_date,\n        end_date=end_date,\n        limit=1000\n    ))\n\n    # Get privileged actions\n    privileged_actions = await audit.search_events(AuditQuery(\n        actions=[\"delete\", \"export\", \"approve\"],\n        start_date=start_date,\n        end_date=end_date,\n        limit=1000\n    ))\n\n    return {\n        \"period\": {\n            \"start\": start_date,\n            \"end\": end_date\n        },\n        \"summary\": {\n            \"total_events\": summary.total_events,\n            \"success_rate\": summary.success_rate,\n            \"events_by_action\": summary.events_by_action,\n            \"unique_users\": len(summary.events_by_user)\n        },\n        \"failures\": [\n            {\n                \"timestamp\": f.timestamp,\n                \"user\": f.user_id,\n                \"action\": f.action.value,\n                \"resource\": f\"{f.resource_type}:{f.resource_id}\",\n                \"error\": f.error_message\n            }\n            for f in failures\n        ],\n        \"privileged_operations\": [\n            {\n                \"timestamp\": p.timestamp,\n                \"user\": p.user_id,\n                \"action\": p.action.value,\n                \"resource\": f\"{p.resource_type}:{p.resource_id}\"\n            }\n            for p in privileged_actions\n        ]\n    }\n</code></pre>"},{"location":"ports/audit/#integration-with-kits","title":"Integration with Kits","text":"<p>The Audit Port is used by the AuditKit to provide high-level audit logging services.</p> <pre><code>from portico import compose\nfrom portico.ports.audit import AuditAction\n\n# Configure audit in webapp\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[\n        compose.audit(\n            enable_auditing=True,\n            retention_days=90  # 90-day retention for compliance\n        ),\n    ],\n)\n\n# Access audit service\naudit_service = app.kits[\"audit\"].service\n\n# Log event\nawait audit_service.log_event(\n    user_id=user_id,\n    action=AuditAction.CREATE,\n    resource_type=\"document\",\n    resource_id=doc_id,\n    details={\"title\": \"New Document\"},\n    ip_address=request.client.host,\n    user_agent=request.headers.get(\"user-agent\")\n)\n\n# Search events\nfrom portico.ports.audit import AuditQuery\n\nevents = await audit_service.search_events(\n    AuditQuery(user_id=user_id, limit=100)\n)\n\n# Generate summary\nsummary = await audit_service.generate_summary(start_date, end_date)\n</code></pre> <p>The Audit Kit provides:</p> <ul> <li>Database-backed audit storage with SqlAlchemyAuditAdapter</li> <li>Transactional audit logging for data consistency</li> <li>Event publishing for audit event notifications</li> <li>Automatic retention policy enforcement</li> </ul> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/audit/#best-practices","title":"Best Practices","text":"<ol> <li>Log Security-Sensitive Operations: Always log authentication, authorization, data exports, and admin operations</li> </ol> <pre><code># \u2705 GOOD\nawait audit.log_event(AuditEvent(\n    action=AuditAction.LOGIN,\n    resource_type=\"authentication\",\n    ip_address=ip_address,\n    success=True\n))\n\n# \u2705 GOOD\nawait audit.log_event(AuditEvent(\n    action=AuditAction.EXPORT,\n    resource_type=\"customer_data\",\n    details={\"record_count\": len(records)}\n))\n</code></pre> <ol> <li>Include Contextual Information: Add rich metadata in details field for forensics</li> </ol> <pre><code># \u2705 GOOD - Rich context\nawait audit.log_event(AuditEvent(\n    action=AuditAction.UPDATE,\n    resource_type=\"user_profile\",\n    details={\n        \"field_changed\": \"email\",\n        \"old_value\": old_email,\n        \"new_value\": new_email,\n        \"verification_required\": True\n    },\n    ip_address=ip_address,\n    user_agent=user_agent\n))\n\n# \u274c BAD - Minimal context\nawait audit.log_event(AuditEvent(\n    action=AuditAction.UPDATE,\n    resource_type=\"user\"\n))\n</code></pre> <ol> <li>Use Group Scoping for Multi-Tenancy: Include group_id for tenant isolation</li> </ol> <pre><code># \u2705 GOOD\nawait audit.log_event(AuditEvent(\n    user_id=user_id,\n    group_id=group_id,  # Tenant isolation\n    action=AuditAction.CREATE,\n    resource_type=\"document\"\n))\n</code></pre> <ol> <li>Implement Retention Policies: Regular cleanup based on compliance requirements</li> </ol> <pre><code># \u2705 GOOD - Scheduled cleanup\nasync def scheduled_audit_cleanup():\n    retention_days = 90  # SOC 2 compliance\n    removed = await audit.cleanup_old_events(retention_days)\n    logger.info(\"audit_cleanup\", removed=removed)\n\n# Schedule daily\nasyncio.create_task(periodic_cleanup(interval=86400))\n</code></pre> <ol> <li>Never Log Sensitive Data: Hash or redact passwords, SSNs, credit cards</li> </ol> <pre><code># \u2705 GOOD\nawait audit.log_event(AuditEvent(\n    action=AuditAction.UPDATE,\n    resource_type=\"user\",\n    details={\"field\": \"password\", \"changed\": True}  # Don't log actual password\n))\n\n# \u274c BAD\nawait audit.log_event(AuditEvent(\n    details={\"password\": \"user_password_123\"}  # Never do this!\n))\n</code></pre>"},{"location":"ports/audit/#faqs","title":"FAQs","text":""},{"location":"ports/audit/#should-i-log-every-database-operation","title":"Should I log every database operation?","text":"<p>No. Focus on security-sensitive and compliance-relevant operations:</p> <ul> <li>\u2705 Log: Authentication, authorization, data exports, admin operations, configuration changes</li> <li>\u274c Don't log: Routine read operations, UI interactions, regular data access</li> </ul> <pre><code># \u2705 Log this\nawait audit.log_event(AuditEvent(action=AuditAction.EXPORT, ...))\n\n# \u274c Don't log this\nuser_profile = await db.get_user_profile(user_id)  # Routine read\n</code></pre>"},{"location":"ports/audit/#how-do-i-handle-audit-failures","title":"How do I handle audit failures?","text":"<p>Audit logging should never break your application. Implementations should catch and log errors internally:</p> <pre><code># Adapter implementation handles errors\nasync def log_event(self, event: AuditEvent) -&gt; None:\n    try:\n        await self._store_event(event)\n    except Exception as e:\n        logger.error(\"audit_log_failed\", error=str(e))\n        # Application continues normally\n</code></pre>"},{"location":"ports/audit/#whats-the-difference-between-audit-logging-and-application-logging","title":"What's the difference between audit logging and application logging?","text":"<ul> <li>Audit Logging (AuditPort): Compliance, security, \"who did what when\"</li> <li>Structured events with metadata</li> <li>Long retention (90+ days)</li> <li>Queryable and reportable</li> <li> <p>Immutable records</p> </li> <li> <p>Application Logging: Debugging, monitoring, \"what happened\"</p> </li> <li>Diagnostic messages</li> <li>Shorter retention (7-30 days)</li> <li>Text-based search</li> <li>Can be modified/rotated</li> </ul>"},{"location":"ports/audit/#what-retention-period-should-i-use","title":"What retention period should I use?","text":"<p>Depends on compliance requirements:</p> <ul> <li>SOC 2: 90 days minimum</li> <li>HIPAA: 6 years for healthcare data</li> <li>GDPR: As long as necessary for the purpose</li> <li>PCI DSS: 1 year minimum</li> </ul> <pre><code>app = compose.webapp(\n    kits=[\n        compose.audit(retention_days=90)  # SOC 2\n    ]\n)\n</code></pre>"},{"location":"ports/audit/#how-do-i-test-audit-logging","title":"How do I test audit logging?","text":"<p>Use the <code>MemoryAudit</code> adapter in tests:</p> <pre><code>import pytest\nfrom portico.adapters.audit import MemoryAudit\nfrom portico.ports.audit import AuditEvent, AuditAction\n\n@pytest.fixture\nasync def audit_adapter():\n    return MemoryAudit()\n\nasync def test_audit_logging(audit_adapter):\n    event = AuditEvent(\n        user_id=user_id,\n        action=AuditAction.CREATE,\n        resource_type=\"document\"\n    )\n    await audit_adapter.log_event(event)\n\n    # Verify logged\n    events = await audit_adapter.search_events(\n        AuditQuery(user_id=user_id)\n    )\n    assert len(events) == 1\n    assert events[0].action == AuditAction.CREATE\n</code></pre>"},{"location":"ports/cache/","title":"Cache Port","text":""},{"location":"ports/cache/#overview","title":"Overview","text":"<p>The Cache Port defines the contract for cache storage backends in Portico applications.</p> <p>Purpose: Abstract cache storage operations to enable high-performance data access with pluggable storage backends.</p> <p>Domain: Performance optimization, data access layer</p> <p>Key Capabilities:</p> <ul> <li>Key-value storage with optional time-to-live (TTL)</li> <li>Namespace-based key isolation for multi-tenant scenarios</li> <li>Tag-based cache invalidation for related data</li> <li>Pattern-based and bulk deletion operations</li> <li>Performance statistics and monitoring</li> <li>Function call result caching with automatic key generation</li> <li>Expired entry cleanup and maintenance</li> </ul> <p>Port Type: Adapter</p> <p>When to Use:</p> <ul> <li>Applications requiring fast data access and reduced database load</li> <li>Multi-tenant applications needing isolated cache namespaces</li> <li>Systems with complex cache invalidation patterns</li> <li>Applications requiring cache performance monitoring</li> <li>Services caching expensive computations or API calls</li> </ul>"},{"location":"ports/cache/#domain-models","title":"Domain Models","text":""},{"location":"ports/cache/#cachekey","title":"CacheKey","text":"<p>Represents a cache key with metadata for organization and invalidation. Immutable.</p> Field Type Required Default Description <code>key</code> <code>str</code> Yes - The unique cache key identifier <code>namespace</code> <code>Optional[str]</code> No <code>None</code> Optional namespace for key isolation <code>tags</code> <code>list[str]</code> No <code>[]</code> Tags for group-based invalidation <p>Properties:</p> <ul> <li><code>full_key -&gt; str</code> - Returns complete cache key with namespace prefix (<code>namespace:key</code> or just <code>key</code>)</li> </ul> <p>Class Methods:</p> <ul> <li><code>@classmethod from_function_call(func, args, kwargs, namespace, tags) -&gt; CacheKey</code> - Creates cache key from function parameters by hashing function signature and arguments</li> </ul> <p>Example:</p> <pre><code>from portico.ports.cache import CacheKey\n\n# Simple key\nkey = CacheKey(key=\"user:123\")\n\n# Key with namespace\nkey = CacheKey(\n    key=\"profile\",\n    namespace=\"user:123\",\n    tags=[\"user\", \"profile\"]\n)\nprint(key.full_key)  # \"user:123:profile\"\n\n# Key from function call (automatic)\nkey = CacheKey.from_function_call(\n    func=get_user_profile,\n    args=(user_id,),\n    kwargs={},\n    namespace=\"profiles\",\n    tags=[\"user\"]\n)\n</code></pre>"},{"location":"ports/cache/#cacheentry","title":"CacheEntry","text":"<p>Represents a cached value with metadata for expiration and access tracking. Immutable.</p> Field Type Required Default Description <code>key</code> <code>CacheKey</code> Yes - The cache key for this entry <code>value</code> <code>Any</code> Yes - The cached value (can be any type) <code>created_at</code> <code>datetime</code> No Current UTC time When entry was created <code>expires_at</code> <code>Optional[datetime]</code> No <code>None</code> When entry expires (None = no expiration) <code>hit_count</code> <code>int</code> No <code>0</code> Number of times entry has been accessed <code>last_accessed</code> <code>datetime</code> No Current UTC time Last access timestamp <p>Properties:</p> <ul> <li><code>is_expired -&gt; bool</code> - Returns True if entry has expired (current time &gt; expires_at)</li> </ul> <p>Methods:</p> <ul> <li><code>touch() -&gt; CacheEntry</code> - Returns new CacheEntry with updated last_accessed and incremented hit_count</li> </ul> <p>Example:</p> <pre><code>from datetime import timedelta\nfrom portico.ports.cache import CacheKey, CacheEntry\n\nkey = CacheKey(key=\"user:123\")\nentry = CacheEntry(\n    key=key,\n    value={\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n    expires_at=datetime.now(UTC) + timedelta(hours=1)\n)\n\n# Check expiration\nif not entry.is_expired:\n    data = entry.value\n\n# Update access metadata\nentry = entry.touch()\n</code></pre>"},{"location":"ports/cache/#cachestats","title":"CacheStats","text":"<p>Performance statistics for cache monitoring and optimization. Immutable snapshot.</p> Field Type Required Default Description <code>total_entries</code> <code>int</code> Yes - Total number of cached entries <code>total_hits</code> <code>int</code> Yes - Total cache hits <code>total_misses</code> <code>int</code> Yes - Total cache misses <code>hit_rate</code> <code>float</code> Yes - Cache hit rate (0.0 to 1.0) <code>memory_usage_bytes</code> <code>Optional[int]</code> No <code>None</code> Approximate memory usage in bytes <code>oldest_entry</code> <code>Optional[datetime]</code> No <code>None</code> Timestamp of oldest cached entry <code>newest_entry</code> <code>Optional[datetime]</code> No <code>None</code> Timestamp of newest cached entry <p>Example:</p> <pre><code>stats = await cache_adapter.get_stats()\n\nprint(f\"Hit rate: {stats.hit_rate:.2%}\")\nprint(f\"Total entries: {stats.total_entries}\")\nif stats.memory_usage_bytes:\n    print(f\"Memory: {stats.memory_usage_bytes / 1024 / 1024:.2f} MB\")\n</code></pre>"},{"location":"ports/cache/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/cache/#cacheadapter","title":"CacheAdapter","text":"<p>The <code>CacheAdapter</code> abstract base class defines the contract for all cache storage backends.</p> <p>Location: <code>portico.ports.cache.CacheAdapter</code></p>"},{"location":"ports/cache/#key-methods","title":"Key Methods","text":""},{"location":"ports/cache/#get","title":"get","text":"<pre><code>async def get(key: CacheKey) -&gt; Optional[CacheEntry]\n</code></pre> <p>Retrieves a cached value by key. Primary method for cache reads.</p> <p>Parameters:</p> <ul> <li><code>key</code>: The cache key to retrieve</li> </ul> <p>Returns: <code>CacheEntry</code> if found and not expired, <code>None</code> otherwise.</p> <p>Example:</p> <pre><code>key = CacheKey(key=\"user:123\")\nentry = await cache_adapter.get(key)\n\nif entry and not entry.is_expired:\n    user_data = entry.value\nelse:\n    # Cache miss - fetch from database\n    user_data = await db.get_user(123)\n    await cache_adapter.set(\n        CacheKey(key=\"user:123\"),\n        user_data,\n        ttl=timedelta(hours=1)\n    )\n</code></pre>"},{"location":"ports/cache/#set","title":"set","text":"<pre><code>async def set(key: CacheKey, value: Any, ttl: Optional[timedelta] = None) -&gt; None\n</code></pre> <p>Stores a value in the cache with optional time-to-live. Primary method for cache writes.</p> <p>Parameters:</p> <ul> <li><code>key</code>: The cache key to store</li> <li><code>value</code>: The value to cache (can be any serializable type)</li> <li><code>ttl</code>: Optional time-to-live duration. If provided, entry expires after this duration.</li> </ul> <p>Example:</p> <pre><code>from datetime import timedelta\n\n# Cache without expiration\nawait cache_adapter.set(\n    key=CacheKey(key=\"user:123\"),\n    value={\"name\": \"Alice\"}\n)\n\n# Cache with 1-hour TTL\nawait cache_adapter.set(\n    key=CacheKey(key=\"session:xyz\"),\n    value=session_data,\n    ttl=timedelta(hours=1)\n)\n\n# Cache with tags for invalidation\nawait cache_adapter.set(\n    key=CacheKey(\n        key=\"product:456\",\n        tags=[\"product\", \"catalog\"]\n    ),\n    value=product_data,\n    ttl=timedelta(minutes=30)\n)\n</code></pre>"},{"location":"ports/cache/#other-methods","title":"Other Methods","text":""},{"location":"ports/cache/#delete","title":"delete","text":"<pre><code>async def delete(key: CacheKey) -&gt; bool\n</code></pre> <p>Deletes a single cached value. Returns True if key existed and was deleted.</p>"},{"location":"ports/cache/#delete_by_pattern","title":"delete_by_pattern","text":"<pre><code>async def delete_by_pattern(pattern: str) -&gt; int\n</code></pre> <p>Deletes all keys matching pattern (supports wildcards like <code>\"user:*\"</code>). Returns number of keys deleted.</p>"},{"location":"ports/cache/#delete_by_namespace","title":"delete_by_namespace","text":"<pre><code>async def delete_by_namespace(namespace: str) -&gt; int\n</code></pre> <p>Deletes all keys in a specific namespace. Returns number of keys deleted.</p>"},{"location":"ports/cache/#delete_by_tags","title":"delete_by_tags","text":"<pre><code>async def delete_by_tags(tags: list[str]) -&gt; int\n</code></pre> <p>Deletes all entries with any of the given tags. Returns number of entries deleted.</p>"},{"location":"ports/cache/#clear","title":"clear","text":"<pre><code>async def clear() -&gt; None\n</code></pre> <p>Clears all cached entries (use with caution in production).</p>"},{"location":"ports/cache/#exists","title":"exists","text":"<pre><code>async def exists(key: CacheKey) -&gt; bool\n</code></pre> <p>Checks if key exists in cache without retrieving the value.</p>"},{"location":"ports/cache/#get_stats","title":"get_stats","text":"<pre><code>async def get_stats() -&gt; CacheStats\n</code></pre> <p>Retrieves cache performance statistics.</p>"},{"location":"ports/cache/#cleanup_expired","title":"cleanup_expired","text":"<pre><code>async def cleanup_expired() -&gt; int\n</code></pre> <p>Removes expired entries from the cache. Returns number of expired entries removed.</p>"},{"location":"ports/cache/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/cache/#cache-aside-pattern-lazy-loading","title":"Cache-Aside Pattern (Lazy Loading)","text":"<pre><code>from portico.ports.cache import CacheKey, CacheAdapter\nfrom datetime import timedelta\n\nasync def get_user_profile(\n    user_id: str,\n    cache: CacheAdapter\n) -&gt; dict:\n    \"\"\"Get user profile with cache-aside pattern.\"\"\"\n\n    # 1. Try cache first\n    cache_key = CacheKey(key=f\"profile:{user_id}\")\n    entry = await cache.get(cache_key)\n\n    if entry and not entry.is_expired:\n        return entry.value\n\n    # 2. Cache miss - fetch from database\n    profile = await db.get_user_profile(user_id)\n\n    # 3. Store in cache for next time\n    await cache.set(\n        key=cache_key,\n        value=profile,\n        ttl=timedelta(hours=1)\n    )\n\n    return profile\n</code></pre>"},{"location":"ports/cache/#tag-based-invalidation","title":"Tag-Based Invalidation","text":"<pre><code># Cache with tags\nasync def cache_product(product_id: str, product: dict, cache: CacheAdapter):\n    key = CacheKey(\n        key=f\"product:{product_id}\",\n        tags=[\"product\", f\"category:{product['category_id']}\"]\n    )\n    await cache.set(key, product, ttl=timedelta(hours=1))\n\n# Invalidate all products in a category\nasync def invalidate_category(category_id: str, cache: CacheAdapter):\n    count = await cache.delete_by_tags([f\"category:{category_id}\"])\n    print(f\"Invalidated {count} products in category\")\n\n# Invalidate all product caches\nasync def invalidate_all_products(cache: CacheAdapter):\n    count = await cache.delete_by_tags([\"product\"])\n    print(f\"Invalidated {count} product caches\")\n</code></pre>"},{"location":"ports/cache/#integration-with-kits","title":"Integration with Kits","text":"<p>The Cache Port is used by the CacheKit to provide high-level caching services.</p> <pre><code>from portico import compose\n\n# Configure cache in webapp\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[\n        compose.cache(\n            backend=\"redis\",\n            redis_url=\"redis://localhost:6379/0\",\n            default_ttl_seconds=3600\n        ),\n    ],\n)\n\n# Access cache service\ncache_service = app.kits[\"cache\"].service\n\n# Use cache service\nawait cache_service.set(\n    key=\"user:123\",\n    value=user_data,\n    ttl=timedelta(hours=1),\n    namespace=\"users\",\n    tags=[\"user\", \"profile\"]\n)\n\n# Retrieve value\nuser_data = await cache_service.get(key=\"user:123\", namespace=\"users\")\n\n# Invalidate by tags\nawait cache_service.invalidate_tags([\"user:123\"])\n\n# Get statistics\nstats = await cache_service.get_stats()\n</code></pre> <p>The Cache Kit provides:</p> <ul> <li>Memory, Redis, and hybrid cache adapters</li> <li>Automatic serialization/deserialization</li> <li>Cache warming and preloading</li> <li>Performance monitoring and metrics</li> </ul> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/cache/#best-practices","title":"Best Practices","text":"<ol> <li>Use Namespaces for Isolation: Isolate cache keys by tenant/context for easy bulk operations</li> </ol> <pre><code># \u2705 GOOD: Isolated namespaces\nCacheKey(key=\"profile\", namespace=f\"user:{user_id}\")\nCacheKey(key=\"settings\", namespace=f\"tenant:{tenant_id}\")\n\n# \u274c BAD: No isolation\nCacheKey(key=f\"user_{user_id}_profile\")\n</code></pre> <ol> <li>Tag Related Data: Use tags to enable bulk invalidation of related cache entries</li> </ol> <pre><code># \u2705 GOOD: Tags enable bulk invalidation\nCacheKey(\n    key=f\"product:{product_id}\",\n    tags=[\"product\", f\"category:{category_id}\", f\"vendor:{vendor_id}\"]\n)\n\n# Invalidate all products in category\nawait cache.delete_by_tags([f\"category:{category_id}\"])\n</code></pre> <ol> <li>Set Appropriate TTLs: Different data types need different expiration times</li> </ol> <pre><code># \u2705 GOOD: Different TTLs for different data\nawait cache.set(session_key, session, ttl=timedelta(hours=1))    # Sessions\nawait cache.set(config_key, config, ttl=timedelta(days=1))       # Config\nawait cache.set(temp_key, temp, ttl=timedelta(minutes=5))        # Temporary\n\n# \u274c BAD: No TTL for temporary data\nawait cache.set(temp_key, temp)  # Never expires!\n</code></pre> <ol> <li>Handle Cache Misses Gracefully: Always have a fallback to the source of truth</li> </ol> <pre><code># \u2705 GOOD: Fallback to source\nentry = await cache.get(key)\nif entry and not entry.is_expired:\n    data = entry.value\nelse:\n    data = await fetch_from_source()\n    await cache.set(key, data, ttl=timedelta(hours=1))\n\n# \u274c BAD: Assume cache always has data\ndata = (await cache.get(key)).value  # May raise AttributeError!\n</code></pre> <ol> <li>Monitor Cache Performance: Regular monitoring helps optimize hit rates</li> </ol> <pre><code># \u2705 GOOD: Regular monitoring\nasync def monitor_cache():\n    stats = await cache.get_stats()\n    logger.info(\"cache_stats\", hit_rate=stats.hit_rate, entries=stats.total_entries)\n\n    if stats.hit_rate &lt; 0.5:\n        logger.warning(\"low_hit_rate\", hit_rate=stats.hit_rate)\n\n# Schedule periodic monitoring\nasyncio.create_task(periodic_monitor(interval=300))\n</code></pre>"},{"location":"ports/cache/#faqs","title":"FAQs","text":""},{"location":"ports/cache/#when-should-i-use-namespaces-vs-key-prefixes","title":"When should I use namespaces vs. key prefixes?","text":"<p>Use namespaces when you need to: - Clear all caches for a tenant/user in one operation - Logically isolate cache data - Implement multi-tenancy</p> <p>Use key prefixes when: - You need pattern-based matching (<code>\"user:*\"</code>) - Namespace isolation isn't required</p> <pre><code># Namespace (better for bulk operations)\nCacheKey(key=\"profile\", namespace=f\"user:{user_id}\")\nawait cache.delete_by_namespace(f\"user:{user_id}\")\n\n# Prefix (better for pattern matching)\nCacheKey(key=f\"user:{user_id}:profile\")\nawait cache.delete_by_pattern(f\"user:{user_id}:*\")\n</code></pre>"},{"location":"ports/cache/#how-do-tags-differ-from-namespaces","title":"How do tags differ from namespaces?","text":"<ul> <li>Namespaces: Hierarchical isolation (one namespace per key)</li> <li>Tags: Multi-dimensional categorization (multiple tags per key)</li> </ul> <pre><code># Can delete by namespace OR by any tag\nkey = CacheKey(\n    key=\"product:123\",\n    namespace=\"catalog\",\n    tags=[\"product\", \"category:electronics\", \"featured\"]\n)\n\nawait cache.delete_by_namespace(\"catalog\")            # Deletes this\nawait cache.delete_by_tags([\"product\"])              # Deletes this\nawait cache.delete_by_tags([\"category:electronics\"]) # Deletes this\n</code></pre>"},{"location":"ports/cache/#what-happens-if-i-dont-specify-a-ttl","title":"What happens if I don't specify a TTL?","text":"<p>Entries without TTL never expire automatically. You must manually delete them or use <code>cache.clear()</code>. This is appropriate for: - Configuration data that rarely changes - Reference data (e.g., country codes) - Data with manual invalidation logic</p>"},{"location":"ports/cache/#can-i-cache-complex-objects","title":"Can I cache complex objects?","text":"<p>Yes! <code>CacheEntry.value</code> accepts <code>Any</code> type. Adapters handle serialization:</p> <ul> <li>MemoryCacheAdapter: Stores objects directly (no serialization)</li> <li>RedisCacheAdapter: Uses JSON/pickle serialization</li> <li>HybridCacheAdapter: L1 (memory) stores objects, L2 (Redis) serializes</li> </ul> <pre><code># Cache complex objects\nawait cache.set(\n    key=CacheKey(key=\"complex\"),\n    value={\n        \"user\": user_obj,\n        \"settings\": settings_obj,\n        \"metadata\": {\"last_login\": datetime.now()}\n    }\n)\n</code></pre>"},{"location":"ports/cache/#how-do-i-prevent-cache-stampede","title":"How do I prevent cache stampede?","text":"<p>Cache stampede occurs when many requests simultaneously miss cache and hit the database. Use locking:</p> <pre><code>from asyncio import Lock\n\nlocks: dict[str, Lock] = {}\n\nasync def get_with_lock(key: str) -&gt; dict:\n    cache_key = CacheKey(key=key)\n\n    # Check cache\n    entry = await cache.get(cache_key)\n    if entry and not entry.is_expired:\n        return entry.value\n\n    # Acquire lock for this key\n    if key not in locks:\n        locks[key] = Lock()\n\n    async with locks[key]:\n        # Double-check cache (another request may have populated it)\n        entry = await cache.get(cache_key)\n        if entry and not entry.is_expired:\n            return entry.value\n\n        # Fetch and cache\n        data = await fetch_from_database(key)\n        await cache.set(cache_key, data, ttl=timedelta(hours=1))\n        return data\n</code></pre>"},{"location":"ports/embedding/","title":"Embedding Port","text":""},{"location":"ports/embedding/#overview","title":"Overview","text":"<p>The Embedding Port defines the contract for converting text into vector embeddings in Portico applications.</p> <p>Purpose: Abstract text embedding operations to enable pluggable embedding providers (OpenAI, Anthropic, local models, etc.).</p> <p>Domain: Natural language processing, semantic search, vector similarity</p> <p>Key Capabilities:</p> <ul> <li>Single and batch text embedding generation</li> <li>Multiple embedding model support</li> <li>Configurable embedding dimensions</li> <li>Token usage tracking</li> <li>Batch processing with configurable size limits</li> <li>Model dimension introspection</li> <li>Provider-agnostic interface for RAG and semantic search</li> </ul> <p>Port Type: Adapter</p> <p>When to Use:</p> <ul> <li>Applications requiring semantic search or similarity matching</li> <li>RAG (Retrieval-Augmented Generation) systems</li> <li>Document clustering and categorization</li> <li>Question-answering systems</li> <li>Recommendation engines based on text similarity</li> <li>Duplicate detection and content matching</li> </ul>"},{"location":"ports/embedding/#domain-models","title":"Domain Models","text":""},{"location":"ports/embedding/#embeddingrequest","title":"EmbeddingRequest","text":"<p>Request for generating text embeddings. Immutable.</p> Field Type Required Default Description <code>texts</code> <code>str \\| List[str]</code> Yes - Single text or list of texts to embed <code>model</code> <code>Optional[str]</code> No <code>None</code> Model to use (defaults to provider default) <code>encoding_format</code> <code>str</code> No <code>\"float\"</code> Encoding format (\"float\" or \"base64\") <code>dimensions</code> <code>Optional[int]</code> No <code>None</code> Embedding dimensions (for models supporting variable dims) <code>user</code> <code>Optional[str]</code> No <code>None</code> Optional user identifier for tracking <p>Example:</p> <pre><code>from portico.ports.embedding import EmbeddingRequest\n\n# Single text\nrequest = EmbeddingRequest(texts=\"Hello, world!\")\n\n# Multiple texts\nrequest = EmbeddingRequest(\n    texts=[\"Document 1\", \"Document 2\", \"Document 3\"],\n    model=\"text-embedding-3-small\",\n    dimensions=1536\n)\n\n# With user tracking\nrequest = EmbeddingRequest(\n    texts=\"User query\",\n    user=\"user_12345\"\n)\n</code></pre>"},{"location":"ports/embedding/#embeddingdata","title":"EmbeddingData","text":"<p>Individual embedding result within a response. Immutable.</p> Field Type Required Default Description <code>embedding</code> <code>List[float]</code> Yes - Embedding vector (list of floats) <code>index</code> <code>int</code> Yes - Index of this embedding in the batch <code>object</code> <code>str</code> No <code>\"embedding\"</code> Object type identifier <p>Example:</p> <pre><code>from portico.ports.embedding import EmbeddingData\n\ndata = EmbeddingData(\n    embedding=[0.123, -0.456, 0.789, ...],  # 1536 dimensions\n    index=0\n)\n\nprint(f\"Vector length: {len(data.embedding)}\")  # 1536\n</code></pre>"},{"location":"ports/embedding/#embeddingusage","title":"EmbeddingUsage","text":"<p>Token usage information for embedding generation. Immutable.</p> Field Type Required Default Description <code>prompt_tokens</code> <code>int</code> Yes - Number of tokens in input texts <code>total_tokens</code> <code>int</code> Yes - Total tokens consumed <p>Example:</p> <pre><code>from portico.ports.embedding import EmbeddingUsage\n\nusage = EmbeddingUsage(\n    prompt_tokens=100,\n    total_tokens=100\n)\n</code></pre>"},{"location":"ports/embedding/#embeddingresponse","title":"EmbeddingResponse","text":"<p>Response from embedding generation with metadata. Immutable.</p> Field Type Required Default Description <code>id</code> <code>str</code> No <code>uuid4()</code> Unique response identifier <code>object</code> <code>str</code> No <code>\"list\"</code> Object type identifier <code>data</code> <code>List[EmbeddingData]</code> Yes - List of embedding results <code>model</code> <code>str</code> Yes - Model used for generation <code>usage</code> <code>Optional[EmbeddingUsage]</code> No <code>None</code> Token usage information <code>created_at</code> <code>datetime</code> No Current UTC time Response creation timestamp <p>Properties:</p> <ul> <li><code>embeddings -&gt; List[List[float]]</code> - Convenience property returning just the embedding vectors</li> <li><code>single_embedding -&gt; List[float]</code> - Returns single embedding vector (raises ValueError if multiple embeddings)</li> </ul> <p>Example:</p> <pre><code>from portico.ports.embedding import EmbeddingResponse\n\nresponse = await embedding_provider.embed(request)\n\nprint(f\"Model: {response.model}\")\nprint(f\"Embeddings count: {len(response.data)}\")\nprint(f\"Tokens used: {response.usage.total_tokens}\")\n\n# Get all embeddings\nvectors = response.embeddings  # List[List[float]]\n\n# For single embedding request\nsingle_vector = response.single_embedding  # List[float]\nprint(f\"Dimension: {len(single_vector)}\")\n</code></pre>"},{"location":"ports/embedding/#embeddingconfig","title":"EmbeddingConfig","text":"<p>Configuration for embedding operations. Immutable.</p> Field Type Required Default Description <code>default_model</code> <code>str</code> No <code>\"text-embedding-3-small\"</code> Default embedding model <code>batch_size</code> <code>int</code> No <code>100</code> Maximum texts to process in one request <code>max_retries</code> <code>int</code> No <code>3</code> Maximum retry attempts on failure <code>timeout_seconds</code> <code>float</code> No <code>30.0</code> Request timeout in seconds <code>dimensions</code> <code>Optional[int]</code> No <code>None</code> Embedding dimensions (None = model default) <p>Example:</p> <pre><code>from portico.ports.embedding import EmbeddingConfig\n\nconfig = EmbeddingConfig(\n    default_model=\"text-embedding-3-large\",\n    batch_size=50,\n    max_retries=5,\n    timeout_seconds=60.0,\n    dimensions=3072\n)\n</code></pre>"},{"location":"ports/embedding/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/embedding/#embeddingprovider","title":"EmbeddingProvider","text":"<p>The <code>EmbeddingProvider</code> abstract base class defines the contract for all embedding providers.</p> <p>Location: <code>portico.ports.embedding.EmbeddingProvider</code></p>"},{"location":"ports/embedding/#key-methods","title":"Key Methods","text":""},{"location":"ports/embedding/#embed","title":"embed","text":"<pre><code>async def embed(request: EmbeddingRequest) -&gt; EmbeddingResponse\n</code></pre> <p>Generate embeddings for the given texts. Primary method for embedding generation with full control.</p> <p>Parameters:</p> <ul> <li><code>request</code>: Embedding request with texts and configuration</li> </ul> <p>Returns: EmbeddingResponse containing generated embeddings and metadata.</p> <p>Example:</p> <pre><code>from portico.ports.embedding import EmbeddingRequest\n\n# Embed single text\nrequest = EmbeddingRequest(texts=\"What is semantic search?\")\nresponse = await embedding_provider.embed(request)\n\nvector = response.single_embedding\nprint(f\"Embedding dimension: {len(vector)}\")\nprint(f\"Tokens used: {response.usage.total_tokens}\")\n\n# Embed multiple texts (batch)\nrequest = EmbeddingRequest(\n    texts=[\n        \"First document about cats\",\n        \"Second document about dogs\",\n        \"Third document about pets\"\n    ],\n    model=\"text-embedding-3-small\"\n)\nresponse = await embedding_provider.embed(request)\n\nfor i, embedding in enumerate(response.embeddings):\n    print(f\"Document {i}: {len(embedding)} dimensions\")\n</code></pre>"},{"location":"ports/embedding/#embed_text","title":"embed_text","text":"<pre><code>async def embed_text(text: str, model: Optional[str] = None, **kwargs: Any) -&gt; List[float]\n</code></pre> <p>Convenience method to embed a single text and return just the vector. Simpler interface for common use cases.</p> <p>Parameters:</p> <ul> <li><code>text</code>: Text to embed</li> <li><code>model</code>: Model to use, defaults to configured default</li> <li><code>**kwargs</code>: Additional provider-specific options</li> </ul> <p>Returns: Embedding vector as a list of floats.</p> <p>Example:</p> <pre><code># Simple single embedding\nvector = await embedding_provider.embed_text(\"Hello, world!\")\nprint(f\"Dimension: {len(vector)}\")  # e.g., 1536\n\n# With specific model\nvector = await embedding_provider.embed_text(\n    \"Semantic search query\",\n    model=\"text-embedding-3-large\"\n)\n\n# Use in similarity search\nquery_vector = await embedding_provider.embed_text(user_query)\nsimilar_docs = await vector_store.search(query_vector, top_k=10)\n</code></pre>"},{"location":"ports/embedding/#other-methods","title":"Other Methods","text":""},{"location":"ports/embedding/#embed_texts","title":"embed_texts","text":"<pre><code>async def embed_texts(\n    texts: List[str],\n    model: Optional[str] = None,\n    **kwargs: Any\n) -&gt; List[List[float]]\n</code></pre> <p>Convenience method to embed multiple texts and return just the vectors. Returns list of embedding vectors, one for each input text.</p>"},{"location":"ports/embedding/#get_embedding_dimension","title":"get_embedding_dimension","text":"<pre><code>async def get_embedding_dimension(model: Optional[str] = None) -&gt; int\n</code></pre> <p>Get the dimension of embeddings produced by the specified model. Returns dimension (length) of embedding vectors produced by the model.</p>"},{"location":"ports/embedding/#list_models","title":"list_models","text":"<pre><code>async def list_models() -&gt; List[str]\n</code></pre> <p>List available embedding models from the provider.</p>"},{"location":"ports/embedding/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/embedding/#semantic-search-with-embeddings","title":"Semantic Search with Embeddings","text":"<pre><code>from portico.ports.embedding import EmbeddingProvider\nfrom portico.ports.vector_store import VectorStore\n\nasync def semantic_search(\n    query: str,\n    embedding_provider: EmbeddingProvider,\n    vector_store: VectorStore,\n    top_k: int = 5\n) -&gt; list:\n    \"\"\"Perform semantic search using embeddings.\"\"\"\n\n    # 1. Embed the query\n    query_vector = await embedding_provider.embed_text(query)\n\n    # 2. Search vector store\n    results = await vector_store.search(\n        vector=query_vector,\n        top_k=top_k,\n        namespace=\"documents\"\n    )\n\n    # 3. Return matches\n    return [\n        {\n            \"text\": result.metadata.get(\"text\"),\n            \"score\": result.score,\n            \"document_id\": result.id\n        }\n        for result in results\n    ]\n\n# Usage\nresults = await semantic_search(\n    query=\"How do I install Portico?\",\n    embedding_provider=app.kits[\"rag\"].embedding_provider,\n    vector_store=app.kits[\"rag\"].vector_store,\n    top_k=10\n)\n\nfor result in results:\n    print(f\"Score: {result['score']:.3f} - {result['text'][:100]}\")\n</code></pre>"},{"location":"ports/embedding/#batch-document-processing","title":"Batch Document Processing","text":"<pre><code>from portico.ports.embedding import EmbeddingProvider\n\nasync def embed_documents_in_batches(\n    documents: list[str],\n    embedding_provider: EmbeddingProvider,\n    batch_size: int = 100\n) -&gt; list[list[float]]:\n    \"\"\"Embed large document collections in batches.\"\"\"\n\n    all_embeddings = []\n\n    # Process in batches to avoid rate limits\n    for i in range(0, len(documents), batch_size):\n        batch = documents[i:i + batch_size]\n\n        # Embed batch\n        embeddings = await embedding_provider.embed_texts(batch)\n        all_embeddings.extend(embeddings)\n\n        logger.info(\n            \"batch_embedded\",\n            batch_num=i // batch_size + 1,\n            batch_size=len(batch),\n            total_processed=len(all_embeddings)\n        )\n\n    return all_embeddings\n\n# Usage\ndocuments = load_document_corpus()  # 10,000 documents\nembeddings = await embed_documents_in_batches(\n    documents,\n    embedding_provider,\n    batch_size=100\n)\n\n# Store in vector database\nawait store_embeddings(documents, embeddings)\n</code></pre>"},{"location":"ports/embedding/#integration-with-kits","title":"Integration with Kits","text":"<p>The Embedding Port is used by the RAG Kit to provide text embedding services.</p> <pre><code>from portico import compose\n\n# Configure RAG kit with OpenAI embeddings\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[\n        compose.rag(\n            llm_provider=\"openai\",\n            llm_api_key=\"sk-...\",\n            embedding_provider=\"openai\",\n            embedding_api_key=\"sk-...\",\n            embedding_model=\"text-embedding-3-small\",\n            vector_store_type=\"memory\"\n        ),\n    ],\n)\n\nawait app.initialize()\n\n# Access embedding provider through RAG kit\nembedding_provider = app.kits[\"rag\"].embedding_provider\n\n# Single text embedding\nvector = await embedding_provider.embed_text(\"Hello, world!\")\nprint(f\"Embedding dimension: {len(vector)}\")  # 1536\n\n# Batch embedding\nvectors = await embedding_provider.embed_texts([\n    \"First document\",\n    \"Second document\",\n    \"Third document\"\n])\nprint(f\"Generated {len(vectors)} embeddings\")\n\n# Get model info\ndimension = await embedding_provider.get_embedding_dimension()\nmodels = await embedding_provider.list_models()\nprint(f\"Available models: {models}\")\n</code></pre> <p>The RAG Kit provides:</p> <ul> <li>OpenAI embedding provider adapter</li> <li>Automatic batching for large document sets</li> <li>Rate limiting and retry logic</li> <li>Integration with vector stores for semantic search</li> <li>Document chunking and embedding pipeline</li> </ul> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/embedding/#best-practices","title":"Best Practices","text":"<ol> <li>Use Batch Processing for Multiple Texts: Batch embedding is more efficient than multiple single calls</li> </ol> <pre><code># \u2705 GOOD: Batch processing\nvectors = await embedding_provider.embed_texts([\n    \"Text 1\", \"Text 2\", \"Text 3\", \"Text 4\", \"Text 5\"\n])\n\n# \u274c BAD: Individual calls (slower, more expensive)\nvectors = []\nfor text in texts:\n    vector = await embedding_provider.embed_text(text)\n    vectors.append(vector)\n</code></pre> <ol> <li>Match Embedding Dimensions to Vector Store: Ensure embedding dimension matches vector store configuration</li> </ol> <pre><code># \u2705 GOOD: Consistent dimensions\ncompose.rag(\n    embedding_model=\"text-embedding-3-small\",  # 1536 dims\n    vector_store_config={\n        \"dimension\": 1536,  # Matches embedding model\n        ...\n    }\n)\n\n# \u274c BAD: Mismatched dimensions\n# embedding_model: 1536 dims, vector_store: 3072 dims\n# Will cause errors!\n</code></pre> <ol> <li>Cache Embeddings for Static Content: Avoid re-embedding the same text repeatedly</li> </ol> <pre><code># \u2705 GOOD: Cache embeddings\ncached_embedding = await cache.get(f\"embedding:{text_hash}\")\nif not cached_embedding:\n    cached_embedding = await embedding_provider.embed_text(text)\n    await cache.set(f\"embedding:{text_hash}\", cached_embedding, ttl=timedelta(days=7))\n\n# \u274c BAD: Re-embed same text every time\nvector = await embedding_provider.embed_text(static_faq_text)\n</code></pre> <ol> <li>Handle Rate Limits with Retries: Embedding APIs have rate limits; use retry logic</li> </ol> <pre><code># \u2705 GOOD: Built-in retry configuration\nconfig = EmbeddingConfig(\n    default_model=\"text-embedding-3-small\",\n    max_retries=5,\n    timeout_seconds=60.0\n)\n\n# \u274c BAD: No retry logic\n# Single failure will crash the entire batch\n</code></pre> <ol> <li>Use Appropriate Models for Your Use Case: Larger models provide better quality but cost more</li> </ol> <pre><code># \u2705 GOOD: Match model to use case\n# text-embedding-3-small (1536 dims) - General search, lower cost\n# text-embedding-3-large (3072 dims) - High accuracy, higher cost\n\n# For general search\ncompose.rag(embedding_model=\"text-embedding-3-small\")\n\n# For specialized domains requiring high accuracy\ncompose.rag(embedding_model=\"text-embedding-3-large\")\n\n# \u274c BAD: Using large model when small would suffice\n# Wastes money and time\n</code></pre>"},{"location":"ports/embedding/#faqs","title":"FAQs","text":""},{"location":"ports/embedding/#what-embedding-models-are-available","title":"What embedding models are available?","text":"<p>Portico includes an OpenAI embedding provider supporting:</p> <ul> <li><code>text-embedding-3-small</code> - 1536 dimensions (default, cost-effective)</li> <li><code>text-embedding-3-large</code> - 3072 dimensions (higher accuracy)</li> <li><code>text-embedding-ada-002</code> - 1536 dimensions (legacy model)</li> </ul> <p>You can check available models at runtime:</p> <pre><code>models = await embedding_provider.list_models()\n</code></pre>"},{"location":"ports/embedding/#how-do-i-choose-embedding-dimensions","title":"How do I choose embedding dimensions?","text":"<p>Embedding dimensions affect quality, cost, and storage:</p> <ul> <li>1536 dimensions (text-embedding-3-small): Good balance, suitable for most use cases</li> <li>3072 dimensions (text-embedding-3-large): Better accuracy, 2x storage cost</li> </ul> <p>Rule of thumb: Start with 1536, upgrade to 3072 if accuracy is insufficient.</p>"},{"location":"ports/embedding/#can-i-use-embeddings-from-different-models-together","title":"Can I use embeddings from different models together?","text":"<p>No! Embeddings from different models are not comparable. You cannot:</p> <ul> <li>Mix embeddings from <code>text-embedding-3-small</code> and <code>text-embedding-3-large</code> in the same vector store</li> <li>Compare similarity between vectors from different models</li> </ul> <p>Always use the same model for both indexing and querying.</p> <pre><code># \u274c WRONG: Different models\n# Index documents with model A\ndoc_embeddings = await provider.embed_texts(docs, model=\"text-embedding-3-small\")\n\n# Query with model B - WON'T WORK!\nquery_embedding = await provider.embed_text(query, model=\"text-embedding-3-large\")\n</code></pre>"},{"location":"ports/embedding/#how-much-does-embedding-cost","title":"How much does embedding cost?","text":"<p>OpenAI embedding costs (as of 2024):</p> <ul> <li><code>text-embedding-3-small</code>: $0.02 / 1M tokens</li> <li><code>text-embedding-3-large</code>: $0.13 / 1M tokens</li> </ul> <p>A typical 500-word document \u2248 650 tokens. So: - 1,000 documents \u2248 650K tokens \u2248 $0.01 (small) or $0.08 (large)</p> <p>Use <code>response.usage.total_tokens</code> to track consumption.</p>"},{"location":"ports/embedding/#how-do-i-implement-a-custom-embedding-provider","title":"How do I implement a custom embedding provider?","text":"<p>Implement the <code>EmbeddingProvider</code> interface:</p> <pre><code>from portico.ports.embedding import EmbeddingProvider, EmbeddingRequest, EmbeddingResponse\n\nclass CustomEmbeddingProvider(EmbeddingProvider):\n    async def embed(self, request: EmbeddingRequest) -&gt; EmbeddingResponse:\n        # Call your embedding service/model\n        vectors = await your_model.encode(request.texts)\n\n        # Return EmbeddingResponse\n        return EmbeddingResponse(\n            data=[EmbeddingData(embedding=vec, index=i) for i, vec in enumerate(vectors)],\n            model=\"your-model-name\"\n        )\n\n    async def embed_text(self, text: str, model: Optional[str] = None) -&gt; List[float]:\n        response = await self.embed(EmbeddingRequest(texts=text, model=model))\n        return response.single_embedding\n\n    # Implement other abstract methods...\n</code></pre> <p>Then use it in composition:</p> <pre><code>def rag(**config):\n    from your_module import CustomEmbeddingProvider\n    from portico.kits.rag import RAGKit\n\n    def factory(database, events):\n        embedding_provider = CustomEmbeddingProvider(api_key=config[\"api_key\"])\n        return RAGKit.create(database, events, config, embedding_provider=embedding_provider)\n\n    return factory\n</code></pre>"},{"location":"ports/file_storage/","title":"File Storage Port","text":""},{"location":"ports/file_storage/#overview","title":"Overview","text":"<p>The File Storage Port defines the contract for file upload, storage, and retrieval in Portico applications.</p> <p>Purpose: Abstract file storage operations to enable pluggable storage backends while maintaining metadata in a database.</p> <p>Domain: File management, binary storage, access control</p> <p>Key Capabilities:</p> <ul> <li>Binary file upload and download with metadata tracking</li> <li>User and group file ownership</li> <li>Public and private file access control</li> <li>File search and listing with pagination</li> <li>Multiple storage backends (local filesystem, cloud storage, database blobs)</li> <li>Content type detection and validation</li> <li>File size limits and validation</li> <li>Tag-based file organization</li> </ul> <p>Port Type: Repository + Adapter (dual interface)</p> <p>When to Use:</p> <ul> <li>Applications requiring user file uploads (documents, images, etc.)</li> <li>Multi-tenant systems with per-user or per-group file storage</li> <li>Systems requiring cloud storage integration (GCS, S3, etc.)</li> <li>Applications with public file sharing requirements</li> <li>Document management and file organization features</li> </ul>"},{"location":"ports/file_storage/#domain-models","title":"Domain Models","text":""},{"location":"ports/file_storage/#filemetadata","title":"FileMetadata","text":"<p>Represents metadata for a stored file. Immutable.</p> Field Type Required Default Description <code>id</code> <code>UUID</code> Yes <code>uuid4()</code> Unique file identifier <code>filename</code> <code>str</code> Yes - Current filename <code>original_filename</code> <code>str</code> Yes - Original filename at upload <code>content_type</code> <code>str</code> Yes - MIME type (e.g., \"image/png\") <code>size_bytes</code> <code>int</code> Yes - File size in bytes <code>owner_type</code> <code>FileOwnerType</code> Yes - Owner type (USER or GROUP) <code>owner_id</code> <code>UUID</code> Yes - Owner identifier <code>storage_path</code> <code>Optional[str]</code> No <code>None</code> Internal storage path (backend-specific) <code>is_public</code> <code>bool</code> No <code>False</code> Whether file is publicly accessible <code>description</code> <code>Optional[str]</code> No <code>None</code> Optional file description <code>tags</code> <code>list[str]</code> No <code>[]</code> Tags for organization and search <code>created_at</code> <code>datetime</code> Yes Current UTC time Upload timestamp <code>updated_at</code> <code>datetime</code> Yes Current UTC time Last metadata update timestamp <p>Class Methods:</p> <ul> <li><code>@classmethod detect_content_type(filename: str) -&gt; str</code> - Detects MIME type from filename extension</li> </ul> <p>Example:</p> <pre><code>from portico.ports.file_storage import FileMetadata, FileOwnerType\n\nmetadata = FileMetadata(\n    id=uuid4(),\n    filename=\"report.pdf\",\n    original_filename=\"Q4-Report-2024.pdf\",\n    content_type=\"application/pdf\",\n    size_bytes=1024000,\n    owner_type=FileOwnerType.USER,\n    owner_id=user_id,\n    is_public=False,\n    tags=[\"report\", \"q4\", \"2024\"]\n)\n\n# Detect content type\ncontent_type = FileMetadata.detect_content_type(\"image.png\")  # \"image/png\"\n</code></pre>"},{"location":"ports/file_storage/#fileuploadrequest","title":"FileUploadRequest","text":"<p>Request model for uploading a new file.</p> Field Type Required Default Description <code>filename</code> <code>str</code> Yes - Filename for the uploaded file <code>content_type</code> <code>Optional[str]</code> No <code>None</code> MIME type (auto-detected if not provided) <code>owner_type</code> <code>FileOwnerType</code> Yes - Owner type (USER or GROUP) <code>owner_id</code> <code>UUID</code> Yes - Owner identifier <code>is_public</code> <code>bool</code> No <code>False</code> Whether file is publicly accessible <code>description</code> <code>Optional[str]</code> No <code>None</code> Optional file description <code>tags</code> <code>list[str]</code> No <code>[]</code> Tags for organization <p>Methods:</p> <ul> <li><code>get_content_type() -&gt; str</code> - Returns content type, detecting from filename if not provided</li> </ul> <p>Example:</p> <pre><code>from portico.ports.file_storage import FileUploadRequest, FileOwnerType\n\nrequest = FileUploadRequest(\n    filename=\"document.pdf\",\n    owner_type=FileOwnerType.USER,\n    owner_id=user_id,\n    is_public=False,\n    description=\"Important document\",\n    tags=[\"work\", \"important\"]\n)\n\n# Content type auto-detected as \"application/pdf\"\nprint(request.get_content_type())\n</code></pre>"},{"location":"ports/file_storage/#fileupdaterequest","title":"FileUpdateRequest","text":"<p>Request model for updating file metadata. All fields optional for partial updates.</p> Field Type Required Default Description <code>filename</code> <code>Optional[str]</code> No <code>None</code> New filename <code>is_public</code> <code>Optional[bool]</code> No <code>None</code> New public status <code>description</code> <code>Optional[str]</code> No <code>None</code> New description <code>tags</code> <code>Optional[list[str]]</code> No <code>None</code> New tags (replaces existing) <p>Example:</p> <pre><code>from portico.ports.file_storage import FileUpdateRequest\n\n# Update filename and make public\nrequest = FileUpdateRequest(\n    filename=\"renamed-document.pdf\",\n    is_public=True\n)\n</code></pre>"},{"location":"ports/file_storage/#filecontent","title":"FileContent","text":"<p>Represents file content with metadata for download operations.</p> Field Type Required Default Description <code>metadata</code> <code>FileMetadata</code> Yes - File metadata <code>content</code> <code>bytes</code> Yes - Binary file content <p>Example:</p> <pre><code>from portico.ports.file_storage import FileContent\n\nfile_content = await storage_service.get_file(file_id)\nprint(f\"Filename: {file_content.metadata.filename}\")\nprint(f\"Size: {file_content.metadata.size_bytes} bytes\")\n\n# Save to disk\nwith open(file_content.metadata.filename, \"wb\") as f:\n    f.write(file_content.content)\n</code></pre>"},{"location":"ports/file_storage/#enumerations","title":"Enumerations","text":""},{"location":"ports/file_storage/#fileownertype","title":"FileOwnerType","text":"<p>Valid owner types for files.</p> Value Description <code>USER</code> File owned by a user <code>GROUP</code> File owned by a group <p>Example:</p> <pre><code>from portico.ports.file_storage import FileOwnerType\n\n# User-owned file\nowner_type = FileOwnerType.USER\n\n# Group-owned file\nowner_type = FileOwnerType.GROUP\n</code></pre>"},{"location":"ports/file_storage/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/file_storage/#filerepository","title":"FileRepository","text":"<p>The <code>FileRepository</code> abstract base class defines the contract for file metadata storage and retrieval.</p> <p>Location: <code>portico.ports.file_storage.FileRepository</code></p>"},{"location":"ports/file_storage/#key-methods","title":"Key Methods","text":""},{"location":"ports/file_storage/#create_metadata","title":"create_metadata","text":"<pre><code>async def create_metadata(\n    file_id: UUID,\n    file_data: FileUploadRequest,\n    storage_path: str,\n    size_bytes: int\n) -&gt; FileMetadata\n</code></pre> <p>Create file metadata record after file has been stored.</p> <p>Parameters:</p> <ul> <li><code>file_id</code>: Unique file identifier</li> <li><code>file_data</code>: File upload request data</li> <li><code>storage_path</code>: Path where file is stored in the storage backend</li> <li><code>size_bytes</code>: File size in bytes</li> </ul> <p>Returns: Created file metadata.</p> <p>Example:</p> <pre><code>from uuid import uuid4\nfrom portico.ports.file_storage import FileUploadRequest, FileOwnerType\n\nfile_id = uuid4()\nstorage_path = f\"uploads/{file_id}/document.pdf\"\n\nmetadata = await file_repository.create_metadata(\n    file_id=file_id,\n    file_data=FileUploadRequest(\n        filename=\"document.pdf\",\n        owner_type=FileOwnerType.USER,\n        owner_id=user_id,\n        tags=[\"document\"]\n    ),\n    storage_path=storage_path,\n    size_bytes=102400\n)\n</code></pre>"},{"location":"ports/file_storage/#get_metadata_by_id","title":"get_metadata_by_id","text":"<pre><code>async def get_metadata_by_id(file_id: UUID) -&gt; Optional[FileMetadata]\n</code></pre> <p>Retrieve file metadata by ID.</p> <p>Parameters:</p> <ul> <li><code>file_id</code>: File identifier</li> </ul> <p>Returns: File metadata if found, None otherwise.</p> <p>Example:</p> <pre><code>metadata = await file_repository.get_metadata_by_id(file_id)\n\nif metadata:\n    print(f\"File: {metadata.filename}\")\n    print(f\"Size: {metadata.size_bytes} bytes\")\n    print(f\"Owner: {metadata.owner_type}:{metadata.owner_id}\")\nelse:\n    print(\"File not found\")\n</code></pre>"},{"location":"ports/file_storage/#other-methods","title":"Other Methods","text":""},{"location":"ports/file_storage/#update_metadata","title":"update_metadata","text":"<pre><code>async def update_metadata(file_id: UUID, update_data: FileUpdateRequest) -&gt; Optional[FileMetadata]\n</code></pre> <p>Update file metadata. Returns updated metadata if found, None otherwise.</p>"},{"location":"ports/file_storage/#delete_metadata","title":"delete_metadata","text":"<pre><code>async def delete_metadata(file_id: UUID) -&gt; bool\n</code></pre> <p>Delete file metadata. Returns True if deleted, False if not found.</p>"},{"location":"ports/file_storage/#list_files_by_owner","title":"list_files_by_owner","text":"<pre><code>async def list_files_by_owner(\n    owner_type: FileOwnerType,\n    owner_id: UUID,\n    limit: int = 100,\n    offset: int = 0\n) -&gt; list[FileMetadata]\n</code></pre> <p>List files owned by a specific user or group with pagination.</p>"},{"location":"ports/file_storage/#list_public_files","title":"list_public_files","text":"<pre><code>async def list_public_files(limit: int = 100, offset: int = 0) -&gt; list[FileMetadata]\n</code></pre> <p>List all public files with pagination.</p>"},{"location":"ports/file_storage/#search_files","title":"search_files","text":"<pre><code>async def search_files(\n    query: str,\n    owner_type: Optional[FileOwnerType] = None,\n    owner_id: Optional[UUID] = None,\n    limit: int = 100,\n    offset: int = 0\n) -&gt; list[FileMetadata]\n</code></pre> <p>Search files by filename or description. Optionally filter by owner.</p>"},{"location":"ports/file_storage/#filestorageadapter","title":"FileStorageAdapter","text":"<p>The <code>FileStorageAdapter</code> abstract base class defines the contract for physical file storage operations.</p> <p>Location: <code>portico.ports.file_storage.FileStorageAdapter</code></p>"},{"location":"ports/file_storage/#key-methods_1","title":"Key Methods","text":""},{"location":"ports/file_storage/#store_file","title":"store_file","text":"<pre><code>async def store_file(file_content: BinaryIO, storage_path: str) -&gt; bool\n</code></pre> <p>Store file content at the specified path. Primary method for file uploads.</p> <p>Parameters:</p> <ul> <li><code>file_content</code>: Binary file content to store (file-like object)</li> <li><code>storage_path</code>: Path where file should be stored (format depends on backend)</li> </ul> <p>Returns: True if stored successfully, False otherwise.</p> <p>Example:</p> <pre><code>import io\nfrom uuid import uuid4\n\n# Store file from bytes\nfile_content = b\"Hello, World!\"\nfile_stream = io.BytesIO(file_content)\n\nfile_id = uuid4()\nstorage_path = storage_adapter.generate_storage_path(file_id, \"hello.txt\")\n\nsuccess = await storage_adapter.store_file(file_stream, storage_path)\nif success:\n    print(f\"File stored at: {storage_path}\")\n</code></pre>"},{"location":"ports/file_storage/#retrieve_file","title":"retrieve_file","text":"<pre><code>async def retrieve_file(storage_path: str) -&gt; Optional[bytes]\n</code></pre> <p>Retrieve file content from storage path. Primary method for file downloads.</p> <p>Parameters:</p> <ul> <li><code>storage_path</code>: Path to retrieve file from</li> </ul> <p>Returns: File content as bytes if found, None otherwise.</p> <p>Example:</p> <pre><code>content = await storage_adapter.retrieve_file(storage_path)\n\nif content:\n    # Save to disk\n    with open(\"downloaded_file.pdf\", \"wb\") as f:\n        f.write(content)\nelse:\n    print(\"File not found in storage\")\n</code></pre>"},{"location":"ports/file_storage/#other-methods_1","title":"Other Methods","text":""},{"location":"ports/file_storage/#delete_file","title":"delete_file","text":"<pre><code>async def delete_file(storage_path: str) -&gt; bool\n</code></pre> <p>Delete file from storage. Returns True if deleted successfully, False otherwise.</p>"},{"location":"ports/file_storage/#file_exists","title":"file_exists","text":"<pre><code>async def file_exists(storage_path: str) -&gt; bool\n</code></pre> <p>Check if file exists at storage path. Returns True if file exists, False otherwise.</p>"},{"location":"ports/file_storage/#get_file_size","title":"get_file_size","text":"<pre><code>async def get_file_size(storage_path: str) -&gt; Optional[int]\n</code></pre> <p>Get file size in bytes. Returns file size if found, None otherwise.</p>"},{"location":"ports/file_storage/#generate_storage_path","title":"generate_storage_path","text":"<pre><code>def generate_storage_path(file_id: UUID, filename: str) -&gt; str\n</code></pre> <p>Generate a storage path for a file. Implementation depends on backend (local path, cloud storage key, etc.).</p>"},{"location":"ports/file_storage/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/file_storage/#file-upload-with-access-control","title":"File Upload with Access Control","text":"<pre><code>from portico.ports.file_storage import FileUploadRequest, FileOwnerType\nfrom portico.exceptions import FileSizeExceededError, FileUploadError\n\nasync def upload_user_document(\n    user_id: UUID,\n    file_content: bytes,\n    filename: str,\n    file_service: FileStorageService\n) -&gt; FileMetadata:\n    \"\"\"Upload a file owned by a user.\"\"\"\n\n    try:\n        # Create upload request\n        upload_request = FileUploadRequest(\n            filename=filename,\n            owner_type=FileOwnerType.USER,\n            owner_id=user_id,\n            is_public=False,  # Private by default\n            tags=[\"user-upload\"]\n        )\n\n        # Upload file\n        metadata = await file_service.upload_file(file_content, upload_request)\n\n        logger.info(\"file_uploaded\", file_id=str(metadata.id), user_id=str(user_id))\n        return metadata\n\n    except FileSizeExceededError as e:\n        logger.warning(\"file_too_large\", size=e.actual_size, limit=e.max_size)\n        raise\n    except FileUploadError as e:\n        logger.error(\"upload_failed\", error=str(e))\n        raise\n</code></pre>"},{"location":"ports/file_storage/#secure-file-download","title":"Secure File Download","text":"<pre><code>from portico.exceptions import FileNotFoundError, FileAccessError\n\nasync def download_file_with_access_check(\n    file_id: UUID,\n    requesting_user_id: UUID,\n    file_service: FileStorageService\n) -&gt; FileContent:\n    \"\"\"Download file with access control.\"\"\"\n\n    try:\n        # Service checks access permissions automatically\n        file_content = await file_service.get_file(\n            file_id=file_id,\n            requesting_user_id=requesting_user_id\n        )\n\n        logger.info(\"file_downloaded\", file_id=str(file_id), user_id=str(requesting_user_id))\n        return file_content\n\n    except FileNotFoundError:\n        logger.warning(\"file_not_found\", file_id=str(file_id))\n        raise\n    except FileAccessError:\n        logger.warning(\"access_denied\", file_id=str(file_id), user_id=str(requesting_user_id))\n        raise\n</code></pre>"},{"location":"ports/file_storage/#integration-with-kits","title":"Integration with Kits","text":"<p>The File Storage Port is used by the File Storage Kit to provide high-level file management services.</p> <pre><code>from portico import compose\n\n# Configure with local storage (development)\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[\n        compose.file(\n            storage_backend=\"local\",\n            storage_path=\"./uploads\",\n            max_file_size_mb=100\n        ),\n    ],\n)\n\n# Configure with Google Cloud Storage (production)\napp = compose.webapp(\n    database_url=\"postgresql+asyncpg://user:pass@localhost/db\",\n    kits=[\n        compose.file(\n            storage_backend=\"gcs\",\n            gcs_bucket=\"my-app-files\",\n            gcs_project=\"my-gcp-project\",\n            gcs_credentials_path=\"/path/to/service-account.json\",\n            max_file_size_mb=500\n        ),\n    ],\n)\n\n# Access file service\nfile_service = app.kits[\"file_storage\"].service\n\n# Upload file\nwith open(\"document.pdf\", \"rb\") as f:\n    metadata = await file_service.upload_file(\n        file_content=f,\n        upload_request=FileUploadRequest(\n            filename=\"document.pdf\",\n            owner_type=FileOwnerType.USER,\n            owner_id=user_id,\n            is_public=False\n        )\n    )\n\n# Download file\nfile_content = await file_service.get_file(\n    file_id=metadata.id,\n    requesting_user_id=user_id\n)\n\n# Save to disk\nwith open(\"downloaded.pdf\", \"wb\") as f:\n    f.write(file_content.content)\n</code></pre> <p>The File Storage Kit provides:</p> <ul> <li>Local filesystem storage adapter</li> <li>Google Cloud Storage (GCS) adapter</li> <li>Database blob storage adapter</li> <li>Automatic content type detection</li> <li>File size validation</li> <li>User and group ownership with access control</li> <li>Public/private file sharing</li> </ul> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/file_storage/#best-practices","title":"Best Practices","text":"<ol> <li>Always Validate File Size: Set appropriate limits to prevent storage abuse and DoS attacks</li> </ol> <pre><code># \u2705 GOOD: Set reasonable limits\ncompose.file(storage_backend=\"local\", max_file_size_mb=100)\n\n# \u274c BAD: No size limits (vulnerable to abuse)\n# Missing max_file_size configuration\n</code></pre> <ol> <li>Use Access Control: Always pass <code>requesting_user_id</code> to enforce ownership checks</li> </ol> <pre><code># \u2705 GOOD: Enforce access control\nfile_content = await file_service.get_file(\n    file_id=file_id,\n    requesting_user_id=current_user.id\n)\n\n# \u274c BAD: No access control\nfile_content = await file_service.get_file(file_id)\n</code></pre> <ol> <li>Choose Appropriate Storage Backend: Use local for development, cloud for production</li> </ol> <pre><code># \u2705 GOOD: Local for dev, GCS for prod\nif os.getenv(\"ENV\") == \"production\":\n    backend = \"gcs\"\n    config = {\"gcs_bucket\": \"prod-files\", ...}\nelse:\n    backend = \"local\"\n    config = {\"storage_path\": \"./dev-uploads\"}\n\n# \u274c BAD: Local storage in production (doesn't scale)\nbackend = \"local\"  # Won't work with multiple servers!\n</code></pre> <ol> <li>Tag Files for Organization: Use tags to enable bulk operations and categorization</li> </ol> <pre><code># \u2705 GOOD: Tags enable organization\nFileUploadRequest(\n    filename=\"report.pdf\",\n    owner_type=FileOwnerType.USER,\n    owner_id=user_id,\n    tags=[\"report\", \"q4-2024\", \"finance\"]\n)\n\n# Later: search by tag\nresults = await file_service.search_files(query=\"q4-2024\")\n\n# \u274c BAD: No tags (harder to organize)\nFileUploadRequest(filename=\"report.pdf\", owner_type=..., owner_id=...)\n</code></pre> <ol> <li>Clean Up Storage on Metadata Deletion: Ensure both metadata and file content are deleted together</li> </ol> <pre><code># \u2705 GOOD: Service handles both (use FileStorageService.delete_file)\nsuccess = await file_service.delete_file(file_id, requesting_user_id)\n# Deletes both storage and metadata\n\n# \u274c BAD: Only deleting metadata (orphans file in storage)\nawait file_repository.delete_metadata(file_id)\n# File still exists in storage!\n</code></pre>"},{"location":"ports/file_storage/#faqs","title":"FAQs","text":""},{"location":"ports/file_storage/#what-storage-backends-are-available","title":"What storage backends are available?","text":"<p>Portico includes three built-in adapters:</p> <ul> <li>LocalFileStorageAdapter: Stores files on local filesystem (development)</li> <li>GCSFileStorageAdapter: Google Cloud Storage (production)</li> <li>DatabaseBlobStorageAdapter: Stores files as BLOBs in database (simple deployments)</li> </ul> <p>Each has trade-offs: - Local: Fast, simple, but doesn't scale across servers - GCS: Scalable, reliable, but requires cloud setup - Database: Simple deployment, but not ideal for large files</p>"},{"location":"ports/file_storage/#how-does-file-ownership-and-access-control-work","title":"How does file ownership and access control work?","text":"<p>Files have an <code>owner_type</code> (USER or GROUP) and <code>owner_id</code>. Access rules:</p> <ol> <li>Public files (<code>is_public=True</code>): Anyone can read</li> <li>User-owned files: Only owner can read/write</li> <li>Group-owned files: Group members can read (requires group membership check)</li> </ol> <pre><code># Upload as user-owned\nFileUploadRequest(owner_type=FileOwnerType.USER, owner_id=user_id)\n\n# Upload as group-owned\nFileUploadRequest(owner_type=FileOwnerType.GROUP, owner_id=group_id)\n</code></pre>"},{"location":"ports/file_storage/#can-i-restrict-file-types","title":"Can I restrict file types?","text":"<p>Yes! Configure <code>allowed_content_types</code> when creating the file service:</p> <pre><code>file_service = FileStorageService(\n    file_repository=repo,\n    storage_adapter=adapter,\n    allowed_content_types={\"image/png\", \"image/jpeg\", \"application/pdf\"}\n)\n\n# Now only images and PDFs can be uploaded\n</code></pre>"},{"location":"ports/file_storage/#what-happens-if-storage-fails-but-metadata-succeeds","title":"What happens if storage fails but metadata succeeds?","text":"<p>The <code>FileStorageService</code> stores the file first, then creates metadata. If storage fails, no metadata is created (no orphan records). If metadata creation fails after successful storage, you may have orphaned files in storage.</p> <p>Best Practice: Use the <code>FileStorageService</code> which handles the two-phase commit correctly:</p> <pre><code># \u2705 Service handles errors correctly\nmetadata = await file_service.upload_file(file_content, upload_request)\n\n# \u274c Don't manually coordinate repository + adapter\n# Risk of inconsistency!\n</code></pre>"},{"location":"ports/file_storage/#how-do-i-generate-download-urls-for-files","title":"How do I generate download URLs for files?","text":"<p>The <code>FileStorageService</code> provides a <code>get_file_url()</code> method that returns a URL path. You'll need to implement a FastAPI endpoint to serve files:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.responses import StreamingResponse\n\napp = FastAPI()\n\n@app.get(\"/files/{file_id}\")\nasync def download_file(\n    file_id: UUID,\n    current_user: User = deps.current_user\n):\n    # Get file with access control\n    file_content = await file_service.get_file(\n        file_id=file_id,\n        requesting_user_id=current_user.id\n    )\n\n    # Stream response\n    return StreamingResponse(\n        io.BytesIO(file_content.content),\n        media_type=file_content.metadata.content_type,\n        headers={\n            \"Content-Disposition\": f'attachment; filename=\"{file_content.metadata.filename}\"'\n        }\n    )\n</code></pre>"},{"location":"ports/llm/","title":"LLM Port","text":""},{"location":"ports/llm/#overview","title":"Overview","text":"<p>The LLM Port defines the contract for Large Language Model chat completion operations, conversation management, and prompt template integration in Portico applications.</p> <p>Purpose: Abstract LLM provider operations to enable pluggable LLM backends (OpenAI, Anthropic, local models) with consistent conversation storage and prompt template management.</p> <p>Domain: Large Language Model integration, chat completions, conversation management, prompt engineering</p> <p>Key Capabilities:</p> <ul> <li>Chat completion with streaming support</li> <li>Multiple LLM provider support (OpenAI, Anthropic)</li> <li>Conversation thread storage and retrieval</li> <li>User ownership and access control for conversations</li> <li>Template-based prompt management (via Template Port)</li> <li>Conversation variable tracking and reproduction</li> <li>Message history management</li> <li>Token usage tracking</li> <li>RAG context injection</li> </ul> <p>Port Type: Adapter + Repository (multi-interface)</p> <p>When to Use:</p> <ul> <li>Chat applications with LLM integration</li> <li>AI assistants and chatbots</li> <li>Template-based prompt management systems</li> <li>Multi-user conversation platforms</li> <li>RAG (Retrieval-Augmented Generation) applications</li> <li>Applications requiring conversation history</li> <li>Prompt engineering and experimentation tools</li> </ul>"},{"location":"ports/llm/#domain-models","title":"Domain Models","text":""},{"location":"ports/llm/#message","title":"Message","text":"<p>A single message in a conversation. Immutable.</p> Field Type Required Default Description <code>role</code> <code>MessageRole</code> Yes - Message role (SYSTEM, USER, or ASSISTANT) <code>content</code> <code>str</code> Yes - Message text content <p>Example:</p> <pre><code>from portico.ports.llm import Message, MessageRole\n\n# System message\nsystem_msg = Message(\n    role=MessageRole.SYSTEM,\n    content=\"You are a helpful assistant specialized in Python programming.\"\n)\n\n# User message\nuser_msg = Message(\n    role=MessageRole.USER,\n    content=\"How do I read a CSV file in Python?\"\n)\n\n# Assistant message\nassistant_msg = Message(\n    role=MessageRole.ASSISTANT,\n    content=\"You can use the csv module or pandas library...\"\n)\n</code></pre>"},{"location":"ports/llm/#chatcompletionrequest","title":"ChatCompletionRequest","text":"<p>Request for chat completion with configuration parameters. Immutable.</p> Field Type Required Default Description <code>messages</code> <code>List[Message]</code> Yes - Conversation messages <code>model</code> <code>Optional[str]</code> No <code>None</code> Model name override (provider default if None) <code>temperature</code> <code>Optional[float]</code> No <code>None</code> Sampling temperature (0.0-2.0) <code>max_tokens</code> <code>Optional[int]</code> No <code>None</code> Maximum tokens to generate <code>top_p</code> <code>Optional[float]</code> No <code>None</code> Nucleus sampling (0.0-1.0) <code>frequency_penalty</code> <code>Optional[float]</code> No <code>None</code> Frequency penalty (-2.0 to 2.0) <code>presence_penalty</code> <code>Optional[float]</code> No <code>None</code> Presence penalty (-2.0 to 2.0) <code>stop</code> <code>Optional[str \\| List[str]]</code> No <code>None</code> Stop sequences <code>stream</code> <code>bool</code> No <code>False</code> Whether to stream response <code>rag_context</code> <code>Optional[str]</code> No <code>None</code> RAG context to inject (OpenAI only) <p>Example:</p> <pre><code>from portico.ports.llm import ChatCompletionRequest, Message, MessageRole\n\nrequest = ChatCompletionRequest(\n    messages=[\n        Message(role=MessageRole.SYSTEM, content=\"You are a helpful assistant.\"),\n        Message(role=MessageRole.USER, content=\"What is Python?\")\n    ],\n    model=\"gpt-4\",\n    temperature=0.7,\n    max_tokens=500\n)\n\nresponse = await chat_provider.complete(request)\n</code></pre>"},{"location":"ports/llm/#chatcompletionresponse","title":"ChatCompletionResponse","text":"<p>Response from chat completion. Immutable.</p> Field Type Required Default Description <code>id</code> <code>str</code> Yes - Unique response identifier <code>model</code> <code>str</code> Yes - Model used for generation <code>message</code> <code>Message</code> Yes - Generated assistant message <code>usage</code> <code>Optional[Usage]</code> No <code>None</code> Token usage statistics <code>created_at</code> <code>datetime</code> No Current UTC time Response timestamp <p>Example:</p> <pre><code>response = await chat_provider.complete(request)\n\nprint(f\"Response: {response.message.content}\")\nprint(f\"Model: {response.model}\")\nif response.usage:\n    print(f\"Tokens used: {response.usage.total_tokens}\")\n</code></pre>"},{"location":"ports/llm/#usage","title":"Usage","text":"<p>Token usage information for cost tracking. Immutable.</p> Field Type Required Default Description <code>prompt_tokens</code> <code>int</code> Yes - Tokens in input prompt <code>completion_tokens</code> <code>int</code> Yes - Tokens in generated response <code>total_tokens</code> <code>int</code> Yes - Total tokens consumed"},{"location":"ports/llm/#conversation","title":"Conversation","text":"<p>A conversation thread with user ownership and template integration. Immutable.</p> Field Type Required Default Description <code>id</code> <code>UUID</code> No <code>uuid4()</code> Unique conversation identifier <code>title</code> <code>str</code> Yes - Conversation title <code>user_id</code> <code>Optional[UUID]</code> No <code>None</code> Owner user ID (None = system) <code>is_public</code> <code>bool</code> No <code>False</code> Public visibility <code>prompt_id</code> <code>Optional[UUID]</code> No <code>None</code> Template used to start conversation <code>template_version_id</code> <code>Optional[UUID]</code> No <code>None</code> Template version used <code>system_prompt</code> <code>Optional[str]</code> No <code>None</code> Rendered system prompt <code>variable_values</code> <code>Optional[Dict[str, str]]</code> No <code>None</code> Variables used in rendering <code>messages</code> <code>List[Message]</code> No <code>[]</code> Conversation messages (loaded separately) <code>message_count</code> <code>int</code> No <code>0</code> Cached message count <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp <code>updated_at</code> <code>datetime</code> No Current UTC time Last update timestamp <p>Methods:</p> <ul> <li><code>is_owned_by(user_id: UUID) -&gt; bool</code> - Check if conversation is owned by user</li> <li><code>is_accessible_by(user_id: Optional[UUID]) -&gt; bool</code> - Check if conversation is accessible (public, owned, or system)</li> <li><code>was_created_from_template() -&gt; bool</code> - Check if conversation has associated template</li> <li><code>can_reproduce() -&gt; bool</code> - Check if conversation can be reproduced (has template + variables)</li> </ul> <p>Example:</p> <pre><code>from portico.ports.llm import Conversation, Message, MessageRole\n\nconversation = Conversation(\n    title=\"Python Help Session\",\n    user_id=user_id,\n    is_public=False,\n    prompt_id=template_id,\n    system_prompt=\"You are a Python expert assistant.\",\n    variable_values={\"expertise\": \"Python\"},\n    messages=[\n        Message(role=MessageRole.SYSTEM, content=\"You are a Python expert.\"),\n        Message(role=MessageRole.USER, content=\"How do I install packages?\")\n    ]\n)\n\n# Check if reproducible\nif conversation.can_reproduce():\n    print(\"This conversation can be reproduced from the template\")\n</code></pre>"},{"location":"ports/llm/#createconversationrequest","title":"CreateConversationRequest","text":"<p>Request for creating a new conversation.</p> Field Type Required Default Description <code>title</code> <code>str</code> Yes - Conversation title <code>user_id</code> <code>Optional[UUID]</code> No <code>None</code> Owner user ID <code>is_public</code> <code>bool</code> No <code>False</code> Public visibility <code>prompt_id</code> <code>Optional[UUID]</code> No <code>None</code> Template ID for template-based conversation <code>template_version_id</code> <code>Optional[UUID]</code> No <code>None</code> Template version ID <code>system_prompt</code> <code>Optional[str]</code> No <code>None</code> Rendered system prompt <code>variable_values</code> <code>Optional[Dict[str, str]]</code> No <code>None</code> Variable values used <code>initial_message</code> <code>Optional[str]</code> No <code>None</code> First user message <p>Example:</p> <pre><code>from portico.ports.llm import CreateConversationRequest\n\nrequest = CreateConversationRequest(\n    title=\"Code Review Session\",\n    user_id=current_user_id,\n    prompt_id=code_review_template_id,\n    variable_values={\"language\": \"Python\", \"focus\": \"best practices\"},\n    initial_message=\"Please review this code: ...\"\n)\n\nconversation = await conversation_repo.create(request)\n</code></pre>"},{"location":"ports/llm/#updateconversationrequest","title":"UpdateConversationRequest","text":"<p>Request for updating conversation metadata. All fields optional.</p> Field Type Required Default Description <code>title</code> <code>Optional[str]</code> No <code>None</code> New title <code>is_public</code> <code>Optional[bool]</code> No <code>None</code> New public status"},{"location":"ports/llm/#variabledefinition","title":"VariableDefinition","text":"<p>Definition of a variable for prompt templates. Immutable.</p> Field Type Required Default Description <code>id</code> <code>UUID</code> No <code>uuid4()</code> Unique identifier <code>name</code> <code>str</code> Yes - Variable name <code>description</code> <code>Optional[str]</code> No <code>None</code> Variable description <code>variable_type</code> <code>VariableType</code> No <code>TEXT</code> Variable type (TEXT, NUMBER, BOOLEAN, SELECT) <code>default_value</code> <code>Optional[str]</code> No <code>None</code> Default value <code>options</code> <code>List[str]</code> No <code>[]</code> Options for SELECT type <code>is_required</code> <code>bool</code> No <code>True</code> Whether variable is required <code>validation_pattern</code> <code>Optional[str]</code> No <code>None</code> Regex validation pattern <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp <code>updated_at</code> <code>datetime</code> No Current UTC time Update timestamp <p>Example:</p> <pre><code>from portico.ports.llm import VariableDefinition, VariableType\n\n# Text variable\nvar_def = VariableDefinition(\n    name=\"language\",\n    description=\"Programming language for code examples\",\n    variable_type=VariableType.TEXT,\n    is_required=True\n)\n\n# Select variable with options\ntone_var = VariableDefinition(\n    name=\"tone\",\n    description=\"Conversation tone\",\n    variable_type=VariableType.SELECT,\n    options=[\"professional\", \"casual\", \"friendly\"],\n    default_value=\"professional\"\n)\n</code></pre>"},{"location":"ports/llm/#conversationvariable","title":"ConversationVariable","text":"<p>A variable value associated with a conversation. Immutable.</p> Field Type Required Default Description <code>id</code> <code>UUID</code> No <code>uuid4()</code> Unique identifier <code>conversation_id</code> <code>UUID</code> Yes - Associated conversation ID <code>variable_name</code> <code>str</code> Yes - Variable name <code>variable_value</code> <code>str</code> Yes - Variable value <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp"},{"location":"ports/llm/#enumerations","title":"Enumerations","text":""},{"location":"ports/llm/#messagerole","title":"MessageRole","text":"<p>Valid roles for chat messages.</p> Value Description <code>SYSTEM</code> System instruction message <code>USER</code> User input message <code>ASSISTANT</code> AI-generated response message <p>Example:</p> <pre><code>from portico.ports.llm import MessageRole\n\n# Use enum for type safety\nMessage(role=MessageRole.SYSTEM, content=\"You are helpful.\")\nMessage(role=MessageRole.USER, content=\"Hello!\")\nMessage(role=MessageRole.ASSISTANT, content=\"Hi there!\")\n</code></pre>"},{"location":"ports/llm/#variabletype","title":"VariableType","text":"<p>Valid types for prompt variables.</p> Value Description <code>TEXT</code> Free-form text input <code>NUMBER</code> Numeric input <code>BOOLEAN</code> True/false value <code>SELECT</code> Selection from predefined options"},{"location":"ports/llm/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/llm/#chatcompletionprovider","title":"ChatCompletionProvider","text":"<p>The <code>ChatCompletionProvider</code> abstract base class defines the contract for LLM chat completion operations.</p> <p>Location: <code>portico.ports.llm.ChatCompletionProvider</code></p>"},{"location":"ports/llm/#key-methods","title":"Key Methods","text":""},{"location":"ports/llm/#complete","title":"complete","text":"<pre><code>async def complete(request: ChatCompletionRequest) -&gt; ChatCompletionResponse\n</code></pre> <p>Generate a chat completion. Primary method for LLM interactions.</p> <p>Parameters:</p> <ul> <li><code>request</code>: Chat completion request with messages and configuration</li> </ul> <p>Returns: ChatCompletionResponse containing generated message and usage stats.</p> <p>Example:</p> <pre><code>from portico.ports.llm import ChatCompletionRequest, Message, MessageRole\n\n# Simple completion\nrequest = ChatCompletionRequest(\n    messages=[\n        Message(role=MessageRole.SYSTEM, content=\"You are a helpful coding assistant.\"),\n        Message(role=MessageRole.USER, content=\"Write a Python function to reverse a string.\")\n    ],\n    model=\"gpt-4\",\n    temperature=0.7,\n    max_tokens=200\n)\n\nresponse = await chat_provider.complete(request)\nprint(response.message.content)\n\n# Multi-turn conversation\nmessages = [\n    Message(role=MessageRole.SYSTEM, content=\"You are a math tutor.\"),\n    Message(role=MessageRole.USER, content=\"What is 5 + 3?\"),\n    Message(role=MessageRole.ASSISTANT, content=\"5 + 3 equals 8.\"),\n    Message(role=MessageRole.USER, content=\"What about 8 * 2?\")\n]\n\nrequest = ChatCompletionRequest(messages=messages, temperature=0.3)\nresponse = await chat_provider.complete(request)\n</code></pre>"},{"location":"ports/llm/#list_models","title":"list_models","text":"<pre><code>async def list_models() -&gt; List[str]\n</code></pre> <p>List available models from the provider. Returns list of model names.</p> <p>Example:</p> <pre><code>models = await chat_provider.list_models()\nprint(f\"Available models: {models}\")\n# ['gpt-3.5-turbo', 'gpt-4', 'gpt-4-turbo-preview']\n</code></pre>"},{"location":"ports/llm/#conversationrepository","title":"ConversationRepository","text":"<p>The <code>ConversationRepository</code> abstract base class defines the contract for conversation storage and retrieval.</p> <p>Location: <code>portico.ports.llm.ConversationRepository</code></p>"},{"location":"ports/llm/#key-methods_1","title":"Key Methods","text":""},{"location":"ports/llm/#create","title":"create","text":"<pre><code>async def create(conversation_data: CreateConversationRequest) -&gt; Conversation\n</code></pre> <p>Create a new conversation. Primary method for starting conversations.</p> <p>Parameters:</p> <ul> <li><code>conversation_data</code>: Request with conversation creation data</li> </ul> <p>Returns: Created Conversation object.</p> <p>Example:</p> <pre><code>from portico.ports.llm import CreateConversationRequest\n\n# Simple conversation\nrequest = CreateConversationRequest(\n    title=\"Python Q&amp;A\",\n    user_id=current_user_id\n)\nconversation = await conversation_repo.create(request)\n\n# Template-based conversation\nrequest = CreateConversationRequest(\n    title=\"Code Review: auth.py\",\n    user_id=current_user_id,\n    prompt_id=code_review_template_id,\n    system_prompt=\"You are an expert Python code reviewer focusing on security.\",\n    variable_values={\"language\": \"Python\", \"focus\": \"security\"}\n)\nconversation = await conversation_repo.create(request)\n</code></pre>"},{"location":"ports/llm/#add_message","title":"add_message","text":"<pre><code>async def add_message(conversation_id: UUID, message: Message) -&gt; Optional[Conversation]\n</code></pre> <p>Add a message to a conversation. Primary method for conversation interaction.</p> <p>Parameters:</p> <ul> <li><code>conversation_id</code>: Conversation identifier</li> <li><code>message</code>: Message to add</li> </ul> <p>Returns: Updated Conversation object if found, None otherwise.</p> <p>Example:</p> <pre><code>from portico.ports.llm import Message, MessageRole\n\n# Add user message\nuser_message = Message(\n    role=MessageRole.USER,\n    content=\"How do I handle exceptions in Python?\"\n)\nupdated = await conversation_repo.add_message(conversation_id, user_message)\n\n# Add assistant response\nassistant_message = Message(\n    role=MessageRole.ASSISTANT,\n    content=\"In Python, you use try-except blocks...\"\n)\nupdated = await conversation_repo.add_message(conversation_id, assistant_message)\n</code></pre>"},{"location":"ports/llm/#other-methods","title":"Other Methods","text":""},{"location":"ports/llm/#get_by_id","title":"get_by_id","text":"<pre><code>async def get_by_id(conversation_id: UUID, user_id: Optional[UUID] = None) -&gt; Optional[Conversation]\n</code></pre> <p>Retrieve a conversation by ID with access control. Returns Conversation if found and accessible, None otherwise.</p>"},{"location":"ports/llm/#update","title":"update","text":"<pre><code>async def update(\n    conversation_id: UUID,\n    update_data: UpdateConversationRequest,\n    user_id: Optional[UUID] = None\n) -&gt; Optional[Conversation]\n</code></pre> <p>Update conversation metadata. Verifies ownership if user_id provided. Returns updated Conversation or None.</p>"},{"location":"ports/llm/#delete","title":"delete","text":"<pre><code>async def delete(conversation_id: UUID, user_id: Optional[UUID] = None) -&gt; bool\n</code></pre> <p>Delete a conversation. Verifies ownership if user_id provided. Returns True if deleted, False if not found.</p>"},{"location":"ports/llm/#list_conversations","title":"list_conversations","text":"<pre><code>async def list_conversations(\n    user_id: Optional[UUID] = None,\n    include_public: bool = True,\n    prompt_id: Optional[UUID] = None,\n    limit: int = 100,\n    offset: int = 0\n) -&gt; List[Conversation]\n</code></pre> <p>List conversations with filtering and pagination. Returns user's conversations + public + system if user_id provided.</p>"},{"location":"ports/llm/#get_messages","title":"get_messages","text":"<pre><code>async def get_messages(conversation_id: UUID, limit: int = 100, offset: int = 0) -&gt; List[Message]\n</code></pre> <p>Get messages from a conversation with pagination. Returns list of Message objects.</p>"},{"location":"ports/llm/#increment_message_count","title":"increment_message_count","text":"<pre><code>async def increment_message_count(conversation_id: UUID, increment: int = 1) -&gt; None\n</code></pre> <p>Increment the message count for a conversation. Used for caching message counts.</p>"},{"location":"ports/llm/#variablerepository","title":"VariableRepository","text":"<p>The <code>VariableRepository</code> abstract base class defines the contract for prompt variable management.</p> <p>Location: <code>portico.ports.llm.VariableRepository</code></p>"},{"location":"ports/llm/#key-methods_2","title":"Key Methods","text":""},{"location":"ports/llm/#create_definition","title":"create_definition","text":"<pre><code>async def create_definition(definition_data: CreateVariableDefinitionRequest) -&gt; VariableDefinition\n</code></pre> <p>Create a new variable definition. Returns created VariableDefinition.</p>"},{"location":"ports/llm/#set_conversation_variables","title":"set_conversation_variables","text":"<pre><code>async def set_conversation_variables(conversation_id: UUID, variables: Dict[str, str]) -&gt; List[ConversationVariable]\n</code></pre> <p>Set variable values for a conversation. Returns list of ConversationVariable objects.</p>"},{"location":"ports/llm/#other-methods_1","title":"Other Methods","text":""},{"location":"ports/llm/#get_definition_by_name","title":"get_definition_by_name","text":"<pre><code>async def get_definition_by_name(name: str) -&gt; Optional[VariableDefinition]\n</code></pre> <p>Retrieve a variable definition by name. Returns VariableDefinition or None.</p>"},{"location":"ports/llm/#list_definitions","title":"list_definitions","text":"<pre><code>async def list_definitions(limit: int = 100, offset: int = 0) -&gt; List[VariableDefinition]\n</code></pre> <p>List variable definitions with pagination.</p>"},{"location":"ports/llm/#get_conversation_variables","title":"get_conversation_variables","text":"<pre><code>async def get_conversation_variables(conversation_id: UUID) -&gt; Dict[str, str]\n</code></pre> <p>Get variable values for a conversation. Returns dictionary mapping variable names to values.</p>"},{"location":"ports/llm/#delete_conversation_variables","title":"delete_conversation_variables","text":"<pre><code>async def delete_conversation_variables(conversation_id: UUID) -&gt; bool\n</code></pre> <p>Delete all variable values for a conversation. Returns True if deleted, False if none found.</p>"},{"location":"ports/llm/#helper-functions","title":"Helper Functions","text":""},{"location":"ports/llm/#create_prompt_request","title":"create_prompt_request","text":"<pre><code>def create_prompt_request(\n    name: str,\n    template: str,\n    description: Optional[str] = None,\n    variables: Optional[List[str]] = None,\n    default_model: Optional[str] = None,\n    default_temperature: Optional[float] = None,\n    default_max_tokens: Optional[int] = None,\n    tags: Optional[List[str]] = None\n) -&gt; CreateTemplateRequest\n</code></pre> <p>Helper to create LLM prompt templates with proper metadata. Returns CreateTemplateRequest configured for LLM prompts.</p> <p>Example:</p> <pre><code>from portico.ports.llm import create_prompt_request\n\nrequest = create_prompt_request(\n    name=\"code_explainer\",\n    template=\"Explain this {{ language }} code:\\n\\n{{ code }}\",\n    description=\"Code explanation assistant\",\n    variables=[\"language\", \"code\"],\n    default_model=\"gpt-4\",\n    default_temperature=0.3,\n    default_max_tokens=1000,\n    tags=[\"code\", \"education\"]\n)\n\ntemplate = await template_registry.create(request)\n</code></pre>"},{"location":"ports/llm/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/llm/#multi-turn-chat-conversation","title":"Multi-Turn Chat Conversation","text":"<pre><code>from portico.ports.llm import (\n    ChatCompletionProvider,\n    ConversationRepository,\n    Message,\n    MessageRole,\n    ChatCompletionRequest,\n    CreateConversationRequest\n)\n\nasync def chat_session(\n    chat_provider: ChatCompletionProvider,\n    conversation_repo: ConversationRepository,\n    user_id: UUID\n):\n    \"\"\"Interactive multi-turn chat session.\"\"\"\n\n    # Create conversation\n    conversation = await conversation_repo.create(\n        CreateConversationRequest(\n            title=\"Python Help\",\n            user_id=user_id\n        )\n    )\n\n    # Add system message\n    system_msg = Message(\n        role=MessageRole.SYSTEM,\n        content=\"You are a helpful Python programming assistant.\"\n    )\n    await conversation_repo.add_message(conversation.id, system_msg)\n\n    # Chat loop\n    while True:\n        user_input = input(\"You: \")\n        if user_input.lower() == \"quit\":\n            break\n\n        # Add user message\n        user_msg = Message(role=MessageRole.USER, content=user_input)\n        await conversation_repo.add_message(conversation.id, user_msg)\n\n        # Get all messages for context\n        messages = await conversation_repo.get_messages(conversation.id)\n\n        # Generate response\n        request = ChatCompletionRequest(\n            messages=messages,\n            model=\"gpt-4\",\n            temperature=0.7\n        )\n        response = await chat_provider.complete(request)\n\n        # Add assistant response\n        await conversation_repo.add_message(conversation.id, response.message)\n\n        print(f\"Assistant: {response.message.content}\\n\")\n</code></pre>"},{"location":"ports/llm/#template-based-conversation-with-rag","title":"Template-Based Conversation with RAG","text":"<pre><code>from portico.ports.llm import create_prompt_request\nfrom portico.ports.template import TemplateRegistry\nfrom portico.adapters.template import Jinja2TemplateRenderer\n\nasync def create_rag_conversation(\n    template_registry: TemplateRegistry,\n    template_renderer: Jinja2TemplateRenderer,\n    conversation_repo: ConversationRepository,\n    chat_provider: ChatCompletionProvider,\n    user_query: str,\n    rag_context: str,\n    user_id: UUID\n):\n    \"\"\"Create conversation using template with RAG context.\"\"\"\n\n    # Create prompt template\n    prompt_request = create_prompt_request(\n        name=\"rag_assistant\",\n        template=\"\"\"You are a helpful assistant. Use the following context to answer questions accurately.\n\nContext:\n&lt;function define_env.&lt;locals&gt;.context at 0x7fdb048b37e0&gt;\n\nAnswer the user's question based on the context above.\"\"\",\n        variables=[\"context\"],\n        default_model=\"gpt-4\",\n        default_temperature=0.3\n    )\n    template = await template_registry.create(prompt_request)\n\n    # Render system prompt\n    system_prompt = template_renderer.render(\n        template.content,\n        {\"context\": rag_context}\n    )\n\n    # Create conversation\n    conversation = await conversation_repo.create(\n        CreateConversationRequest(\n            title=\"RAG Q&amp;A\",\n            user_id=user_id,\n            prompt_id=template.id,\n            system_prompt=system_prompt,\n            variable_values={\"context\": rag_context[:100] + \"...\"}  # Truncate for storage\n        )\n    )\n\n    # Add messages\n    await conversation_repo.add_message(\n        conversation.id,\n        Message(role=MessageRole.SYSTEM, content=system_prompt)\n    )\n    await conversation_repo.add_message(\n        conversation.id,\n        Message(role=MessageRole.USER, content=user_query)\n    )\n\n    # Generate response\n    messages = await conversation_repo.get_messages(conversation.id)\n    response = await chat_provider.complete(\n        ChatCompletionRequest(messages=messages, model=\"gpt-4\")\n    )\n\n    await conversation_repo.add_message(conversation.id, response.message)\n\n    return conversation, response.message.content\n</code></pre>"},{"location":"ports/llm/#integration-with-kits","title":"Integration with Kits","text":"<p>The LLM Port is used by the LLM Kit to provide high-level chat completion and conversation management services.</p> <pre><code>from portico import compose\n\n# Configure LLM kit with OpenAI\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[\n        compose.llm(\n            provider=\"openai\",\n            api_key=\"sk-...\",\n            default_model=\"gpt-4\"\n        )\n    ]\n)\n\nawait app.initialize()\n\n# Access LLM service\nllm_service = app.kits[\"llm\"].service\n\n# Simple completion\nresponse = await llm_service.complete_simple(\n    content=\"What is Python?\",\n    system_message=\"You are a programming expert.\",\n    temperature=0.7\n)\nprint(response)\n\n# Chat with messages\nfrom portico.ports.llm import Message, MessageRole\n\nmessages = [\n    Message(role=MessageRole.SYSTEM, content=\"You are helpful.\"),\n    Message(role=MessageRole.USER, content=\"Hello!\")\n]\nresponse = await llm_service.complete_from_messages(messages)\nprint(response.message.content)\n\n# Use stored prompt template\nresponse = await llm_service.complete_from_prompt(\n    prompt_name_or_id=\"code_explainer\",\n    variables={\"language\": \"Python\", \"code\": \"def hello(): pass\"}\n)\n</code></pre> <p>The LLM Kit provides:</p> <ul> <li>OpenAI and Anthropic provider adapters</li> <li>Conversation storage with SQLAlchemy</li> <li>Template integration for prompt management</li> <li>Token usage tracking</li> <li>Streaming support (provider-dependent)</li> </ul> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/llm/#best-practices","title":"Best Practices","text":"<ol> <li>Use System Messages for Instructions: Set behavior with system messages, not user messages</li> </ol> <pre><code># \u2705 GOOD: System message for instructions\nmessages = [\n    Message(role=MessageRole.SYSTEM, content=\"You are a helpful Python tutor.\"),\n    Message(role=MessageRole.USER, content=\"How do I use list comprehensions?\")\n]\n\n# \u274c BAD: Instructions in user message\nmessages = [\n    Message(role=MessageRole.USER, content=\"Act as a Python tutor. How do I use list comprehensions?\")\n]\n</code></pre> <ol> <li>Track Conversations for Context: Use ConversationRepository to maintain multi-turn context</li> </ol> <pre><code># \u2705 GOOD: Load full conversation history\nmessages = await conversation_repo.get_messages(conversation_id)\nresponse = await chat_provider.complete(ChatCompletionRequest(messages=messages))\n\n# \u274c BAD: No context (each message independent)\nresponse = await chat_provider.complete(\n    ChatCompletionRequest(messages=[Message(role=MessageRole.USER, content=user_input)])\n)\n</code></pre> <ol> <li>Set Temperature Based on Use Case: Lower for factual, higher for creative</li> </ol> <pre><code># \u2705 GOOD: Match temperature to task\n# Factual question answering\nrequest = ChatCompletionRequest(messages=messages, temperature=0.3)\n\n# Creative writing\nrequest = ChatCompletionRequest(messages=messages, temperature=0.9)\n\n# \u274c BAD: High temperature for factual tasks\nrequest = ChatCompletionRequest(messages=messages, temperature=1.5)\n# Will produce inconsistent/creative answers\n</code></pre> <ol> <li>Use Templates for Reusable Prompts: Store prompts as templates for consistency</li> </ol> <pre><code># \u2705 GOOD: Reusable template\ntemplate = create_prompt_request(\n    name=\"code_reviewer\",\n    template=\"Review this {{ language }} code for best practices:\\n\\n{{ code }}\",\n    variables=[\"language\", \"code\"]\n)\nawait template_registry.create(template)\n\n# Use many times\nresponse = await llm_service.complete_from_prompt(\n    \"code_reviewer\",\n    variables={\"language\": \"Python\", \"code\": code_snippet}\n)\n\n# \u274c BAD: Hardcoded prompts everywhere\nprompt = f\"Review this {language} code: {code}\"  # Inconsistent\n</code></pre> <ol> <li>Monitor Token Usage for Cost Control: Track usage to manage API costs</li> </ol> <pre><code># \u2705 GOOD: Track and log usage\nresponse = await chat_provider.complete(request)\n\nif response.usage:\n    logger.info(\n        \"llm_completion\",\n        model=response.model,\n        prompt_tokens=response.usage.prompt_tokens,\n        completion_tokens=response.usage.completion_tokens,\n        total_tokens=response.usage.total_tokens\n    )\n\n    # Alert if high usage\n    if response.usage.total_tokens &gt; 10000:\n        logger.warning(\"high_token_usage\", tokens=response.usage.total_tokens)\n\n# \u274c BAD: Ignore usage\n# Can lead to unexpected costs\n</code></pre>"},{"location":"ports/llm/#faqs","title":"FAQs","text":""},{"location":"ports/llm/#what-llm-providers-are-supported","title":"What LLM providers are supported?","text":"<p>Portico includes adapters for:</p> <ul> <li>OpenAI - GPT-3.5, GPT-4, GPT-4 Turbo models</li> <li>Anthropic - Claude 3 models (Haiku, Sonnet, Opus)</li> </ul> <p>You can implement custom providers by extending <code>ChatCompletionProvider</code>.</p>"},{"location":"ports/llm/#how-do-i-handle-streaming-responses","title":"How do I handle streaming responses?","text":"<p>Set <code>stream=True</code> in <code>ChatCompletionRequest</code>:</p> <pre><code>request = ChatCompletionRequest(\n    messages=messages,\n    stream=True\n)\n\n# Streaming implementation is provider-specific\n# Check provider adapter documentation\n</code></pre> <p>Note: Streaming support varies by provider adapter.</p>"},{"location":"ports/llm/#can-i-use-different-models-in-the-same-conversation","title":"Can I use different models in the same conversation?","text":"<p>Yes, but it's generally not recommended. Model switching can cause inconsistencies in conversation style and capabilities. If needed:</p> <pre><code># Different models for different turns\nrequest1 = ChatCompletionRequest(messages=messages, model=\"gpt-3.5-turbo\")\nresponse1 = await chat_provider.complete(request1)\n\nmessages.append(response1.message)\nrequest2 = ChatCompletionRequest(messages=messages, model=\"gpt-4\")\nresponse2 = await chat_provider.complete(request2)\n</code></pre>"},{"location":"ports/llm/#how-do-i-inject-rag-context-into-conversations","title":"How do I inject RAG context into conversations?","text":"<p>Use the <code>rag_context</code> parameter (OpenAI only):</p> <pre><code>request = ChatCompletionRequest(\n    messages=[Message(role=MessageRole.USER, content=\"What is Portico?\")],\n    rag_context=\"Portico is a Python framework for building GPT-powered applications...\",\n    model=\"gpt-4\"\n)\n\nresponse = await chat_provider.complete(request)\n</code></pre> <p>For Anthropic, manually add context to the system message.</p>"},{"location":"ports/llm/#how-do-i-implement-a-custom-llm-provider","title":"How do I implement a custom LLM provider?","text":"<p>Implement the <code>ChatCompletionProvider</code> interface:</p> <pre><code>from portico.ports.llm import (\n    ChatCompletionProvider,\n    ChatCompletionRequest,\n    ChatCompletionResponse,\n    Message,\n    MessageRole,\n    Usage\n)\n\nclass CustomLLMProvider(ChatCompletionProvider):\n    async def complete(self, request: ChatCompletionRequest) -&gt; ChatCompletionResponse:\n        # Call your LLM API\n        api_response = await your_llm_api.chat(\n            messages=[{\"role\": m.role.value, \"content\": m.content} for m in request.messages],\n            model=request.model or \"default-model\",\n            temperature=request.temperature\n        )\n\n        # Return ChatCompletionResponse\n        return ChatCompletionResponse(\n            id=api_response[\"id\"],\n            model=api_response[\"model\"],\n            message=Message(\n                role=MessageRole.ASSISTANT,\n                content=api_response[\"content\"]\n            ),\n            usage=Usage(\n                prompt_tokens=api_response[\"usage\"][\"prompt_tokens\"],\n                completion_tokens=api_response[\"usage\"][\"completion_tokens\"],\n                total_tokens=api_response[\"usage\"][\"total_tokens\"]\n            )\n        )\n\n    async def list_models(self) -&gt; List[str]:\n        return await your_llm_api.list_models()\n</code></pre> <p>Then use in composition:</p> <pre><code>def llm(**config):\n    from your_module import CustomLLMProvider\n    from portico.kits.llm import LLMKit\n\n    def factory(database, events):\n        provider = CustomLLMProvider(api_key=config[\"api_key\"])\n        return LLMKit.create(database, events, config, completion_provider=provider)\n\n    return factory\n</code></pre>"},{"location":"ports/permissions/","title":"Permissions Port","text":""},{"location":"ports/permissions/#overview","title":"Overview","text":"<p>The Permissions Port defines the contract for role-based access control (RBAC) in Portico applications.</p> <p>Purpose: Abstract permission and role management to enable flexible authorization systems with global and group-scoped permissions.</p> <p>Domain: Authorization, role-based access control, permission management</p> <p>Key Capabilities:</p> <ul> <li>Global and group-scoped permissions</li> <li>Role definition with permission sets</li> <li>User permission checking (global and group contexts)</li> <li>System and custom roles/permissions</li> <li>Permission registration and discovery</li> <li>Category-based permission organization</li> <li>Hierarchical group permission inheritance</li> </ul> <p>Port Type: Repository</p> <p>When to Use:</p> <ul> <li>Applications requiring role-based access control</li> <li>Multi-tenant systems with group-level permissions</li> <li>Systems with hierarchical permission structures</li> <li>Applications needing custom permission definitions</li> <li>Authorization enforcement at API/service boundaries</li> <li>Administrative interfaces with fine-grained access control</li> </ul>"},{"location":"ports/permissions/#domain-models","title":"Domain Models","text":""},{"location":"ports/permissions/#permission","title":"Permission","text":"<p>Permission domain model. Immutable.</p> Field Type Required Default Description <code>name</code> <code>str</code> Yes - Permission name (e.g., \"users.create\", \"files.read\") <code>description</code> <code>str</code> Yes - Human-readable description <code>scope</code> <code>PermissionScope</code> Yes - Permission scope (GLOBAL, GROUP, or PERSONAL) <code>category</code> <code>str</code> Yes - Category for organization (e.g., \"users\", \"files\") <code>is_system_permission</code> <code>bool</code> No <code>False</code> Whether this is a system-defined permission <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp <p>Example:</p> <pre><code>from portico.ports.permissions import Permission, PermissionScope\n\n# Global permission\nperm = Permission(\n    name=\"users.create\",\n    description=\"Create new users\",\n    scope=PermissionScope.GLOBAL,\n    category=\"users\",\n    is_system_permission=True\n)\n\n# Group permission\ngroup_perm = Permission(\n    name=\"documents.edit\",\n    description=\"Edit group documents\",\n    scope=PermissionScope.GROUP,\n    category=\"documents\",\n    is_system_permission=False\n)\n</code></pre>"},{"location":"ports/permissions/#globalrole","title":"GlobalRole","text":"<p>Global role domain model with permissions. Immutable.</p> Field Type Required Default Description <code>name</code> <code>str</code> Yes - Role name (e.g., \"admin\", \"editor\") <code>description</code> <code>str</code> Yes - Human-readable description <code>permissions</code> <code>Set[str]</code> Yes - Set of permission names this role grants <code>is_system_role</code> <code>bool</code> No <code>False</code> Whether this is a system-defined role <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp <p>Example:</p> <pre><code>from portico.ports.permissions import GlobalRole\n\nadmin_role = GlobalRole(\n    name=\"admin\",\n    description=\"System administrator with full access\",\n    permissions={\n        \"users.create\",\n        \"users.read\",\n        \"users.update\",\n        \"users.delete\",\n        \"roles.manage\"\n    },\n    is_system_role=True\n)\n\neditor_role = GlobalRole(\n    name=\"editor\",\n    description=\"Content editor\",\n    permissions={\"content.create\", \"content.edit\", \"content.read\"},\n    is_system_role=False\n)\n</code></pre>"},{"location":"ports/permissions/#grouprole","title":"GroupRole","text":"<p>Group role domain model with permissions. Immutable.</p> Field Type Required Default Description <code>name</code> <code>str</code> Yes - Role name (e.g., \"member\", \"admin\") <code>description</code> <code>str</code> Yes - Human-readable description <code>permissions</code> <code>Set[str]</code> Yes - Set of permission names this role grants <code>is_system_role</code> <code>bool</code> No <code>False</code> Whether this is a system-defined role <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp <p>Example:</p> <pre><code>from portico.ports.permissions import GroupRole\n\ngroup_admin = GroupRole(\n    name=\"group_admin\",\n    description=\"Group administrator\",\n    permissions={\n        \"group.manage\",\n        \"group.members.add\",\n        \"group.members.remove\",\n        \"group.documents.delete\"\n    },\n    is_system_role=True\n)\n\ngroup_member = GroupRole(\n    name=\"member\",\n    description=\"Regular group member\",\n    permissions={\"group.documents.read\", \"group.documents.create\"},\n    is_system_role=False\n)\n</code></pre>"},{"location":"ports/permissions/#createpermissionrequest","title":"CreatePermissionRequest","text":"<p>Request for creating a new permission.</p> Field Type Required Default Description <code>name</code> <code>str</code> Yes - Permission name <code>description</code> <code>str</code> Yes - Permission description <code>scope</code> <code>PermissionScope</code> Yes - Permission scope <code>category</code> <code>str</code> Yes - Permission category <p>Example:</p> <pre><code>from portico.ports.permissions import CreatePermissionRequest, PermissionScope\n\nrequest = CreatePermissionRequest(\n    name=\"reports.generate\",\n    description=\"Generate financial reports\",\n    scope=PermissionScope.GLOBAL,\n    category=\"reports\"\n)\n</code></pre>"},{"location":"ports/permissions/#createglobalrolerequest","title":"CreateGlobalRoleRequest","text":"<p>Request for creating a global role.</p> Field Type Required Default Description <code>name</code> <code>str</code> Yes - Role name <code>description</code> <code>str</code> Yes - Role description <code>permissions</code> <code>Set[str]</code> Yes - Permission names to grant <p>Example:</p> <pre><code>from portico.ports.permissions import CreateGlobalRoleRequest\n\nrequest = CreateGlobalRoleRequest(\n    name=\"analyst\",\n    description=\"Data analyst with reporting access\",\n    permissions={\"reports.generate\", \"reports.read\", \"data.read\"}\n)\n</code></pre>"},{"location":"ports/permissions/#creategrouprolerequest","title":"CreateGroupRoleRequest","text":"<p>Request for creating a group role.</p> Field Type Required Default Description <code>name</code> <code>str</code> Yes - Role name <code>description</code> <code>str</code> Yes - Role description <code>permissions</code> <code>Set[str]</code> Yes - Permission names to grant <p>Example:</p> <pre><code>from portico.ports.permissions import CreateGroupRoleRequest\n\nrequest = CreateGroupRoleRequest(\n    name=\"moderator\",\n    description=\"Group moderator\",\n    permissions={\"group.posts.edit\", \"group.posts.delete\", \"group.members.warn\"}\n)\n</code></pre>"},{"location":"ports/permissions/#enumerations","title":"Enumerations","text":""},{"location":"ports/permissions/#permissionscope","title":"PermissionScope","text":"<p>Scope of permissions.</p> Value Description <code>GLOBAL</code> Global system-wide permission <code>GROUP</code> Group/organization-scoped permission <code>PERSONAL</code> Personal/user-scoped permission <p>Example:</p> <pre><code>from portico.ports.permissions import PermissionScope\n\n# Use enum for type safety\nperm = CreatePermissionRequest(\n    name=\"files.upload\",\n    description=\"Upload files\",\n    scope=PermissionScope.GROUP,  # Group-scoped\n    category=\"files\"\n)\n</code></pre>"},{"location":"ports/permissions/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/permissions/#permissionrepository","title":"PermissionRepository","text":"<p>The <code>PermissionRepository</code> abstract base class defines the contract for permission and role operations.</p> <p>Location: <code>portico.ports.permissions.PermissionRepository</code></p>"},{"location":"ports/permissions/#key-methods","title":"Key Methods","text":""},{"location":"ports/permissions/#check_permission","title":"check_permission","text":"<pre><code>async def check_permission(\n    user_id: UUID,\n    permission: str,\n    group_id: Optional[UUID] = None\n) -&gt; bool\n</code></pre> <p>Check if user has permission with optional group context. Primary method for authorization checks.</p> <p>Parameters:</p> <ul> <li><code>user_id</code>: User identifier</li> <li><code>permission</code>: Permission name to check (e.g., \"users.create\")</li> <li><code>group_id</code>: Optional group context for permission check</li> </ul> <p>Returns: True if user has the permission, False otherwise.</p> <p>Example:</p> <pre><code>from portico.ports.permissions import PermissionRepository\n\n# Global permission check\ncan_create_users = await perm_repo.check_permission(\n    user_id=current_user_id,\n    permission=\"users.create\"\n)\n\nif can_create_users:\n    user = await user_service.create_user(request)\nelse:\n    raise AuthorizationError(\"Insufficient permissions\")\n\n# Group permission check\ncan_edit_docs = await perm_repo.check_permission(\n    user_id=current_user_id,\n    permission=\"documents.edit\",\n    group_id=group_id\n)\n\nif can_edit_docs:\n    await update_document(doc_id, content)\n</code></pre>"},{"location":"ports/permissions/#get_user_global_permissions","title":"get_user_global_permissions","text":"<pre><code>async def get_user_global_permissions(user_id: UUID) -&gt; Set[str]\n</code></pre> <p>Get user's global permissions. Primary method for retrieving all permissions.</p> <p>Parameters:</p> <ul> <li><code>user_id</code>: User identifier</li> </ul> <p>Returns: Set of global permission names the user has.</p> <p>Example:</p> <pre><code># Get all global permissions for user\npermissions = await perm_repo.get_user_global_permissions(current_user_id)\n\nprint(f\"User has {len(permissions)} global permissions:\")\nfor perm in sorted(permissions):\n    print(f\"  - {perm}\")\n\n# Check if user has admin permissions\nadmin_perms = {\"users.delete\", \"roles.manage\", \"system.configure\"}\nis_admin = admin_perms.issubset(permissions)\n</code></pre>"},{"location":"ports/permissions/#other-methods","title":"Other Methods","text":""},{"location":"ports/permissions/#get_global_role","title":"get_global_role","text":"<pre><code>async def get_global_role(role_name: str) -&gt; Optional[GlobalRole]\n</code></pre> <p>Get global role by name. Returns GlobalRole if found, None otherwise.</p>"},{"location":"ports/permissions/#get_group_role","title":"get_group_role","text":"<pre><code>async def get_group_role(role_name: str) -&gt; Optional[GroupRole]\n</code></pre> <p>Get group role by name. Returns GroupRole if found, None otherwise.</p>"},{"location":"ports/permissions/#get_permission","title":"get_permission","text":"<pre><code>async def get_permission(permission_name: str) -&gt; Optional[Permission]\n</code></pre> <p>Get permission by name. Returns Permission if found, None otherwise.</p>"},{"location":"ports/permissions/#get_user_group_permissions","title":"get_user_group_permissions","text":"<pre><code>async def get_user_group_permissions(user_id: UUID, group_id: UUID) -&gt; Set[str]\n</code></pre> <p>Get user's permissions within a group hierarchy. Returns set of permission names.</p>"},{"location":"ports/permissions/#register_global_roles","title":"register_global_roles","text":"<pre><code>async def register_global_roles(roles: Dict[str, List[str]]) -&gt; None\n</code></pre> <p>Register custom global roles. Dictionary maps role names to permission lists.</p>"},{"location":"ports/permissions/#register_group_roles","title":"register_group_roles","text":"<pre><code>async def register_group_roles(roles: Dict[str, List[str]]) -&gt; None\n</code></pre> <p>Register custom group roles. Dictionary maps role names to permission lists.</p>"},{"location":"ports/permissions/#register_permissions","title":"register_permissions","text":"<pre><code>async def register_permissions(permissions: List[CreatePermissionRequest]) -&gt; None\n</code></pre> <p>Register custom permissions. Takes list of permission creation requests.</p>"},{"location":"ports/permissions/#has_global_permission","title":"has_global_permission","text":"<pre><code>async def has_global_permission(user_id: UUID, permission: str) -&gt; bool\n</code></pre> <p>Check if user has global permission. Returns True if user has the permission, False otherwise.</p>"},{"location":"ports/permissions/#has_group_permission","title":"has_group_permission","text":"<pre><code>async def has_group_permission(user_id: UUID, permission: str, group_id: UUID) -&gt; bool\n</code></pre> <p>Check if user has permission within group hierarchy. Returns True if user has the permission in the group, False otherwise.</p>"},{"location":"ports/permissions/#list_global_roles","title":"list_global_roles","text":"<pre><code>async def list_global_roles() -&gt; List[GlobalRole]\n</code></pre> <p>List all global roles. Returns list of GlobalRole objects.</p>"},{"location":"ports/permissions/#list_group_roles","title":"list_group_roles","text":"<pre><code>async def list_group_roles() -&gt; List[GroupRole]\n</code></pre> <p>List all group roles. Returns list of GroupRole objects.</p>"},{"location":"ports/permissions/#list_permissions","title":"list_permissions","text":"<pre><code>async def list_permissions(scope: Optional[PermissionScope] = None) -&gt; List[Permission]\n</code></pre> <p>List permissions, optionally filtered by scope. Returns list of Permission objects.</p>"},{"location":"ports/permissions/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/permissions/#role-based-authorization","title":"Role-Based Authorization","text":"<pre><code>from portico.ports.permissions import PermissionRepository, CreateGlobalRoleRequest\nfrom portico.exceptions import AuthorizationError\n\nasync def setup_rbac(perm_repo: PermissionRepository):\n    \"\"\"Initialize roles and permissions.\"\"\"\n\n    # Register permissions\n    from portico.ports.permissions import CreatePermissionRequest, PermissionScope\n\n    permissions = [\n        CreatePermissionRequest(\n            name=\"users.create\",\n            description=\"Create users\",\n            scope=PermissionScope.GLOBAL,\n            category=\"users\"\n        ),\n        CreatePermissionRequest(\n            name=\"users.read\",\n            description=\"View users\",\n            scope=PermissionScope.GLOBAL,\n            category=\"users\"\n        ),\n        CreatePermissionRequest(\n            name=\"users.update\",\n            description=\"Update users\",\n            scope=PermissionScope.GLOBAL,\n            category=\"users\"\n        ),\n        CreatePermissionRequest(\n            name=\"users.delete\",\n            description=\"Delete users\",\n            scope=PermissionScope.GLOBAL,\n            category=\"users\"\n        )\n    ]\n    await perm_repo.register_permissions(permissions)\n\n    # Register roles\n    await perm_repo.register_global_roles({\n        \"admin\": [\"users.create\", \"users.read\", \"users.update\", \"users.delete\"],\n        \"user_manager\": [\"users.create\", \"users.read\", \"users.update\"],\n        \"viewer\": [\"users.read\"]\n    })\n\nasync def require_permission(\n    perm_repo: PermissionRepository,\n    user_id: UUID,\n    permission: str\n):\n    \"\"\"Enforce permission requirement.\"\"\"\n\n    has_permission = await perm_repo.check_permission(user_id, permission)\n\n    if not has_permission:\n        raise AuthorizationError(\n            f\"User {user_id} lacks required permission: {permission}\"\n        )\n\n# Usage in API endpoints\nasync def delete_user_endpoint(user_id: UUID, current_user_id: UUID):\n    # Check permission\n    await require_permission(perm_repo, current_user_id, \"users.delete\")\n\n    # Permission granted, proceed\n    await user_service.delete_user(user_id)\n</code></pre>"},{"location":"ports/permissions/#group-scoped-authorization","title":"Group-Scoped Authorization","text":"<pre><code>from portico.ports.permissions import PermissionRepository\nfrom uuid import UUID\n\nasync def setup_group_permissions(perm_repo: PermissionRepository):\n    \"\"\"Initialize group-scoped permissions and roles.\"\"\"\n\n    # Register group permissions\n    from portico.ports.permissions import CreatePermissionRequest, PermissionScope\n\n    group_permissions = [\n        CreatePermissionRequest(\n            name=\"group.documents.create\",\n            description=\"Create group documents\",\n            scope=PermissionScope.GROUP,\n            category=\"documents\"\n        ),\n        CreatePermissionRequest(\n            name=\"group.documents.edit\",\n            description=\"Edit group documents\",\n            scope=PermissionScope.GROUP,\n            category=\"documents\"\n        ),\n        CreatePermissionRequest(\n            name=\"group.documents.delete\",\n            description=\"Delete group documents\",\n            scope=PermissionScope.GROUP,\n            category=\"documents\"\n        ),\n        CreatePermissionRequest(\n            name=\"group.members.add\",\n            description=\"Add group members\",\n            scope=PermissionScope.GROUP,\n            category=\"members\"\n        )\n    ]\n    await perm_repo.register_permissions(group_permissions)\n\n    # Register group roles\n    await perm_repo.register_group_roles({\n        \"group_admin\": [\n            \"group.documents.create\",\n            \"group.documents.edit\",\n            \"group.documents.delete\",\n            \"group.members.add\"\n        ],\n        \"editor\": [\n            \"group.documents.create\",\n            \"group.documents.edit\"\n        ],\n        \"member\": [\n            \"group.documents.create\"\n        ]\n    })\n\nasync def can_edit_document(\n    perm_repo: PermissionRepository,\n    user_id: UUID,\n    group_id: UUID,\n    document_id: UUID\n) -&gt; bool:\n    \"\"\"Check if user can edit a document in a group.\"\"\"\n\n    # Check group-scoped permission\n    can_edit = await perm_repo.has_group_permission(\n        user_id=user_id,\n        permission=\"group.documents.edit\",\n        group_id=group_id\n    )\n\n    return can_edit\n\n# Usage\nif await can_edit_document(perm_repo, user_id, group_id, doc_id):\n    await update_document(doc_id, new_content)\nelse:\n    raise AuthorizationError(\"Cannot edit this document\")\n</code></pre>"},{"location":"ports/permissions/#integration-with-kits","title":"Integration with Kits","text":"<p>The Permissions Port is used by the RBAC Kit to provide role and permission management services.</p> <pre><code>from portico import compose\n\n# Configure RBAC kit\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[\n        compose.user(),\n        compose.group(),\n        compose.rbac()\n    ]\n)\n\nawait app.initialize()\n\n# Access RBAC service\nrbac_service = app.kits[\"rbac\"].service\n\n# Create permission\nfrom portico.ports.permissions import CreatePermissionRequest, PermissionScope\n\nperm = await rbac_service.create_permission(\n    CreatePermissionRequest(\n        name=\"reports.export\",\n        description=\"Export reports to PDF\",\n        scope=PermissionScope.GLOBAL,\n        category=\"reports\"\n    )\n)\n\n# Create role\nfrom portico.ports.permissions import CreateGlobalRoleRequest\n\nrole = await rbac_service.create_role(\n    CreateGlobalRoleRequest(\n        name=\"analyst\",\n        description=\"Data analyst\",\n        permissions={\"reports.export\", \"reports.view\", \"data.read\"}\n    )\n)\n\n# Assign role to user\nawait rbac_service.assign_role(user_id, role_name=\"analyst\")\n\n# Check permission\ncan_export = await rbac_service.check_permission(\n    user_id=user_id,\n    permission=\"reports.export\"\n)\n\nif can_export:\n    report_pdf = await generate_report_pdf()\n</code></pre> <p>The RBAC Kit provides:</p> <ul> <li>SQLAlchemy-based permission repository</li> <li>User role assignment (global and group-scoped)</li> <li>Permission checking with caching</li> <li>System role/permission initialization</li> <li>Event publishing for role changes</li> </ul> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/permissions/#best-practices","title":"Best Practices","text":"<ol> <li>Use Namespaced Permission Names: Organize permissions by category with dot notation</li> </ol> <pre><code># \u2705 GOOD: Namespaced permissions\npermissions = {\n    \"users.create\",\n    \"users.read\",\n    \"users.update\",\n    \"users.delete\",\n    \"reports.generate\",\n    \"reports.export\"\n}\n\n# \u274c BAD: Flat permission names\npermissions = {\n    \"create_user\",\n    \"read_user\",\n    \"generate_report\"\n}\n# Harder to organize and understand relationships\n</code></pre> <ol> <li>Check Permissions, Not Roles: Authorize based on permissions, not role names</li> </ol> <pre><code># \u2705 GOOD: Permission-based authorization\ncan_delete = await perm_repo.check_permission(user_id, \"users.delete\")\nif can_delete:\n    await delete_user(user_id)\n\n# \u274c BAD: Role-based authorization\nuser_role = await get_user_role(user_id)\nif user_role == \"admin\":  # Brittle - what if multiple roles can delete?\n    await delete_user(user_id)\n</code></pre> <ol> <li>Use Group Permissions for Multi-Tenancy: Scope permissions to groups for isolation</li> </ol> <pre><code># \u2705 GOOD: Group-scoped permissions\ncan_edit = await perm_repo.has_group_permission(\n    user_id=user_id,\n    permission=\"documents.edit\",\n    group_id=group_id\n)\n\n# \u274c BAD: Global permission for group-specific action\ncan_edit = await perm_repo.has_global_permission(user_id, \"documents.edit\")\n# No isolation - user could edit any group's documents!\n</code></pre> <ol> <li>Register Permissions at Startup: Define all permissions during initialization</li> </ol> <pre><code># \u2705 GOOD: Register all permissions at startup\nasync def initialize_permissions(perm_repo: PermissionRepository):\n    permissions = [\n        CreatePermissionRequest(name=\"users.create\", ...),\n        CreatePermissionRequest(name=\"users.read\", ...),\n        # ... all permissions\n    ]\n    await perm_repo.register_permissions(permissions)\n\n# \u274c BAD: Ad-hoc permission creation\n# Create permissions when you discover you need them\n# Leads to inconsistency and missing permissions\n</code></pre> <ol> <li>Use Minimal Permissions for Roles: Grant only necessary permissions (principle of least privilege)</li> </ol> <pre><code># \u2705 GOOD: Minimal permissions\nawait perm_repo.register_global_roles({\n    \"viewer\": [\"users.read\", \"reports.read\"],  # Read-only\n    \"editor\": [\"users.read\", \"reports.read\", \"reports.create\"],\n    \"admin\": [\"users.*\", \"reports.*\", \"system.*\"]  # Full access\n})\n\n# \u274c BAD: Over-permissive roles\nawait perm_repo.register_global_roles({\n    \"viewer\": [\"users.*\", \"reports.*\"],  # Too much access for viewer!\n})\n</code></pre>"},{"location":"ports/permissions/#faqs","title":"FAQs","text":""},{"location":"ports/permissions/#whats-the-difference-between-global-and-group-permissions","title":"What's the difference between global and group permissions?","text":"<ul> <li>Global permissions apply system-wide and are checked without group context</li> <li>Group permissions are scoped to specific groups and require a group_id for checking</li> </ul> <pre><code># Global permission - system-wide\nawait perm_repo.check_permission(user_id, \"users.create\")\n\n# Group permission - within a specific group\nawait perm_repo.check_permission(user_id, \"documents.edit\", group_id=group_id)\n</code></pre> <p>Use global permissions for: System administration, user management, global settings</p> <p>Use group permissions for: Group-specific resources, team collaboration, multi-tenant isolation</p>"},{"location":"ports/permissions/#how-do-i-create-custom-permissions","title":"How do I create custom permissions?","text":"<p>Use <code>register_permissions()</code> to define custom permissions:</p> <pre><code>from portico.ports.permissions import CreatePermissionRequest, PermissionScope\n\ncustom_permissions = [\n    CreatePermissionRequest(\n        name=\"invoices.approve\",\n        description=\"Approve invoices for payment\",\n        scope=PermissionScope.GLOBAL,\n        category=\"invoices\"\n    ),\n    CreatePermissionRequest(\n        name=\"team.budget.view\",\n        description=\"View team budget\",\n        scope=PermissionScope.GROUP,\n        category=\"budget\"\n    )\n]\n\nawait perm_repo.register_permissions(custom_permissions)\n</code></pre>"},{"location":"ports/permissions/#can-a-user-have-multiple-roles","title":"Can a user have multiple roles?","text":"<p>Yes! Users can have multiple global roles and multiple group roles. Permissions are combined:</p> <pre><code># User assigned multiple roles\nawait rbac_service.assign_role(user_id, \"editor\")\nawait rbac_service.assign_role(user_id, \"analyst\")\n\n# User gets union of permissions from both roles\npermissions = await perm_repo.get_user_global_permissions(user_id)\n# Includes permissions from both \"editor\" and \"analyst\" roles\n</code></pre>"},{"location":"ports/permissions/#how-do-group-permissions-inherit","title":"How do group permissions inherit?","text":"<p>Group permissions can inherit from parent groups if your group hierarchy supports it. Implementation depends on the GroupKit configuration:</p> <pre><code># If user has \"documents.edit\" in parent group,\n# they may have it in child groups (depends on GroupKit configuration)\ncan_edit = await perm_repo.has_group_permission(\n    user_id=user_id,\n    permission=\"documents.edit\",\n    group_id=child_group_id\n)\n</code></pre> <p>Check your GroupKit configuration for inheritance rules.</p>"},{"location":"ports/permissions/#how-do-i-implement-a-custom-permission-repository","title":"How do I implement a custom permission repository?","text":"<p>Implement the <code>PermissionRepository</code> interface:</p> <pre><code>from portico.ports.permissions import (\n    PermissionRepository,\n    Permission,\n    GlobalRole,\n    GroupRole,\n    CreatePermissionRequest\n)\n\nclass CustomPermissionRepository(PermissionRepository):\n    async def check_permission(\n        self,\n        user_id: UUID,\n        permission: str,\n        group_id: Optional[UUID] = None\n    ) -&gt; bool:\n        # Your authorization logic\n        if group_id:\n            # Check group permission\n            group_perms = await your_db.get_group_permissions(user_id, group_id)\n            return permission in group_perms\n        else:\n            # Check global permission\n            global_perms = await your_db.get_global_permissions(user_id)\n            return permission in global_perms\n\n    async def get_user_global_permissions(self, user_id: UUID) -&gt; Set[str]:\n        # Get all global permissions for user\n        roles = await your_db.get_user_roles(user_id)\n        permissions = set()\n        for role in roles:\n            role_perms = await your_db.get_role_permissions(role.id)\n            permissions.update(role_perms)\n        return permissions\n\n    # Implement all other abstract methods...\n</code></pre> <p>Then use in composition:</p> <pre><code>def rbac(**config):\n    from your_module import CustomPermissionRepository\n    from portico.kits.rbac import RBACKit\n\n    def factory(database, events):\n        perm_repo = CustomPermissionRepository(database)\n        return RBACKit.create(database, events, config, permission_repository=perm_repo)\n\n    return factory\n</code></pre>"},{"location":"ports/session/","title":"Session Port","text":""},{"location":"ports/session/#overview","title":"Overview","text":"<p>The Session Port defines the contract for session storage backends in Portico applications.</p> <p>Purpose: Abstract session storage operations to enable secure, scalable user session management with pluggable storage backends.</p> <p>Domain: Authentication, security, user session management</p> <p>Key Capabilities:</p> <ul> <li>Secure session data storage and retrieval</li> <li>Session expiration and lifecycle management</li> <li>User-based session management and bulk operations</li> <li>Session metadata tracking (IP address, user agent, access times)</li> <li>Automatic expired session cleanup</li> <li>Multi-session support per user</li> </ul> <p>Port Type: Storage</p> <p>When to Use:</p> <ul> <li>Applications requiring stateful user authentication</li> <li>Multi-device session management</li> <li>Systems requiring session revocation capabilities</li> <li>Applications tracking session metadata for security auditing</li> <li>Services requiring granular session lifecycle control</li> </ul>"},{"location":"ports/session/#domain-models","title":"Domain Models","text":""},{"location":"ports/session/#sessiondata","title":"SessionData","text":"<p>Represents session data with metadata for authentication and lifecycle management. Immutable.</p> Field Type Required Default Description <code>id</code> <code>Optional[str]</code> No <code>None</code> Session token/identifier (validated as non-empty) <code>user_id</code> <code>UUID</code> Yes - User who owns this session <code>created_at</code> <code>datetime</code> Yes - When the session was created (UTC) <code>expires_at</code> <code>datetime</code> Yes - When the session expires (UTC) <code>last_accessed</code> <code>datetime</code> Yes - Last access timestamp (UTC) <code>ip_address</code> <code>Optional[str]</code> No <code>None</code> IP address of session creator <code>user_agent</code> <code>Optional[str]</code> No <code>None</code> User agent string from session creation <p>Properties:</p> <ul> <li><code>is_expired -&gt; bool</code> - Returns True if current time exceeds expires_at</li> <li><code>has_valid_token -&gt; bool</code> - Returns True if session has non-empty token</li> </ul> <p>Methods:</p> <ul> <li><code>touch(extend_by: Optional[timedelta] = None) -&gt; SessionData</code> - Returns new SessionData with updated last_accessed time and optionally extended expiration</li> </ul> <p>Example:</p> <pre><code>from datetime import UTC, datetime, timedelta\nfrom uuid import UUID\nfrom portico.ports.session import SessionData\n\n# Create session data\nsession = SessionData(\n    id=\"abc123token\",\n    user_id=UUID(\"550e8400-e29b-41d4-a716-446655440000\"),\n    created_at=datetime.now(UTC),\n    expires_at=datetime.now(UTC) + timedelta(hours=24),\n    last_accessed=datetime.now(UTC),\n    ip_address=\"192.168.1.100\",\n    user_agent=\"Mozilla/5.0...\"\n)\n\n# Check expiration\nif not session.is_expired:\n    # Session is still valid\n    user_id = session.user_id\n\n# Update last accessed time\nsession = session.touch()\n\n# Extend session expiration\nsession = session.touch(extend_by=timedelta(hours=1))\n</code></pre>"},{"location":"ports/session/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/session/#sessionstorage","title":"SessionStorage","text":"<p>The <code>SessionStorage</code> abstract base class defines the contract for all session storage backends.</p> <p>Location: <code>portico.ports.session.SessionStorage</code></p>"},{"location":"ports/session/#key-methods","title":"Key Methods","text":""},{"location":"ports/session/#store_session","title":"store_session","text":"<pre><code>async def store_session(token: str, session_data: SessionData) -&gt; None\n</code></pre> <p>Stores session data with the given token. Primary method for session creation and updates.</p> <p>Parameters:</p> <ul> <li><code>token</code>: Session token/identifier to use as the storage key</li> <li><code>session_data</code>: SessionData object containing session information</li> </ul> <p>Example:</p> <pre><code>from datetime import UTC, datetime, timedelta\nfrom uuid import uuid4\nfrom portico.ports.session import SessionData, SessionStorage\n\nasync def create_session(\n    user_id: UUID,\n    storage: SessionStorage,\n    session_timeout: timedelta = timedelta(hours=24)\n) -&gt; str:\n    \"\"\"Create a new user session.\"\"\"\n\n    # Generate secure token\n    token = secrets.token_urlsafe(32)\n\n    # Create session data\n    session_data = SessionData(\n        id=token,\n        user_id=user_id,\n        created_at=datetime.now(UTC),\n        expires_at=datetime.now(UTC) + session_timeout,\n        last_accessed=datetime.now(UTC),\n        ip_address=request.client.host,\n        user_agent=request.headers.get(\"user-agent\")\n    )\n\n    # Store session\n    await storage.store_session(token, session_data)\n\n    return token\n</code></pre>"},{"location":"ports/session/#get_session","title":"get_session","text":"<pre><code>async def get_session(token: str) -&gt; Optional[SessionData]\n</code></pre> <p>Retrieves session data by token. Primary method for session validation and retrieval.</p> <p>Parameters:</p> <ul> <li><code>token</code>: Session token to retrieve</li> </ul> <p>Returns: <code>SessionData</code> if found, <code>None</code> otherwise.</p> <p>Example:</p> <pre><code>async def validate_session(\n    token: str,\n    storage: SessionStorage\n) -&gt; Optional[UUID]:\n    \"\"\"Validate session and return user ID.\"\"\"\n\n    # Retrieve session\n    session = await storage.get_session(token)\n\n    if session is None:\n        # Session not found\n        return None\n\n    if session.is_expired:\n        # Session expired - delete it\n        await storage.delete_session(token)\n        return None\n\n    # Update last accessed time\n    session = session.touch()\n    await storage.store_session(token, session)\n\n    return session.user_id\n</code></pre>"},{"location":"ports/session/#other-methods","title":"Other Methods","text":""},{"location":"ports/session/#delete_session","title":"delete_session","text":"<pre><code>async def delete_session(token: str) -&gt; bool\n</code></pre> <p>Deletes session by token. Returns True if session existed and was deleted.</p> <p>Example:</p> <pre><code># User logout\nasync def logout(token: str, storage: SessionStorage):\n    deleted = await storage.delete_session(token)\n    if deleted:\n        logger.info(\"session_deleted\", token=token)\n</code></pre>"},{"location":"ports/session/#delete_user_sessions","title":"delete_user_sessions","text":"<pre><code>async def delete_user_sessions(user_id: UUID) -&gt; int\n</code></pre> <p>Deletes all sessions for a user. Returns number of sessions deleted.</p> <p>Example:</p> <pre><code># User password changed - revoke all sessions\nasync def revoke_all_sessions(user_id: UUID, storage: SessionStorage):\n    count = await storage.delete_user_sessions(user_id)\n    logger.info(\"sessions_revoked\", user_id=user_id, count=count)\n</code></pre>"},{"location":"ports/session/#cleanup_expired_sessions","title":"cleanup_expired_sessions","text":"<pre><code>async def cleanup_expired_sessions() -&gt; int\n</code></pre> <p>Removes expired sessions. Returns number of sessions cleaned up.</p> <p>Example:</p> <pre><code># Periodic cleanup task\nasync def cleanup_task(storage: SessionStorage):\n    while True:\n        await asyncio.sleep(3600)  # Every hour\n        count = await storage.cleanup_expired_sessions()\n        logger.info(\"expired_sessions_cleaned\", count=count)\n</code></pre>"},{"location":"ports/session/#get_user_sessions","title":"get_user_sessions","text":"<pre><code>async def get_user_sessions(user_id: UUID) -&gt; list[SessionData]\n</code></pre> <p>Gets all active sessions for a user.</p> <p>Example:</p> <pre><code># List user's active sessions\nasync def list_sessions(user_id: UUID, storage: SessionStorage):\n    sessions = await storage.get_user_sessions(user_id)\n\n    return [\n        {\n            \"token\": s.id,\n            \"created_at\": s.created_at,\n            \"last_accessed\": s.last_accessed,\n            \"ip_address\": s.ip_address,\n            \"user_agent\": s.user_agent\n        }\n        for s in sessions\n        if not s.is_expired\n    ]\n</code></pre>"},{"location":"ports/session/#exceptions","title":"Exceptions","text":"<p>The Session Port defines several specialized exceptions for session-related errors:</p>"},{"location":"ports/session/#sessionerror","title":"SessionError","text":"<p>Base exception for all session-related errors.</p> <p>Error Code: <code>SESSION_ERROR</code></p>"},{"location":"ports/session/#sessionnotfounderror","title":"SessionNotFoundError","text":"<p>Raised when attempting to access a session that doesn't exist.</p> <p>Error Code: <code>SESSION_NOT_FOUND</code> HTTP Status: 404</p> <pre><code>from portico.exceptions import SessionNotFoundError\n\nsession = await storage.get_session(token)\nif session is None:\n    raise SessionNotFoundError(token)\n</code></pre>"},{"location":"ports/session/#sessionexpirederror","title":"SessionExpiredError","text":"<p>Raised when attempting to use an expired session.</p> <p>Error Code: <code>SESSION_EXPIRED</code> HTTP Status: 401</p> <pre><code>from portico.exceptions import SessionExpiredError\n\nif session.is_expired:\n    raise SessionExpiredError(token)\n</code></pre>"},{"location":"ports/session/#invalidsessionerror","title":"InvalidSessionError","text":"<p>Raised when session token is malformed or corrupted.</p> <p>Error Code: <code>INVALID_SESSION</code> HTTP Status: 401</p> <pre><code>from portico.exceptions import InvalidSessionError\n\nif not session.has_valid_token:\n    raise InvalidSessionError(\"Session token is empty or invalid\")\n</code></pre>"},{"location":"ports/session/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/session/#session-creation-with-cookie-storage","title":"Session Creation with Cookie Storage","text":"<pre><code>from datetime import UTC, datetime, timedelta\nfrom fastapi import Response\nimport secrets\nfrom portico.ports.session import SessionData, SessionStorage\n\nasync def create_user_session(\n    user_id: UUID,\n    storage: SessionStorage,\n    response: Response,\n    session_timeout_minutes: int = 1440  # 24 hours\n) -&gt; str:\n    \"\"\"Create session and set cookie.\"\"\"\n\n    # Generate secure token\n    token = secrets.token_urlsafe(32)\n\n    # Create session data\n    session_data = SessionData(\n        id=token,\n        user_id=user_id,\n        created_at=datetime.now(UTC),\n        expires_at=datetime.now(UTC) + timedelta(minutes=session_timeout_minutes),\n        last_accessed=datetime.now(UTC),\n        ip_address=request.client.host if request else None,\n        user_agent=request.headers.get(\"user-agent\") if request else None\n    )\n\n    # Store in backend\n    await storage.store_session(token, session_data)\n\n    # Set HTTP-only cookie\n    response.set_cookie(\n        key=\"session_token\",\n        value=token,\n        httponly=True,\n        secure=True,  # HTTPS only in production\n        samesite=\"lax\",\n        max_age=session_timeout_minutes * 60\n    )\n\n    return token\n</code></pre>"},{"location":"ports/session/#session-validation-middleware","title":"Session Validation Middleware","text":"<pre><code>from fastapi import Request, HTTPException\nfrom portico.ports.session import SessionStorage\nfrom portico.exceptions import SessionExpiredError, SessionNotFoundError\n\nasync def validate_session_middleware(\n    request: Request,\n    storage: SessionStorage\n) -&gt; UUID:\n    \"\"\"Validate session from cookie and return user ID.\"\"\"\n\n    # Extract token from cookie\n    token = request.cookies.get(\"session_token\")\n    if not token:\n        raise HTTPException(status_code=401, detail=\"No session token\")\n\n    # Retrieve session\n    session = await storage.get_session(token)\n    if session is None:\n        raise SessionNotFoundError(token)\n\n    # Check expiration\n    if session.is_expired:\n        await storage.delete_session(token)\n        raise SessionExpiredError(token)\n\n    # Touch session (update last_accessed)\n    session = session.touch()\n    await storage.store_session(token, session)\n\n    return session.user_id\n</code></pre>"},{"location":"ports/session/#sliding-session-expiration","title":"Sliding Session Expiration","text":"<pre><code>async def refresh_session(\n    token: str,\n    storage: SessionStorage,\n    extension: timedelta = timedelta(hours=1)\n) -&gt; SessionData:\n    \"\"\"Extend session expiration on activity.\"\"\"\n\n    session = await storage.get_session(token)\n    if session is None:\n        raise SessionNotFoundError(token)\n\n    if session.is_expired:\n        raise SessionExpiredError(token)\n\n    # Touch and extend expiration\n    session = session.touch(extend_by=extension)\n    await storage.store_session(token, session)\n\n    return session\n</code></pre>"},{"location":"ports/session/#session-cleanup-background-task","title":"Session Cleanup Background Task","text":"<pre><code>import asyncio\nfrom portico.ports.session import SessionStorage\nfrom portico.kits.logging import get_logger\n\nlogger = get_logger(__name__)\n\nasync def periodic_session_cleanup(\n    storage: SessionStorage,\n    interval_seconds: int = 3600  # Every hour\n):\n    \"\"\"Background task to clean up expired sessions.\"\"\"\n\n    while True:\n        try:\n            await asyncio.sleep(interval_seconds)\n\n            count = await storage.cleanup_expired_sessions()\n\n            if count &gt; 0:\n                logger.info(\n                    \"expired_sessions_cleaned\",\n                    count=count,\n                    interval_seconds=interval_seconds\n                )\n        except Exception as e:\n            logger.error(\n                \"session_cleanup_failed\",\n                error=str(e),\n                error_type=type(e).__name__\n            )\n</code></pre>"},{"location":"ports/session/#integration-with-kits","title":"Integration with Kits","text":"<p>The Session Port is designed to be used by authentication kits and session management services.</p> <p>Note: Currently, the Session Port is not directly integrated with a specific kit. The AuthKit has its own session management implementation. Future versions may provide a dedicated SessionKit that uses this port.</p> <p>Potential Usage Pattern:</p> <pre><code>from portico import compose\nfrom portico.ports.session import SessionStorage\n\n# Future integration pattern (not yet implemented)\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[\n        compose.session(\n            backend=\"redis\",  # or \"database\", \"memory\"\n            redis_url=\"redis://localhost:6379/0\",\n            session_timeout_minutes=1440,\n            cleanup_interval_seconds=3600\n        ),\n    ],\n)\n\n# Access session storage\nsession_storage: SessionStorage = app.kits[\"session\"].storage\n</code></pre>"},{"location":"ports/session/#best-practices","title":"Best Practices","text":"<ol> <li>Use Secure Token Generation: Always use cryptographically secure random tokens</li> </ol> <pre><code># \u2705 GOOD: Cryptographically secure\nimport secrets\ntoken = secrets.token_urlsafe(32)\n\n# \u274c BAD: Predictable tokens\nimport random\ntoken = str(random.randint(0, 999999))  # NEVER do this!\n</code></pre> <ol> <li>Set Appropriate Expiration Times: Different session types need different timeouts</li> </ol> <pre><code># \u2705 GOOD: Different timeouts for different contexts\nexpires_at = datetime.now(UTC) + timedelta(hours=24)    # Regular sessions\nexpires_at = datetime.now(UTC) + timedelta(minutes=15)  # Admin sessions\nexpires_at = datetime.now(UTC) + timedelta(days=30)     # Remember-me tokens\n\n# \u274c BAD: No expiration\nexpires_at = datetime.max  # Sessions never expire!\n</code></pre> <ol> <li>Always Touch Sessions on Access: Update last_accessed for sliding expiration</li> </ol> <pre><code># \u2705 GOOD: Update access time\nsession = await storage.get_session(token)\nif session and not session.is_expired:\n    session = session.touch()\n    await storage.store_session(token, session)\n\n# \u274c BAD: Never update access time\nsession = await storage.get_session(token)\n# Session will expire even if actively used\n</code></pre> <ol> <li>Cleanup Expired Sessions Regularly: Prevent storage bloat</li> </ol> <pre><code># \u2705 GOOD: Scheduled cleanup\nasync def cleanup_task():\n    while True:\n        await asyncio.sleep(3600)  # Every hour\n        await storage.cleanup_expired_sessions()\n\nasyncio.create_task(cleanup_task())\n\n# \u274c BAD: No cleanup\n# Expired sessions accumulate forever\n</code></pre> <ol> <li>Store Minimal Session Data: Keep session metadata lightweight</li> </ol> <pre><code># \u2705 GOOD: Store only user_id, fetch user data as needed\nsession = SessionData(\n    id=token,\n    user_id=user_id,\n    # ... minimal metadata\n)\n\n# Later, fetch full user data\nuser = await user_repository.get_user(session.user_id)\n\n# \u274c BAD: Store entire user object in session\n# This duplicates data and can lead to stale information\n</code></pre> <ol> <li>Revoke Sessions on Security Events: Delete sessions when needed</li> </ol> <pre><code># \u2705 GOOD: Revoke on password change\nasync def change_password(user_id: UUID, new_password: str):\n    await user_service.update_password(user_id, new_password)\n    # Revoke all existing sessions\n    await storage.delete_user_sessions(user_id)\n\n# \u274c BAD: Keep old sessions active after password change\n# Allows potentially compromised sessions to remain valid\n</code></pre>"},{"location":"ports/session/#faqs","title":"FAQs","text":""},{"location":"ports/session/#how-is-sessiondata-different-from-the-auth-kits-session-model","title":"How is SessionData different from the auth kit's Session model?","text":"<p>SessionData (from the Session Port) is designed as a generic session storage model with rich metadata (IP address, user agent, access tracking). It's intended for flexible session storage backends.</p> <p>The auth kit's Session model is a simpler database-backed session model specific to the current AuthKit implementation.</p> <p>Future versions may unify these or provide adapters between them.</p>"},{"location":"ports/session/#should-i-use-database-or-redis-for-session-storage","title":"Should I use database or Redis for session storage?","text":"<p>Database storage when: - You have a small user base (&lt; 10,000 active sessions) - You want session persistence across restarts - You already have a database and want to minimize dependencies - You need ACID guarantees for session operations</p> <p>Redis storage when: - You have a large user base (&gt; 10,000 active sessions) - Performance is critical (sub-millisecond session lookups) - You can tolerate session loss on Redis restart (or use Redis persistence) - You need distributed session sharing across app servers</p>"},{"location":"ports/session/#how-do-i-implement-remember-me-functionality","title":"How do I implement \"remember me\" functionality?","text":"<p>Create two session types with different expiration times:</p> <pre><code># Regular session: 24 hours\nregular_session = SessionData(\n    id=session_token,\n    user_id=user_id,\n    expires_at=datetime.now(UTC) + timedelta(hours=24),\n    # ...\n)\n\n# Remember-me session: 30 days\nremember_token = secrets.token_urlsafe(32)\nremember_session = SessionData(\n    id=remember_token,\n    user_id=user_id,\n    expires_at=datetime.now(UTC) + timedelta(days=30),\n    # ...\n)\n</code></pre> <p>Store both tokens in separate cookies with appropriate expiration.</p>"},{"location":"ports/session/#can-one-user-have-multiple-active-sessions","title":"Can one user have multiple active sessions?","text":"<p>Yes! This is common for users on multiple devices. Use <code>get_user_sessions()</code> to retrieve all active sessions:</p> <pre><code># List user's active sessions\nsessions = await storage.get_user_sessions(user_id)\n\n# Display in user settings\nfor session in sessions:\n    print(f\"Device: {session.user_agent}\")\n    print(f\"Last active: {session.last_accessed}\")\n    print(f\"IP: {session.ip_address}\")\n</code></pre>"},{"location":"ports/session/#how-do-i-handle-session-fixation-attacks","title":"How do I handle session fixation attacks?","text":"<p>Regenerate session tokens after privilege escalation (login, permission changes):</p> <pre><code>async def login(username: str, password: str, storage: SessionStorage):\n    # Validate credentials\n    user = await authenticate(username, password)\n\n    # Generate NEW token after successful login\n    new_token = secrets.token_urlsafe(32)\n\n    session = SessionData(\n        id=new_token,\n        user_id=user.id,\n        # ...\n    )\n\n    await storage.store_session(new_token, session)\n\n    # Never reuse pre-authentication tokens\n    return new_token\n</code></pre>"},{"location":"ports/session/#should-i-encrypt-session-data","title":"Should I encrypt session data?","text":"<p>The session token itself should be: - Generated with cryptographically secure random (\u2705 <code>secrets.token_urlsafe()</code>) - Transmitted only over HTTPS (\u2705 <code>secure=True</code> cookie flag) - HTTP-only to prevent JavaScript access (\u2705 <code>httponly=True</code>)</p> <p>Session data (SessionData fields) typically doesn't need encryption if: - Tokens are stored securely - Storage backend is secure (database, Redis with auth) - Data is minimal (just user_id and metadata)</p> <p>Encrypt session data if: - Storing sensitive PII in session - Regulatory requirements demand it - Using untrusted storage backend</p>"},{"location":"ports/template/","title":"Template Port","text":""},{"location":"ports/template/#overview","title":"Overview","text":"<p>The Template Port defines the contract for storing, managing, and rendering reusable templates in Portico applications.</p> <p>Purpose: Abstract template storage and rendering operations to enable consistent text generation across different use cases (LLM prompts, emails, notifications, etc.).</p> <p>Domain: Template management, content generation, variable substitution</p> <p>Key Capabilities:</p> <ul> <li>Jinja2-based template storage and rendering</li> <li>Template versioning with full history</li> <li>User ownership and access control</li> <li>Type-specific template organization (LLM prompts, emails, SMS, webhooks)</li> <li>Variable extraction and validation</li> <li>Template search and filtering</li> <li>Public and private template sharing</li> <li>Version restoration and rollback</li> </ul> <p>Port Type: Repository + Adapter (dual interface)</p> <p>When to Use:</p> <ul> <li>LLM prompt template management</li> <li>Email and notification template systems</li> <li>Webhook payload templating</li> <li>Multi-tenant applications with user-specific templates</li> <li>Content generation with dynamic variable substitution</li> <li>Applications requiring template version control</li> </ul>"},{"location":"ports/template/#domain-models","title":"Domain Models","text":""},{"location":"ports/template/#template","title":"Template","text":"<p>Represents a reusable template with type-specific metadata and optional user ownership. Immutable.</p> Field Type Required Default Description <code>id</code> <code>UUID</code> No <code>uuid4()</code> Unique template identifier <code>name</code> <code>str</code> Yes - Template name (unique within type) <code>description</code> <code>Optional[str]</code> No <code>None</code> Template description <code>template_type</code> <code>str</code> Yes - Type identifier (e.g., \"llm_prompt\", \"notification_email\") <code>content</code> <code>str</code> Yes - Jinja2 template content <code>variables</code> <code>List[str]</code> No <code>[]</code> List of variable names used in template <code>metadata</code> <code>Dict[str, Any]</code> No <code>{}</code> Type-specific configuration <code>tags</code> <code>List[str]</code> No <code>[]</code> Tags for organization and search <code>user_id</code> <code>Optional[UUID]</code> No <code>None</code> Owner user ID (None = system template) <code>is_public</code> <code>bool</code> No <code>False</code> Whether template is visible to all users <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp <code>updated_at</code> <code>datetime</code> No Current UTC time Last update timestamp <p>Methods:</p> <ul> <li><code>get_metadata_field(field: str, default: Any = None) -&gt; Any</code> - Safely get metadata field with default</li> <li><code>is_owned_by(user_id: UUID) -&gt; bool</code> - Check if template is owned by user</li> <li><code>is_accessible_by(user_id: Optional[UUID]) -&gt; bool</code> - Check if template is accessible by user (public, owned, or system)</li> </ul> <p>Example:</p> <pre><code>from portico.ports.template import Template, TemplateTypes\n\n# LLM prompt template\ntemplate = Template(\n    name=\"customer_support_assistant\",\n    description=\"Friendly customer support assistant prompt\",\n    template_type=TemplateTypes.LLM_PROMPT,\n    content=\"You are a helpful customer support assistant for {{ company_name }}. \"\n            \"Be friendly and professional. Customer question: {{ question }}\",\n    variables=[\"company_name\", \"question\"],\n    metadata={\n        \"model\": \"gpt-4\",\n        \"temperature\": 0.7,\n        \"max_tokens\": 500\n    },\n    tags=[\"customer-support\", \"assistant\"],\n    user_id=None,  # System template\n    is_public=True\n)\n\n# Check access\nif template.is_accessible_by(user_id):\n    print(\"User can access this template\")\n\n# Get metadata\nmodel = template.get_metadata_field(\"model\", \"gpt-3.5-turbo\")\n</code></pre>"},{"location":"ports/template/#templateversion","title":"TemplateVersion","text":"<p>A version snapshot of a template, enabling version history and restoration. Immutable.</p> Field Type Required Default Description <code>id</code> <code>UUID</code> No <code>uuid4()</code> Unique version identifier <code>template_id</code> <code>UUID</code> Yes - Parent template ID <code>name</code> <code>str</code> Yes - Template name (snapshot) <code>description</code> <code>Optional[str]</code> No <code>None</code> Template description (snapshot) <code>template_type</code> <code>str</code> Yes - Template type (snapshot) <code>content</code> <code>str</code> Yes - Template content (snapshot) <code>variables</code> <code>List[str]</code> No <code>[]</code> Variable names (snapshot) <code>metadata</code> <code>Dict[str, Any]</code> No <code>{}</code> Metadata (snapshot) <code>tags</code> <code>List[str]</code> No <code>[]</code> Tags (snapshot) <code>version_number</code> <code>int</code> Yes - Sequential version number (1, 2, 3...) <code>created_by</code> <code>Optional[UUID]</code> No <code>None</code> User who created this version <code>change_note</code> <code>Optional[str]</code> No <code>None</code> Optional note describing changes <code>restored_from_version</code> <code>Optional[int]</code> No <code>None</code> If restored, which version number <code>created_at</code> <code>datetime</code> No Current UTC time Version creation timestamp <code>updated_at</code> <code>datetime</code> No Current UTC time Version update timestamp <p>Example:</p> <pre><code>from portico.ports.template import TemplateVersion\n\n# Get version history\nversions = await template_registry.list_versions(template_id)\n\nfor version in versions:\n    print(f\"Version {version.version_number}\")\n    print(f\"  Created by: {version.created_by}\")\n    print(f\"  Note: {version.change_note}\")\n    if version.restored_from_version:\n        print(f\"  Restored from v{version.restored_from_version}\")\n</code></pre>"},{"location":"ports/template/#createtemplaterequest","title":"CreateTemplateRequest","text":"<p>Request for creating a new template.</p> Field Type Required Default Description <code>name</code> <code>str</code> Yes - Template name <code>description</code> <code>Optional[str]</code> No <code>None</code> Template description <code>template_type</code> <code>str</code> Yes - Template type identifier <code>content</code> <code>str</code> Yes - Jinja2 template content <code>variables</code> <code>List[str]</code> No <code>[]</code> Variable names <code>metadata</code> <code>Dict[str, Any]</code> No <code>{}</code> Type-specific metadata <code>tags</code> <code>List[str]</code> No <code>[]</code> Tags <code>user_id</code> <code>Optional[UUID]</code> No <code>None</code> Owner user ID <code>is_public</code> <code>bool</code> No <code>False</code> Public visibility <p>Example:</p> <pre><code>from portico.ports.template import CreateTemplateRequest, TemplateTypes\n\nrequest = CreateTemplateRequest(\n    name=\"welcome_email\",\n    description=\"Welcome email for new users\",\n    template_type=TemplateTypes.NOTIFICATION_EMAIL,\n    content=\"Welcome {{ user_name }}! Thanks for joining {{ app_name }}.\",\n    variables=[\"user_name\", \"app_name\"],\n    tags=[\"onboarding\", \"email\"],\n    user_id=admin_user_id,\n    is_public=True\n)\n\ntemplate = await template_registry.create(request)\n</code></pre>"},{"location":"ports/template/#updatetemplaterequest","title":"UpdateTemplateRequest","text":"<p>Request for updating an existing template. All fields optional for partial updates.</p> Field Type Required Default Description <code>name</code> <code>Optional[str]</code> No <code>None</code> New template name <code>description</code> <code>Optional[str]</code> No <code>None</code> New description <code>content</code> <code>Optional[str]</code> No <code>None</code> New template content <code>variables</code> <code>Optional[List[str]]</code> No <code>None</code> New variable list <code>metadata</code> <code>Optional[Dict[str, Any]]</code> No <code>None</code> New metadata <code>tags</code> <code>Optional[List[str]]</code> No <code>None</code> New tags <code>is_public</code> <code>Optional[bool]</code> No <code>None</code> New public status <p>Example:</p> <pre><code>from portico.ports.template import UpdateTemplateRequest\n\n# Update content and make public\nrequest = UpdateTemplateRequest(\n    content=\"Updated template content with {{ new_variable }}\",\n    variables=[\"new_variable\"],\n    is_public=True\n)\n\nupdated = await template_registry.update(template_id, request, user_id)\n</code></pre>"},{"location":"ports/template/#templatequery","title":"TemplateQuery","text":"<p>Query parameters for searching templates. Immutable.</p> Field Type Required Default Description <code>template_type</code> <code>Optional[str]</code> No <code>None</code> Filter by single template type <code>template_types</code> <code>Optional[List[str]]</code> No <code>None</code> Filter by multiple template types <code>tags</code> <code>Optional[List[str]]</code> No <code>None</code> Filter by tags (any match) <code>name_contains</code> <code>Optional[str]</code> No <code>None</code> Filter by name substring <code>limit</code> <code>int</code> No <code>100</code> Maximum results (1-1000) <code>offset</code> <code>int</code> No <code>0</code> Results to skip (\u22650) <p>Example:</p> <pre><code>from portico.ports.template import TemplateQuery, TemplateTypes\n\n# Search for email templates\nquery = TemplateQuery(\n    template_types=[TemplateTypes.NOTIFICATION_EMAIL, TemplateTypes.NOTIFICATION_SMS],\n    tags=[\"onboarding\"],\n    name_contains=\"welcome\",\n    limit=10\n)\n\ntemplates = await template_registry.search_templates(query)\n</code></pre>"},{"location":"ports/template/#enumerations","title":"Enumerations","text":""},{"location":"ports/template/#templatetypes","title":"TemplateTypes","text":"<p>Standard template type constants.</p> Constant Value Description <code>LLM_PROMPT</code> <code>\"llm_prompt\"</code> LLM system/user prompts <code>NOTIFICATION_EMAIL</code> <code>\"notification_email\"</code> Email notification templates <code>NOTIFICATION_SMS</code> <code>\"notification_sms\"</code> SMS notification templates <code>WEBHOOK</code> <code>\"webhook\"</code> Webhook payload templates <code>SLACK</code> <code>\"slack\"</code> Slack message templates <p>Example:</p> <pre><code>from portico.ports.template import TemplateTypes\n\n# Use constants instead of strings\ntemplate = CreateTemplateRequest(\n    name=\"my_prompt\",\n    template_type=TemplateTypes.LLM_PROMPT,  # \u2705 Type-safe\n    content=\"...\"\n)\n\n# \u274c Avoid magic strings\ntemplate_type = \"llm_prompt\"\n</code></pre>"},{"location":"ports/template/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/template/#templateregistry","title":"TemplateRegistry","text":"<p>The <code>TemplateRegistry</code> abstract base class defines the contract for template storage and retrieval.</p> <p>Location: <code>portico.ports.template.TemplateRegistry</code></p>"},{"location":"ports/template/#key-methods","title":"Key Methods","text":""},{"location":"ports/template/#create","title":"create","text":"<pre><code>async def create(template_data: CreateTemplateRequest) -&gt; Template\n</code></pre> <p>Create a new template. Primary method for storing templates.</p> <p>Parameters:</p> <ul> <li><code>template_data</code>: Template creation data</li> </ul> <p>Returns: Created Template object.</p> <p>Example:</p> <pre><code>from portico.ports.template import CreateTemplateRequest, TemplateTypes\n\n# Create LLM prompt template\nrequest = CreateTemplateRequest(\n    name=\"code_reviewer\",\n    description=\"Code review assistant prompt\",\n    template_type=TemplateTypes.LLM_PROMPT,\n    content=\"\"\"You are an expert code reviewer. Review this code for:\n- Bugs and errors\n- Performance issues\n- Best practices\n\nCode:\n{{ code }}\n\nLanguage: {{ language }}\"\"\",\n    variables=[\"code\", \"language\"],\n    metadata={\n        \"model\": \"gpt-4\",\n        \"temperature\": 0.3\n    },\n    tags=[\"code-review\", \"development\"],\n    user_id=user_id,\n    is_public=False\n)\n\ntemplate = await template_registry.create(request)\nprint(f\"Created template: {template.id}\")\n</code></pre>"},{"location":"ports/template/#get_by_id","title":"get_by_id","text":"<pre><code>async def get_by_id(template_id: UUID, user_id: Optional[UUID] = None) -&gt; Optional[Template]\n</code></pre> <p>Retrieve a template by ID with access control. Primary method for loading templates.</p> <p>Parameters:</p> <ul> <li><code>template_id</code>: Template identifier</li> <li><code>user_id</code>: Optional user ID for access control (checks if user can access template)</li> </ul> <p>Returns: Template object if found and accessible, None otherwise.</p> <p>Example:</p> <pre><code># Get template with access control\ntemplate = await template_registry.get_by_id(template_id, user_id=current_user_id)\n\nif template:\n    # User has access\n    rendered = template_renderer.render(template.content, {\"code\": code, \"language\": \"python\"})\nelse:\n    # Template not found or access denied\n    print(\"Template not accessible\")\n\n# Get system template (no access control)\nsystem_template = await template_registry.get_by_id(template_id)\n</code></pre>"},{"location":"ports/template/#other-methods","title":"Other Methods","text":""},{"location":"ports/template/#get_by_name","title":"get_by_name","text":"<pre><code>async def get_by_name(name: str, template_type: Optional[str] = None) -&gt; Optional[Template]\n</code></pre> <p>Retrieve a template by name and optional type. Returns first match if type not specified.</p>"},{"location":"ports/template/#update","title":"update","text":"<pre><code>async def update(\n    template_id: UUID,\n    update_data: UpdateTemplateRequest,\n    user_id: Optional[UUID] = None\n) -&gt; Optional[Template]\n</code></pre> <p>Update an existing template. If user_id provided, verifies ownership. Returns updated template or None.</p>"},{"location":"ports/template/#delete","title":"delete","text":"<pre><code>async def delete(template_id: UUID, user_id: Optional[UUID] = None) -&gt; bool\n</code></pre> <p>Delete a template. If user_id provided, verifies ownership. Returns True if deleted, False if not found.</p>"},{"location":"ports/template/#list_templates","title":"list_templates","text":"<pre><code>async def list_templates(\n    template_type: Optional[str] = None,\n    tags: Optional[List[str]] = None,\n    user_id: Optional[UUID] = None,\n    include_public: bool = True,\n    limit: int = 100,\n    offset: int = 0\n) -&gt; List[Template]\n</code></pre> <p>List templates with filtering and pagination. If user_id provided, returns user's templates + public + system templates.</p>"},{"location":"ports/template/#search_templates","title":"search_templates","text":"<pre><code>async def search_templates(query: TemplateQuery) -&gt; List[Template]\n</code></pre> <p>Search templates with advanced filters. Returns list of templates matching query.</p>"},{"location":"ports/template/#get_latest_version","title":"get_latest_version","text":"<pre><code>async def get_latest_version(template_id: UUID) -&gt; Optional[TemplateVersion]\n</code></pre> <p>Get the most recent version of a template. Returns latest TemplateVersion or None.</p>"},{"location":"ports/template/#get_version","title":"get_version","text":"<pre><code>async def get_version(template_id: UUID, version_number: int) -&gt; Optional[TemplateVersion]\n</code></pre> <p>Get a specific version of a template. Returns TemplateVersion or None.</p>"},{"location":"ports/template/#list_versions","title":"list_versions","text":"<pre><code>async def list_versions(template_id: UUID, limit: int = 100, offset: int = 0) -&gt; List[TemplateVersion]\n</code></pre> <p>List all versions of a template, newest first. Returns list of TemplateVersion objects.</p>"},{"location":"ports/template/#restore_version","title":"restore_version","text":"<pre><code>async def restore_version(\n    template_id: UUID,\n    version_number: int,\n    created_by: Optional[UUID] = None,\n    change_note: Optional[str] = None\n) -&gt; Template\n</code></pre> <p>Restore template to a previous version. Creates new version with old content (preserves history). Raises ResourceNotFoundError if not found.</p>"},{"location":"ports/template/#get_version_count","title":"get_version_count","text":"<pre><code>async def get_version_count(template_id: UUID) -&gt; int\n</code></pre> <p>Get total number of versions for a template. Returns version count.</p>"},{"location":"ports/template/#templaterenderer","title":"TemplateRenderer","text":"<p>The <code>TemplateRenderer</code> abstract base class defines the contract for rendering templates with variables.</p> <p>Location: <code>portico.ports.template.TemplateRenderer</code></p>"},{"location":"ports/template/#key-methods_1","title":"Key Methods","text":""},{"location":"ports/template/#render","title":"render","text":"<pre><code>def render(template: str, variables: Dict[str, Any]) -&gt; str\n</code></pre> <p>Render a template with variables. Primary method for template rendering.</p> <p>Parameters:</p> <ul> <li><code>template</code>: Jinja2 template string</li> <li><code>variables</code>: Dictionary of variable values</li> </ul> <p>Returns: Rendered template string.</p> <p>Raises: - <code>TemplateRenderError</code> if rendering fails - <code>TemplateValidationError</code> if template has syntax errors</p> <p>Example:</p> <pre><code>from portico.adapters.template import Jinja2TemplateRenderer\n\nrenderer = Jinja2TemplateRenderer()\n\n# Simple variable substitution\ntemplate = \"Hello {{ name }}!\"\nrendered = renderer.render(template, {\"name\": \"Alice\"})\nprint(rendered)  # \"Hello Alice!\"\n\n# With conditionals\ntemplate = \"\"\"\n\nFree user: {{ name }}\n\n\"\"\"\nrendered = renderer.render(template, {\"name\": \"Bob\", \"is_premium\": True})\n\n# With loops\ntemplate = \"\"\"\nItems:\n\n\"\"\"\nrendered = renderer.render(template, {\"items\": [\"apple\", \"banana\", \"cherry\"]})\n</code></pre>"},{"location":"ports/template/#extract_variables","title":"extract_variables","text":"<pre><code>def extract_variables(template: str) -&gt; List[str]\n</code></pre> <p>Extract variable names from a template. Returns list of unique variable names found.</p> <p>Example:</p> <pre><code>template = \"Hello {{ name }}, your score is {{ score }}!\"\nvariables = renderer.extract_variables(template)\nprint(variables)  # [\"name\", \"score\"]\n</code></pre>"},{"location":"ports/template/#other-methods_1","title":"Other Methods","text":""},{"location":"ports/template/#validate_variables","title":"validate_variables","text":"<pre><code>def validate_variables(template: str, variables: Dict[str, Any]) -&gt; List[str]\n</code></pre> <p>Check if all required variables are provided. Returns list of missing variable names (empty if all provided).</p>"},{"location":"ports/template/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/template/#llm-prompt-management","title":"LLM Prompt Management","text":"<pre><code>from portico.ports.template import (\n    TemplateRegistry,\n    TemplateRenderer,\n    CreateTemplateRequest,\n    TemplateTypes\n)\n\nasync def create_prompt_template(\n    template_registry: TemplateRegistry,\n    name: str,\n    content: str,\n    model: str = \"gpt-4\",\n    temperature: float = 0.7\n):\n    \"\"\"Create an LLM prompt template with metadata.\"\"\"\n\n    # Extract variables from template\n    from portico.adapters.template import Jinja2TemplateRenderer\n    renderer = Jinja2TemplateRenderer()\n    variables = renderer.extract_variables(content)\n\n    # Create template\n    request = CreateTemplateRequest(\n        name=name,\n        template_type=TemplateTypes.LLM_PROMPT,\n        content=content,\n        variables=variables,\n        metadata={\n            \"model\": model,\n            \"temperature\": temperature,\n            \"max_tokens\": 1000\n        }\n    )\n\n    template = await template_registry.create(request)\n    return template\n\nasync def render_prompt(\n    template_registry: TemplateRegistry,\n    template_renderer: TemplateRenderer,\n    template_name: str,\n    variables: dict\n) -&gt; str:\n    \"\"\"Load and render a prompt template.\"\"\"\n\n    # Get template\n    template = await template_registry.get_by_name(\n        template_name,\n        template_type=TemplateTypes.LLM_PROMPT\n    )\n\n    if not template:\n        raise ValueError(f\"Template '{template_name}' not found\")\n\n    # Validate variables\n    missing = template_renderer.validate_variables(template.content, variables)\n    if missing:\n        raise ValueError(f\"Missing required variables: {missing}\")\n\n    # Render\n    return template_renderer.render(template.content, variables)\n\n# Usage\ntemplate = await create_prompt_template(\n    template_registry,\n    name=\"code_explainer\",\n    content=\"Explain this {{ language }} code:\\n\\n{{ code }}\"\n)\n\nprompt = await render_prompt(\n    template_registry,\n    template_renderer,\n    template_name=\"code_explainer\",\n    variables={\"language\": \"Python\", \"code\": \"def hello(): print('Hi')\"}\n)\n</code></pre>"},{"location":"ports/template/#template-versioning-and-rollback","title":"Template Versioning and Rollback","text":"<pre><code>from portico.ports.template import UpdateTemplateRequest\n\nasync def update_template_with_versioning(\n    template_registry: TemplateRegistry,\n    template_id: UUID,\n    new_content: str,\n    user_id: UUID,\n    change_note: str\n):\n    \"\"\"Update template content and create version snapshot.\"\"\"\n\n    # Update creates a new version automatically\n    request = UpdateTemplateRequest(content=new_content)\n    updated = await template_registry.update(template_id, request, user_id)\n\n    # Get version history\n    versions = await template_registry.list_versions(template_id)\n    latest_version = versions[0]\n\n    logger.info(\n        \"template_updated\",\n        template_id=str(template_id),\n        version=latest_version.version_number,\n        note=change_note\n    )\n\n    return updated\n\nasync def rollback_template(\n    template_registry: TemplateRegistry,\n    template_id: UUID,\n    version_number: int,\n    user_id: UUID\n):\n    \"\"\"Rollback template to a previous version.\"\"\"\n\n    # Restore creates a new version with old content\n    restored = await template_registry.restore_version(\n        template_id=template_id,\n        version_number=version_number,\n        created_by=user_id,\n        change_note=f\"Rolled back to version {version_number}\"\n    )\n\n    logger.info(\n        \"template_restored\",\n        template_id=str(template_id),\n        restored_from=version_number\n    )\n\n    return restored\n\n# Usage\n# Update template (creates version 2)\nawait update_template_with_versioning(\n    template_registry,\n    template_id,\n    new_content=\"Updated prompt: {{ variable }}\",\n    user_id=admin_id,\n    change_note=\"Improved clarity\"\n)\n\n# Oops, rollback to version 1\nawait rollback_template(template_registry, template_id, version_number=1, user_id=admin_id)\n</code></pre>"},{"location":"ports/template/#integration-with-kits","title":"Integration with Kits","text":"<p>The Template Port is used by the LLM Kit for prompt template management and by applications for general template needs.</p> <pre><code>from portico import compose\nfrom portico.adapters.template import Jinja2TemplateRenderer\nfrom portico.ports.template import CreateTemplateRequest, TemplateTypes\n\n# Templates are stored in the database\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[compose.llm(provider=\"openai\", api_key=\"sk-...\")]\n)\n\nawait app.initialize()\n\n# Access template registry through database adapter\n# (Note: Template kit not yet implemented, use adapters directly)\nfrom portico.adapters.storage import SqlAlchemyTemplateRegistry\n\ntemplate_registry = SqlAlchemyTemplateRegistry(database=app.database)\ntemplate_renderer = Jinja2TemplateRenderer()\n\n# Create prompt template\nrequest = CreateTemplateRequest(\n    name=\"chat_assistant\",\n    template_type=TemplateTypes.LLM_PROMPT,\n    content=\"You are a {{ persona }}. Answer: {{ question }}\",\n    variables=[\"persona\", \"question\"],\n    metadata={\"model\": \"gpt-4\", \"temperature\": 0.7}\n)\n\ntemplate = await template_registry.create(request)\n\n# Render and use with LLM\nprompt = template_renderer.render(\n    template.content,\n    {\"persona\": \"helpful assistant\", \"question\": \"What is Python?\"}\n)\n\nresponse = await app.kits[\"llm\"].service.complete(prompt)\n</code></pre> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/template/#best-practices","title":"Best Practices","text":"<ol> <li>Extract Variables Automatically: Use <code>extract_variables()</code> to avoid manual variable tracking</li> </ol> <pre><code># \u2705 GOOD: Auto-extract variables\nrenderer = Jinja2TemplateRenderer()\nvariables = renderer.extract_variables(content)\n\ntemplate = CreateTemplateRequest(\n    name=\"my_template\",\n    content=content,\n    variables=variables  # Automatically tracked\n)\n\n# \u274c BAD: Manually specify (error-prone)\nvariables = [\"var1\", \"var2\"]  # Easy to forget variables\n</code></pre> <ol> <li>Validate Variables Before Rendering: Check for missing variables to provide clear errors</li> </ol> <pre><code># \u2705 GOOD: Validate first\nmissing = renderer.validate_variables(template.content, variables)\nif missing:\n    raise ValueError(f\"Missing variables: {missing}\")\nrendered = renderer.render(template.content, variables)\n\n# \u274c BAD: No validation (cryptic errors)\nrendered = renderer.render(template.content, variables)\n# Raises UndefinedError at runtime\n</code></pre> <ol> <li>Use Namespaces for Multi-Tenancy: Leverage user_id for template isolation</li> </ol> <pre><code># \u2705 GOOD: User-owned templates\ntemplate = CreateTemplateRequest(\n    name=\"my_prompt\",\n    content=\"...\",\n    user_id=current_user_id,  # User owns this\n    is_public=False  # Private to user\n)\n\n# System admins can create public templates\nsystem_template = CreateTemplateRequest(\n    name=\"default_prompt\",\n    content=\"...\",\n    user_id=None,  # System template\n    is_public=True  # Everyone can use\n)\n\n# \u274c BAD: No ownership (can't filter by user)\ntemplate = CreateTemplateRequest(name=\"template\", content=\"...\")\n</code></pre> <ol> <li>Version Risky Changes: Use versioning before updating critical templates</li> </ol> <pre><code># \u2705 GOOD: Version history preserved\n# Each update creates a new version\nawait template_registry.update(template_id, UpdateTemplateRequest(content=new_content))\n\n# Can rollback if needed\nawait template_registry.restore_version(template_id, version_number=1)\n\n# \u274c BAD: Direct content modification\n# (Not possible with immutable models, but conceptually wrong)\n</code></pre> <ol> <li>Use Type Constants: Use <code>TemplateTypes</code> constants instead of magic strings</li> </ol> <pre><code># \u2705 GOOD: Type-safe constants\nfrom portico.ports.template import TemplateTypes\n\ntemplate = CreateTemplateRequest(\n    template_type=TemplateTypes.LLM_PROMPT,  # IDE autocomplete\n    ...\n)\n\n# \u274c BAD: Magic strings (typo-prone)\ntemplate = CreateTemplateRequest(\n    template_type=\"llm_promt\",  # Typo!\n    ...\n)\n</code></pre>"},{"location":"ports/template/#faqs","title":"FAQs","text":""},{"location":"ports/template/#what-template-syntax-is-supported","title":"What template syntax is supported?","text":"<p>Portico uses Jinja2 template syntax, supporting:</p> <ul> <li>Variable substitution: <code>{{ variable }}</code></li> <li>Conditionals: ``</li> <li>Loops: ``</li> <li>Filters: <code>{{ VARIABLE }}</code></li> <li>Comments: ``</li> </ul> <p>See Jinja2 documentation for full syntax.</p>"},{"location":"ports/template/#how-does-template-versioning-work","title":"How does template versioning work?","text":"<p>Every time you update a template, a new <code>TemplateVersion</code> is created automatically. Versions are numbered sequentially (1, 2, 3...) and preserve the complete template state.</p> <p>Version operations: - <code>list_versions()</code> - View version history - <code>get_version()</code> - Load a specific version - <code>restore_version()</code> - Rollback to an old version (creates new version with old content)</p> <p>Important: Restoring a version doesn't delete newer versions\u2014it creates a new version with the old content, preserving full history.</p>"},{"location":"ports/template/#how-do-i-handle-missing-template-variables","title":"How do I handle missing template variables?","text":"<p>Use <code>validate_variables()</code> before rendering:</p> <pre><code>missing = renderer.validate_variables(template.content, variables)\nif missing:\n    # Prompt user for missing values or use defaults\n    for var in missing:\n        variables[var] = get_default_value(var)\n\nrendered = renderer.render(template.content, variables)\n</code></pre> <p>Alternatively, catch <code>TemplateRenderError</code> when rendering.</p>"},{"location":"ports/template/#can-i-use-templates-without-a-database","title":"Can I use templates without a database?","text":"<p>Yes! You can use the <code>TemplateRenderer</code> directly without storing templates:</p> <pre><code>from portico.adapters.template import Jinja2TemplateRenderer\n\nrenderer = Jinja2TemplateRenderer()\n\n# Render inline template\ntemplate_string = \"Hello {{ name }}!\"\nrendered = renderer.render(template_string, {\"name\": \"World\"})\n</code></pre> <p>The <code>TemplateRegistry</code> is only needed if you want to store, version, and manage templates in a database.</p>"},{"location":"ports/template/#how-do-i-implement-a-custom-template-storage-backend","title":"How do I implement a custom template storage backend?","text":"<p>Implement the <code>TemplateRegistry</code> interface:</p> <pre><code>from portico.ports.template import (\n    TemplateRegistry,\n    Template,\n    CreateTemplateRequest,\n    UpdateTemplateRequest\n)\n\nclass CustomTemplateRegistry(TemplateRegistry):\n    async def create(self, template_data: CreateTemplateRequest) -&gt; Template:\n        # Store template in your backend\n        template_id = await your_db.insert_template(template_data)\n        return await self.get_by_id(template_id)\n\n    async def get_by_id(\n        self,\n        template_id: UUID,\n        user_id: Optional[UUID] = None\n    ) -&gt; Optional[Template]:\n        # Retrieve from your backend\n        data = await your_db.get_template(template_id)\n\n        if not data:\n            return None\n\n        template = Template(**data)\n\n        # Check access control\n        if user_id and not template.is_accessible_by(user_id):\n            return None\n\n        return template\n\n    # Implement all other abstract methods...\n</code></pre> <p>Then use it directly:</p> <pre><code>registry = CustomTemplateRegistry(connection_string=\"...\")\ntemplate = await registry.create(CreateTemplateRequest(...))\n</code></pre>"},{"location":"ports/user/","title":"User Port","text":""},{"location":"ports/user/#overview","title":"Overview","text":"<p>The User Port defines the contract for user management, authentication, and authorization in Portico applications.</p> <p>Purpose: Provides interfaces and domain models for user identity, password-based authentication, and global role-based access control.</p> <p>Domain: User management, authentication, authorization</p> <p>Key Capabilities:</p> <ul> <li>User CRUD operations (create, read, update, delete)</li> <li>Password-based authentication with secure hashing</li> <li>Global role-based authorization</li> <li>User search and listing with pagination</li> <li>Email and username uniqueness enforcement</li> </ul> <p>Port Type: Repository</p> <p>When to Use:</p> <ul> <li>Implementing user registration and account management</li> <li>Authenticating users with username/email and password</li> <li>Managing user profiles and lifecycle</li> <li>Implementing role-based access control at the global level</li> </ul>"},{"location":"ports/user/#domain-models","title":"Domain Models","text":""},{"location":"ports/user/#user","title":"User","text":"<p>Core domain model representing an authenticated user. Immutable snapshot of user state.</p> Field Type Required Default Description <code>id</code> <code>UUID</code> Yes <code>uuid4()</code> Unique user identifier <code>email</code> <code>str</code> Yes - User's email address (unique) <code>username</code> <code>str</code> Yes - Username for login (unique) <code>is_active</code> <code>bool</code> Yes <code>True</code> Whether the account is active <code>global_role</code> <code>str</code> Yes <code>\"user\"</code> Global system role (e.g., \"user\", \"admin\") <code>password_hash</code> <code>Optional[str]</code> No <code>None</code> Serialized password hash <code>password_changed_at</code> <code>Optional[datetime]</code> No <code>None</code> Last password change timestamp (UTC) <code>created_at</code> <code>datetime</code> Yes <code>now(UTC)</code> Account creation timestamp (UTC) <code>updated_at</code> <code>datetime</code> Yes <code>now(UTC)</code> Last update timestamp (UTC) <p>Methods:</p> <ul> <li><code>has_password() -&gt; bool</code> - Returns True if user has a password set</li> </ul> <p>Example:</p> <pre><code>from portico.ports.user import User\nfrom datetime import datetime, UTC\nfrom uuid import uuid4\n\nuser = User(\n    id=uuid4(),\n    email=\"john@example.com\",\n    username=\"john_doe\",\n    is_active=True,\n    global_role=\"admin\",\n    password_hash=\"$2b$12$...\",\n    created_at=datetime.now(UTC),\n    updated_at=datetime.now(UTC)\n)\n\n# User is immutable (frozen)\nif user.has_password():\n    print(\"User has password authentication enabled\")\n</code></pre>"},{"location":"ports/user/#createuserrequest","title":"CreateUserRequest","text":"<p>Request model for creating a new user. Supports both raw password (to be hashed) and pre-hashed password workflows.</p> Field Type Required Default Description <code>email</code> <code>str</code> Yes - User's email address <code>username</code> <code>str</code> Yes - User's username <code>global_role</code> <code>str</code> No <code>\"user\"</code> Initial global role <code>password_hash</code> <code>Optional[str]</code> No <code>None</code> Pre-hashed password <code>password</code> <code>Optional[str]</code> No <code>None</code> Raw password (will be hashed by service) <p>Example:</p> <pre><code>from portico.ports.user import CreateUserRequest\n\n# User registration with raw password\nrequest = CreateUserRequest(\n    email=\"john@example.com\",\n    username=\"john_doe\",\n    password=\"securePassword123\"\n)\n\n# SSO user without password\nsso_request = CreateUserRequest(\n    email=\"sso@example.com\",\n    username=\"sso_user\"\n)\n</code></pre>"},{"location":"ports/user/#updateuserrequest","title":"UpdateUserRequest","text":"<p>Request model for updating an existing user. All fields optional for partial updates.</p> Field Type Required Default Description <code>email</code> <code>Optional[str]</code> No <code>None</code> New email address <code>username</code> <code>Optional[str]</code> No <code>None</code> New username <code>is_active</code> <code>Optional[bool]</code> No <code>None</code> New active status <code>global_role</code> <code>Optional[str]</code> No <code>None</code> New global role <p>Example:</p> <pre><code>from portico.ports.user import UpdateUserRequest\n\n# Update email only\nrequest = UpdateUserRequest(email=\"newemail@example.com\")\n\n# Deactivate user\nrequest = UpdateUserRequest(is_active=False)\n</code></pre>"},{"location":"ports/user/#setpasswordrequest","title":"SetPasswordRequest","text":"<p>Request model for setting or updating a user's password hash.</p> Field Type Required Default Description <code>password_hash</code> <code>str</code> Yes - Serialized password hash <p>Example:</p> <pre><code>from portico.ports.user import SetPasswordRequest\n\nrequest = SetPasswordRequest(\n    password_hash=\"$2b$12$...\"\n)\n</code></pre>"},{"location":"ports/user/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/user/#userrepository","title":"UserRepository","text":"<p>Abstract interface for user persistence operations.</p> <p>Location: <code>portico.ports.user.UserRepository</code></p>"},{"location":"ports/user/#key-methods","title":"Key Methods","text":""},{"location":"ports/user/#create","title":"create","text":"<pre><code>async def create(user_data: CreateUserRequest) -&gt; Optional[User]\n</code></pre> <p>Create a new user in the system.</p> <p>Parameters:</p> <ul> <li><code>user_data: CreateUserRequest</code> - User creation data</li> </ul> <p>Returns: Created User object, or None if creation failed</p> <p>Raises:</p> <ul> <li><code>ConflictError</code> - If email or username already exists</li> <li><code>ValidationError</code> - If data validation fails</li> </ul> <p>Example:</p> <pre><code>from portico.ports.user import UserRepository, CreateUserRequest\n\nuser = await repository.create(\n    CreateUserRequest(\n        email=\"john@example.com\",\n        username=\"john_doe\",\n        password=\"securePassword123\"\n    )\n)\n</code></pre>"},{"location":"ports/user/#authenticate_user","title":"authenticate_user","text":"<pre><code>async def authenticate_user(username_or_email: str, password_hash: str) -&gt; Optional[User]\n</code></pre> <p>Authenticate a user by username/email and password hash.</p> <p>Parameters:</p> <ul> <li><code>username_or_email: str</code> - Username or email address</li> <li><code>password_hash: str</code> - Password hash to verify</li> </ul> <p>Returns: User if authentication succeeds, None otherwise</p> <p>Example:</p> <pre><code># Service layer hashes the provided password first\nuser = await repository.authenticate_user(\n    \"john@example.com\",\n    hashed_password\n)\nif user:\n    print(\"Authentication successful\")\n</code></pre>"},{"location":"ports/user/#other-methods","title":"Other Methods","text":""},{"location":"ports/user/#get_by_id","title":"get_by_id","text":"<pre><code>async def get_by_id(user_id: UUID) -&gt; Optional[User]\n</code></pre> <p>Retrieve a user by their unique ID.</p>"},{"location":"ports/user/#get_by_email","title":"get_by_email","text":"<pre><code>async def get_by_email(email: str) -&gt; Optional[User]\n</code></pre> <p>Retrieve a user by their email address.</p>"},{"location":"ports/user/#get_by_username","title":"get_by_username","text":"<pre><code>async def get_by_username(username: str) -&gt; Optional[User]\n</code></pre> <p>Retrieve a user by their username.</p>"},{"location":"ports/user/#update","title":"update","text":"<pre><code>async def update(user_id: UUID, update_data: UpdateUserRequest) -&gt; Optional[User]\n</code></pre> <p>Update an existing user. Performs partial update - only non-None fields are updated.</p>"},{"location":"ports/user/#delete","title":"delete","text":"<pre><code>async def delete(user_id: UUID) -&gt; bool\n</code></pre> <p>Delete a user by ID. Returns True if deleted, False if not found.</p>"},{"location":"ports/user/#list_users","title":"list_users","text":"<pre><code>async def list_users(limit: int = 100, offset: int = 0) -&gt; List[User]\n</code></pre> <p>List users with pagination.</p>"},{"location":"ports/user/#set_password","title":"set_password","text":"<pre><code>async def set_password(user_id: UUID, password_request: SetPasswordRequest) -&gt; Optional[User]\n</code></pre> <p>Set or update a user's password hash.</p>"},{"location":"ports/user/#get_user_password_hash","title":"get_user_password_hash","text":"<pre><code>async def get_user_password_hash(user_id: UUID) -&gt; Optional[str]\n</code></pre> <p>Get a user's password hash for verification purposes.</p>"},{"location":"ports/user/#search_users","title":"search_users","text":"<pre><code>async def search_users(query: str, limit: int = 10) -&gt; List[User]\n</code></pre> <p>Search users by email or username.</p>"},{"location":"ports/user/#rolepermissionmanager","title":"RolePermissionManager","text":"<p>Abstract interface for role and permission management at the global level.</p> <p>Location: <code>portico.ports.user.RolePermissionManager</code></p>"},{"location":"ports/user/#define_role","title":"define_role","text":"<pre><code>def define_role(role_name: str, permissions: Set[str]) -&gt; None\n</code></pre> <p>Define a role with its associated permissions.</p>"},{"location":"ports/user/#get_role_permissions","title":"get_role_permissions","text":"<pre><code>def get_role_permissions(role_name: str) -&gt; Set[str]\n</code></pre> <p>Get all permissions for a specific role.</p>"},{"location":"ports/user/#user_has_permission","title":"user_has_permission","text":"<pre><code>def user_has_permission(user: User, permission: str) -&gt; bool\n</code></pre> <p>Check if a user has a specific permission based on their global role.</p>"},{"location":"ports/user/#user_has_role","title":"user_has_role","text":"<pre><code>def user_has_role(user: User, role: str) -&gt; bool\n</code></pre> <p>Check if a user has a specific role.</p>"},{"location":"ports/user/#get_all_roles","title":"get_all_roles","text":"<pre><code>def get_all_roles() -&gt; Dict[str, Set[str]]\n</code></pre> <p>Get all defined roles and their permissions.</p>"},{"location":"ports/user/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/user/#creating-and-authenticating-users","title":"Creating and Authenticating Users","text":"<pre><code>from portico import compose\nfrom portico.ports.user import CreateUserRequest\n\n# Initialize application\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///app.db\",\n    kits=[compose.user(password_min_length=8)]\n)\nawait app.initialize()\n\n# Create a user\nuser = await app.kits[\"user\"].service.create_user(\n    CreateUserRequest(\n        email=\"john@example.com\",\n        username=\"john_doe\",\n        password=\"securePassword123\"\n    )\n)\n\n# Authenticate user (via Auth Kit)\nauthenticated = await app.kits[\"auth\"].service.login(\n    username_or_email=\"john@example.com\",\n    password=\"securePassword123\"\n)\n\nif authenticated:\n    print(f\"Logged in as: {authenticated.email}\")\n</code></pre>"},{"location":"ports/user/#role-based-authorization","title":"Role-Based Authorization","text":"<pre><code>from portico.ports.user import User\n\n# Define roles\nmanager = app.kits[\"user\"].role_manager\nmanager.define_role(\"editor\", {\"create_post\", \"edit_post\", \"delete_own_post\"})\nmanager.define_role(\"admin\", {\"create_post\", \"edit_post\", \"delete_any_post\", \"manage_users\"})\n\n# Check permissions\nuser = await app.kits[\"user\"].service.get_user(user_id)\nif manager.user_has_permission(user, \"delete_post\"):\n    await delete_post(post_id)\nelse:\n    raise AuthorizationError(\"Permission denied\")\n</code></pre>"},{"location":"ports/user/#integration-with-kits","title":"Integration with Kits","text":"<p>The User Port is used by the User Kit to provide user management services.</p> <pre><code>from portico import compose\n\n# Configure User Kit\napp = compose.webapp(\n    kits=[\n        compose.user(\n            password_min_length=8,\n            password_max_age_days=90\n        )\n    ]\n)\n\n# Access User Service\nuser_service = app.kits[\"user\"].service\n\n# Create user\nuser = await user_service.create_user(\n    CreateUserRequest(email=\"user@example.com\", username=\"user\", password=\"password123\")\n)\n\n# Update user\nupdated = await user_service.update_user(\n    user.id,\n    UpdateUserRequest(global_role=\"admin\")\n)\n</code></pre> <p>The User Kit provides:</p> <ul> <li>Password hashing with bcrypt</li> <li>Password policy enforcement</li> <li>Event publishing (UserCreatedEvent, UserUpdatedEvent, UserDeletedEvent)</li> <li>Validation before repository calls</li> </ul> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/user/#best-practices","title":"Best Practices","text":"<ol> <li>Immutability: User model is immutable - always get fresh instances from repository</li> </ol> <pre><code># \u2705 GOOD\nupdated_user = await repository.update(user.id, UpdateUserRequest(email=\"new@example.com\"))\n\n# \u274c BAD\nuser.email = \"new@example.com\"  # Raises FrozenInstanceError!\n</code></pre> <ol> <li>Password Security: Never store plain text passwords. Use CreateUserRequest with <code>password</code> field for automatic hashing</li> </ol> <pre><code># \u2705 GOOD\nCreateUserRequest(email=\"user@example.com\", username=\"user\", password=\"plaintext\")\n\n# \u274c BAD\nUser(..., password_hash=\"plaintext\")  # Never store plain passwords!\n</code></pre> <ol> <li>Unique Constraints: Handle email/username conflicts gracefully with ConflictError</li> </ol> <pre><code>from portico.exceptions import ConflictError\n\ntry:\n    user = await repository.create(CreateUserRequest(...))\nexcept ConflictError:\n    print(\"User already exists\")\n</code></pre> <ol> <li>Pagination: Always paginate when listing users to avoid memory issues</li> </ol> <pre><code># \u2705 GOOD\nusers = await repository.list_users(limit=50, offset=0)\n\n# \u274c BAD\nusers = await repository.list_users(limit=999999)\n</code></pre> <ol> <li>Indexed Lookups: Use direct lookups (get_by_email) instead of search for better performance</li> </ol> <pre><code># \u2705 FAST - Direct lookup (indexed)\nuser = await repository.get_by_email(\"john@example.com\")\n\n# \u274c SLOW - Search for exact match\nusers = await repository.search_users(\"john@example.com\")\n</code></pre>"},{"location":"ports/user/#faqs","title":"FAQs","text":""},{"location":"ports/user/#why-is-the-user-model-immutable-frozen","title":"Why is the User model immutable (frozen)?","text":"<p>Immutability ensures data consistency in async operations. Multiple coroutines might reference the same User object - immutability prevents race conditions. When you update a user, you get a new User instance from the repository.</p>"},{"location":"ports/user/#should-i-hash-passwords-in-my-application-code","title":"Should I hash passwords in my application code?","text":"<p>No, the UserService in the User Kit handles password hashing automatically. Provide a <code>password</code> field in CreateUserRequest - the service hashes it before calling the repository. Only provide <code>password_hash</code> for admin operations with pre-hashed passwords.</p>"},{"location":"ports/user/#can-i-extend-the-user-model-with-custom-fields","title":"Can I extend the User model with custom fields?","text":"<p>The User port model is intentionally minimal. For custom fields:</p> <ol> <li>Store in metadata: Add a JSONB column in your database model</li> <li>Create extension models: Define your own model that includes User + custom fields</li> </ol> <pre><code>from portico.ports.user import User\n\nclass ExtendedUser(BaseModel):\n    user: User  # Core user from port\n    profile_picture_url: Optional[str] = None\n    bio: Optional[str] = None\n</code></pre>"},{"location":"ports/user/#can-users-exist-without-passwords","title":"Can users exist without passwords?","text":"<p>Yes! Set <code>password_hash</code> to <code>None</code> for SSO users or users who authenticate through external providers:</p> <pre><code>user = CreateUserRequest(\n    email=\"sso@example.com\",\n    username=\"sso_user\"\n    # No password or password_hash\n)\n\nif not user.has_password():\n    print(\"User must authenticate via SSO\")\n</code></pre>"},{"location":"ports/user/#how-do-i-implement-a-custom-adapter-for-userrepository","title":"How do I implement a custom adapter for UserRepository?","text":"<p>Implement all abstract methods defined in the <code>UserRepository</code> interface:</p> <pre><code>from portico.ports.user import UserRepository, User, CreateUserRequest\n\nclass CustomUserRepository(UserRepository):\n    async def create(self, user_data: CreateUserRequest) -&gt; Optional[User]:\n        # Your implementation\n        pass\n\n    async def get_by_id(self, user_id: UUID) -&gt; Optional[User]:\n        # Your implementation\n        pass\n\n    # ... implement all other abstract methods\n</code></pre> <p>Then use it in composition:</p> <pre><code>def user(**config):\n    from your_module import CustomUserRepository\n    from portico.kits.user import UserKit\n\n    def factory(database, events):\n        repository = CustomUserRepository(config[\"connection_string\"])\n        return UserKit(database, events, config, user_repository=repository)\n\n    return factory\n</code></pre>"},{"location":"ports/vector_store/","title":"Vector Store Port","text":""},{"location":"ports/vector_store/#overview","title":"Overview","text":"<p>The Vector Store Port defines the contract for storing and searching vector embeddings in Portico applications.</p> <p>Purpose: Abstract vector storage and similarity search operations to enable pluggable vector database backends for semantic search and retrieval.</p> <p>Domain: Vector similarity search, semantic retrieval, RAG (Retrieval-Augmented Generation)</p> <p>Key Capabilities:</p> <ul> <li>Document and document chunk storage with embeddings</li> <li>Vector similarity search with multiple algorithms (cosine, euclidean, dot product)</li> <li>Namespace-based multi-tenant isolation</li> <li>Metadata filtering for refined searches</li> <li>Similarity threshold filtering</li> <li>Direct similarity computation between vectors</li> <li>Batch indexing operations</li> <li>Statistics and monitoring</li> </ul> <p>Port Type: Adapter</p> <p>When to Use:</p> <ul> <li>RAG (Retrieval-Augmented Generation) systems</li> <li>Semantic search applications</li> <li>Document similarity and clustering</li> <li>Question-answering systems</li> <li>Knowledge base retrieval</li> <li>Content recommendation engines</li> <li>Duplicate detection</li> </ul>"},{"location":"ports/vector_store/#domain-models","title":"Domain Models","text":""},{"location":"ports/vector_store/#document","title":"Document","text":"<p>Represents a document with text content, metadata, and optional embedding. Immutable.</p> Field Type Required Default Description <code>id</code> <code>str</code> No <code>uuid4()</code> Unique document identifier <code>content</code> <code>str</code> Yes - Document text content <code>metadata</code> <code>Dict[str, Any]</code> No <code>{}</code> Custom metadata for filtering <code>embedding</code> <code>Optional[List[float]]</code> No <code>None</code> Vector embedding (required for indexing) <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp <p>Example:</p> <pre><code>from portico.ports.vector_store import Document\n\n# Document with embedding\ndoc = Document(\n    id=\"doc_123\",\n    content=\"Portico is a Python framework for building GPT-powered applications.\",\n    metadata={\n        \"source\": \"documentation\",\n        \"category\": \"overview\",\n        \"version\": \"1.0\"\n    },\n    embedding=[0.123, -0.456, 0.789, ...]  # 1536-dim vector\n)\n</code></pre>"},{"location":"ports/vector_store/#documentchunk","title":"DocumentChunk","text":"<p>Represents a chunked portion of a document with position metadata. Used for long documents that need to be split. Immutable.</p> Field Type Required Default Description <code>id</code> <code>str</code> No <code>uuid4()</code> Unique chunk identifier <code>content</code> <code>str</code> Yes - Chunk text content <code>metadata</code> <code>Dict[str, Any]</code> No <code>{}</code> Custom metadata for filtering <code>embedding</code> <code>Optional[List[float]]</code> No <code>None</code> Vector embedding (required for indexing) <code>document_id</code> <code>str</code> Yes - Parent document ID <code>chunk_index</code> <code>int</code> Yes - Position index in parent document <code>start_char</code> <code>int</code> Yes - Starting character position <code>end_char</code> <code>int</code> Yes - Ending character position <code>created_at</code> <code>datetime</code> No Current UTC time Creation timestamp <p>Example:</p> <pre><code>from portico.ports.vector_store import DocumentChunk\n\nchunk = DocumentChunk(\n    id=\"chunk_1\",\n    content=\"Portico uses hexagonal architecture with ports and adapters.\",\n    metadata={\"source\": \"documentation\", \"category\": \"architecture\"},\n    embedding=[0.234, -0.567, 0.891, ...],\n    document_id=\"doc_123\",\n    chunk_index=0,\n    start_char=0,\n    end_char=65\n)\n</code></pre>"},{"location":"ports/vector_store/#searchquery","title":"SearchQuery","text":"<p>Query parameters for vector similarity search. Immutable.</p> Field Type Required Default Description <code>vector</code> <code>Optional[List[float]]</code> No* <code>None</code> Query vector for similarity search <code>text</code> <code>Optional[str]</code> No* <code>None</code> Query text (must be embedded first) <code>k</code> <code>int</code> No <code>10</code> Number of results to return <code>threshold</code> <code>Optional[float]</code> No <code>None</code> Minimum similarity threshold (0.0-1.0) <code>filters</code> <code>Dict[str, Any]</code> No <code>{}</code> Metadata filters to apply <code>namespace</code> <code>Optional[str]</code> No <code>None</code> Namespace for multi-tenant isolation <code>include_metadata</code> <code>bool</code> No <code>True</code> Include metadata in results <code>include_embeddings</code> <code>bool</code> No <code>False</code> Include embeddings in results <p>Validation: Either <code>vector</code> or <code>text</code> must be provided (but not both).</p> <p>Example:</p> <pre><code>from portico.ports.vector_store import SearchQuery\n\n# Search with vector\nquery = SearchQuery(\n    vector=[0.123, -0.456, 0.789, ...],  # Pre-embedded query\n    k=5,\n    threshold=0.7,\n    filters={\"category\": \"documentation\"},\n    namespace=\"prod\"\n)\n\n# Search with text (requires RAG service to embed)\nquery = SearchQuery(\n    text=\"How do I use Portico?\",\n    k=10,\n    namespace=\"prod\"\n)\n</code></pre>"},{"location":"ports/vector_store/#searchresult","title":"SearchResult","text":"<p>Search result with document/chunk and similarity score. Immutable.</p> Field Type Required Default Description <code>document</code> <code>Document \\| DocumentChunk</code> Yes - Retrieved document or chunk <code>score</code> <code>float</code> Yes - Similarity score (0.0-1.0, higher is better) <p>Example:</p> <pre><code>from portico.ports.vector_store import SearchResult\n\nresults = await vector_store.search(query)\n\nfor result in results:\n    print(f\"Score: {result.score:.3f}\")\n    print(f\"Content: {result.document.content[:100]}\")\n    print(f\"Metadata: {result.document.metadata}\")\n</code></pre>"},{"location":"ports/vector_store/#similarityrequest","title":"SimilarityRequest","text":"<p>Request for computing similarity between vectors or texts. Immutable.</p> Field Type Required Default Description <code>query_vector</code> <code>Optional[List[float]]</code> No* <code>None</code> Query vector <code>query_text</code> <code>Optional[str]</code> No* <code>None</code> Query text (must be embedded) <code>target_vectors</code> <code>Optional[List[List[float]]]</code> No* <code>None</code> Target vectors to compare <code>target_texts</code> <code>Optional[List[str]]</code> No* <code>None</code> Target texts (must be embedded) <code>method</code> <code>str</code> No <code>\"cosine\"</code> Similarity method (cosine, euclidean, dot_product) <p>Validation: Either <code>query_vector</code> or <code>query_text</code> must be provided. Either <code>target_vectors</code> or <code>target_texts</code> must be provided.</p> <p>Example:</p> <pre><code>from portico.ports.vector_store import SimilarityRequest\n\nrequest = SimilarityRequest(\n    query_vector=[0.1, 0.2, 0.3],\n    target_vectors=[\n        [0.15, 0.25, 0.35],\n        [0.5, 0.6, 0.7],\n        [-0.1, -0.2, -0.3]\n    ],\n    method=\"cosine\"\n)\n\nresponse = await vector_store.compute_similarity(request)\nprint(response.scores)  # [0.998, 0.845, -0.123]\n</code></pre>"},{"location":"ports/vector_store/#similarityresponse","title":"SimilarityResponse","text":"<p>Response from similarity computation. Immutable.</p> Field Type Required Default Description <code>scores</code> <code>List[float]</code> Yes - Similarity scores for each target <code>method</code> <code>str</code> Yes - Similarity method used"},{"location":"ports/vector_store/#vectorstorestats","title":"VectorStoreStats","text":"<p>Statistics about the vector store. Immutable.</p> Field Type Required Default Description <code>total_documents</code> <code>int</code> Yes - Total number of documents indexed <code>total_chunks</code> <code>int</code> Yes - Total number of chunks indexed <code>namespaces</code> <code>List[str]</code> Yes - List of namespaces in use <code>average_embedding_dimension</code> <code>Optional[int]</code> No <code>None</code> Average embedding vector dimension <code>storage_size_bytes</code> <code>Optional[int]</code> No <code>None</code> Storage size (if available) <p>Example:</p> <pre><code>stats = await vector_store.get_stats()\n\nprint(f\"Documents: {stats.total_documents}\")\nprint(f\"Chunks: {stats.total_chunks}\")\nprint(f\"Namespaces: {stats.namespaces}\")\nprint(f\"Avg dimension: {stats.average_embedding_dimension}\")\n</code></pre>"},{"location":"ports/vector_store/#vectorstoreconfig","title":"VectorStoreConfig","text":"<p>Configuration for vector store operations. Immutable.</p> Field Type Required Default Description <code>default_namespace</code> <code>str</code> No <code>\"default\"</code> Default namespace for operations <code>max_documents_per_namespace</code> <code>Optional[int]</code> No <code>None</code> Max documents per namespace (None = unlimited) <code>default_search_k</code> <code>int</code> No <code>10</code> Default number of search results <code>default_similarity_threshold</code> <code>float</code> No <code>0.0</code> Default minimum similarity threshold <code>similarity_method</code> <code>str</code> No <code>\"cosine\"</code> Default similarity method <code>batch_size</code> <code>int</code> No <code>100</code> Batch size for bulk operations <code>enable_metadata_indexing</code> <code>bool</code> No <code>True</code> Enable metadata indexing for faster filtering"},{"location":"ports/vector_store/#port-interfaces","title":"Port Interfaces","text":""},{"location":"ports/vector_store/#vectorstore","title":"VectorStore","text":"<p>The <code>VectorStore</code> abstract base class defines the contract for all vector storage backends.</p> <p>Location: <code>portico.ports.vector_store.VectorStore</code></p>"},{"location":"ports/vector_store/#key-methods","title":"Key Methods","text":""},{"location":"ports/vector_store/#index_document","title":"index_document","text":"<pre><code>async def index_document(document: Document, namespace: Optional[str] = None) -&gt; str\n</code></pre> <p>Index a document in the vector store. Primary method for storing documents with embeddings.</p> <p>Parameters:</p> <ul> <li><code>document</code>: Document to index (must have <code>embedding</code> set)</li> <li><code>namespace</code>: Optional namespace for multi-tenant isolation</li> </ul> <p>Returns: Document ID.</p> <p>Raises: ValueError if document does not have an embedding.</p> <p>Example:</p> <pre><code>from portico.ports.vector_store import Document\n\n# Create document with embedding\nembedding = await embedding_provider.embed_text(\"Your document text here\")\ndoc = Document(\n    content=\"Your document text here\",\n    metadata={\"source\": \"api\", \"author\": \"user_123\"},\n    embedding=embedding\n)\n\n# Index the document\ndoc_id = await vector_store.index_document(doc, namespace=\"prod\")\nprint(f\"Indexed document: {doc_id}\")\n</code></pre>"},{"location":"ports/vector_store/#search","title":"search","text":"<pre><code>async def search(query: SearchQuery) -&gt; List[SearchResult]\n</code></pre> <p>Search for similar documents/chunks. Primary method for semantic search and retrieval.</p> <p>Parameters:</p> <ul> <li><code>query</code>: Search query with vector and parameters</li> </ul> <p>Returns: List of search results sorted by similarity score (highest first), limited to <code>query.k</code> results.</p> <p>Raises: ValueError if query does not have a vector (text queries require embedding first).</p> <p>Example:</p> <pre><code>from portico.ports.vector_store import SearchQuery\n\n# Generate query embedding\nquery_embedding = await embedding_provider.embed_text(\"How do I install Portico?\")\n\n# Search vector store\nquery = SearchQuery(\n    vector=query_embedding,\n    k=5,\n    threshold=0.7,\n    filters={\"category\": \"documentation\"},\n    namespace=\"prod\"\n)\n\nresults = await vector_store.search(query)\n\nfor result in results:\n    print(f\"Score: {result.score:.3f}\")\n    print(f\"Content: {result.document.content[:100]}\")\n    print(f\"Metadata: {result.document.metadata}\")\n    print(\"---\")\n\n# Used in RAG pipeline\nasync def retrieve_context(user_query: str) -&gt; str:\n    embedding = await embedding_provider.embed_text(user_query)\n    results = await vector_store.search(SearchQuery(vector=embedding, k=3))\n    return \"\\n\\n\".join([r.document.content for r in results])\n</code></pre>"},{"location":"ports/vector_store/#other-methods","title":"Other Methods","text":""},{"location":"ports/vector_store/#index_documents","title":"index_documents","text":"<pre><code>async def index_documents(documents: List[Document], namespace: Optional[str] = None) -&gt; List[str]\n</code></pre> <p>Index multiple documents in batch. Returns list of document IDs.</p>"},{"location":"ports/vector_store/#index_chunk","title":"index_chunk","text":"<pre><code>async def index_chunk(chunk: DocumentChunk, namespace: Optional[str] = None) -&gt; str\n</code></pre> <p>Index a document chunk. Returns chunk ID.</p>"},{"location":"ports/vector_store/#index_chunks","title":"index_chunks","text":"<pre><code>async def index_chunks(chunks: List[DocumentChunk], namespace: Optional[str] = None) -&gt; List[str]\n</code></pre> <p>Index multiple document chunks in batch. Returns list of chunk IDs.</p>"},{"location":"ports/vector_store/#get_document","title":"get_document","text":"<pre><code>async def get_document(document_id: str, namespace: Optional[str] = None) -&gt; Optional[Document]\n</code></pre> <p>Retrieve a document by ID. Returns document if found, None otherwise.</p>"},{"location":"ports/vector_store/#get_chunk","title":"get_chunk","text":"<pre><code>async def get_chunk(chunk_id: str, namespace: Optional[str] = None) -&gt; Optional[DocumentChunk]\n</code></pre> <p>Retrieve a document chunk by ID. Returns chunk if found, None otherwise.</p>"},{"location":"ports/vector_store/#delete_document","title":"delete_document","text":"<pre><code>async def delete_document(document_id: str, namespace: Optional[str] = None) -&gt; bool\n</code></pre> <p>Delete a document from the vector store. Returns True if deleted, False if not found.</p>"},{"location":"ports/vector_store/#delete_chunk","title":"delete_chunk","text":"<pre><code>async def delete_chunk(chunk_id: str, namespace: Optional[str] = None) -&gt; bool\n</code></pre> <p>Delete a document chunk from the vector store. Returns True if deleted, False if not found.</p>"},{"location":"ports/vector_store/#delete_by_metadata","title":"delete_by_metadata","text":"<pre><code>async def delete_by_metadata(filters: Dict[str, Any], namespace: Optional[str] = None) -&gt; int\n</code></pre> <p>Delete documents/chunks by metadata filters. Returns number of items deleted.</p>"},{"location":"ports/vector_store/#clear_namespace","title":"clear_namespace","text":"<pre><code>async def clear_namespace(namespace: str) -&gt; int\n</code></pre> <p>Clear all documents/chunks in a namespace. Returns number of items deleted.</p>"},{"location":"ports/vector_store/#clear_all","title":"clear_all","text":"<pre><code>async def clear_all() -&gt; int\n</code></pre> <p>Clear all documents/chunks from the vector store. Returns number of items deleted.</p>"},{"location":"ports/vector_store/#compute_similarity","title":"compute_similarity","text":"<pre><code>async def compute_similarity(request: SimilarityRequest) -&gt; SimilarityResponse\n</code></pre> <p>Compute similarity between query and target vectors. Returns similarity scores for each target.</p>"},{"location":"ports/vector_store/#get_stats","title":"get_stats","text":"<pre><code>async def get_stats(namespace: Optional[str] = None) -&gt; VectorStoreStats\n</code></pre> <p>Get statistics about the vector store. If namespace provided, returns stats for that namespace only.</p>"},{"location":"ports/vector_store/#list_namespaces","title":"list_namespaces","text":"<pre><code>async def list_namespaces() -&gt; List[str]\n</code></pre> <p>List all namespaces in the vector store. Returns list of namespace names.</p>"},{"location":"ports/vector_store/#common-patterns","title":"Common Patterns","text":""},{"location":"ports/vector_store/#rag-pipeline-with-vector-search","title":"RAG Pipeline with Vector Search","text":"<pre><code>from portico.ports.embedding import EmbeddingProvider\nfrom portico.ports.vector_store import VectorStore, SearchQuery, Document\nfrom portico.ports.llm import Message, MessageRole\n\nasync def rag_query(\n    user_query: str,\n    embedding_provider: EmbeddingProvider,\n    vector_store: VectorStore,\n    llm_service: LLMService,\n    k: int = 3\n) -&gt; str:\n    \"\"\"Complete RAG pipeline: retrieve context and generate response.\"\"\"\n\n    # Step 1: Embed the query\n    query_embedding = await embedding_provider.embed_text(user_query)\n\n    # Step 2: Search for relevant documents\n    search_query = SearchQuery(\n        vector=query_embedding,\n        k=k,\n        threshold=0.6,\n        namespace=\"knowledge_base\"\n    )\n    results = await vector_store.search(search_query)\n\n    # Step 3: Build context from top results\n    context = \"\\n\\n\".join([\n        f\"[Source {i+1}]: {r.document.content}\"\n        for i, r in enumerate(results)\n    ])\n\n    # Step 4: Generate response with context\n    messages = [\n        Message(\n            role=MessageRole.SYSTEM,\n            content=f\"Answer using this context:\\n\\n{context}\"\n        ),\n        Message(\n            role=MessageRole.USER,\n            content=user_query\n        )\n    ]\n\n    response = await llm_service.chat(messages)\n    return response.content\n\n# Usage\nanswer = await rag_query(\n    \"How do I use Portico for RAG?\",\n    embedding_provider=app.kits[\"rag\"].embedding_provider,\n    vector_store=app.kits[\"rag\"].vector_store,\n    llm_service=app.kits[\"llm\"].service\n)\n</code></pre>"},{"location":"ports/vector_store/#document-chunking-and-indexing","title":"Document Chunking and Indexing","text":"<pre><code>from portico.ports.vector_store import Document, DocumentChunk\nfrom portico.ports.embedding import EmbeddingProvider\n\nasync def chunk_and_index_document(\n    content: str,\n    metadata: dict,\n    embedding_provider: EmbeddingProvider,\n    vector_store: VectorStore,\n    chunk_size: int = 500,\n    chunk_overlap: int = 50\n):\n    \"\"\"Split long document into chunks and index them.\"\"\"\n\n    # Generate document ID\n    doc_id = str(uuid4())\n\n    chunks = []\n    start = 0\n\n    while start &lt; len(content):\n        end = start + chunk_size\n        chunk_content = content[start:end]\n\n        # Create chunk\n        chunk = DocumentChunk(\n            content=chunk_content,\n            metadata=metadata,\n            document_id=doc_id,\n            chunk_index=len(chunks),\n            start_char=start,\n            end_char=end\n        )\n\n        chunks.append(chunk)\n        start += chunk_size - chunk_overlap\n\n    # Embed all chunks\n    chunk_texts = [c.content for c in chunks]\n    embeddings = await embedding_provider.embed_texts(chunk_texts)\n\n    # Add embeddings to chunks\n    chunks_with_embeddings = [\n        DocumentChunk(**{**chunk.model_dump(), \"embedding\": emb})\n        for chunk, emb in zip(chunks, embeddings)\n    ]\n\n    # Index all chunks\n    chunk_ids = await vector_store.index_chunks(\n        chunks_with_embeddings,\n        namespace=\"documents\"\n    )\n\n    logger.info(\n        \"document_indexed\",\n        doc_id=doc_id,\n        chunks=len(chunk_ids),\n        total_chars=len(content)\n    )\n\n    return doc_id, chunk_ids\n</code></pre>"},{"location":"ports/vector_store/#integration-with-kits","title":"Integration with Kits","text":"<p>The Vector Store Port is used by the RAG Kit to provide document storage and semantic search.</p> <pre><code>from portico import compose\n\n# Configure RAG kit with memory vector store (development)\napp = compose.webapp(\n    database_url=\"sqlite+aiosqlite:///./app.db\",\n    kits=[\n        compose.rag(\n            llm_provider=\"openai\",\n            llm_api_key=\"sk-...\",\n            embedding_provider=\"openai\",\n            embedding_api_key=\"sk-...\",\n            vector_store_type=\"memory\",  # In-memory (requires numpy)\n        ),\n    ],\n)\n\n# Configure with Pinecone (production)\napp = compose.webapp(\n    database_url=\"postgresql+asyncpg://user:pass@localhost/db\",\n    kits=[\n        compose.rag(\n            llm_provider=\"openai\",\n            llm_api_key=\"sk-...\",\n            embedding_provider=\"openai\",\n            embedding_api_key=\"sk-...\",\n            vector_store_type=\"pinecone\",\n            vector_store_config={\n                \"api_key\": \"pc-...\",\n                \"index_name\": \"my-app-vectors\",\n                \"dimension\": 1536,\n                \"cloud\": \"aws\",\n                \"region\": \"us-east-1\",\n                \"metric\": \"cosine\"\n            }\n        ),\n    ],\n)\n\nawait app.initialize()\n\n# Access vector store through RAG kit\nvector_store = app.kits[\"rag\"].vector_store\n\n# Index a document\nembedding = await app.kits[\"rag\"].embedding_provider.embed_text(\"Document content\")\ndoc = Document(content=\"Document content\", embedding=embedding)\ndoc_id = await vector_store.index_document(doc, namespace=\"prod\")\n\n# Search\nquery_emb = await app.kits[\"rag\"].embedding_provider.embed_text(\"search query\")\nresults = await vector_store.search(SearchQuery(vector=query_emb, k=5))\n\n# Get statistics\nstats = await vector_store.get_stats()\nprint(f\"Total documents: {stats.total_documents}\")\n</code></pre> <p>The RAG Kit provides:</p> <ul> <li>Memory vector store adapter (in-memory with numpy)</li> <li>Pinecone vector store adapter (cloud-based)</li> <li>Integration with embedding providers</li> <li>Document chunking utilities</li> <li>Managed RAG service combining retrieval + generation</li> </ul> <p>See the Kits Overview for more information about using kits.</p>"},{"location":"ports/vector_store/#best-practices","title":"Best Practices","text":"<ol> <li>Always Embed Before Indexing: Documents must have embeddings before indexing</li> </ol> <pre><code># \u2705 GOOD: Embed first\nembedding = await embedding_provider.embed_text(content)\ndoc = Document(content=content, embedding=embedding)\nawait vector_store.index_document(doc)\n\n# \u274c BAD: No embedding\ndoc = Document(content=content)\nawait vector_store.index_document(doc)  # Raises ValueError!\n</code></pre> <ol> <li>Use Namespaces for Multi-Tenancy: Isolate data by user, project, or environment</li> </ol> <pre><code># \u2705 GOOD: Namespace isolation\nawait vector_store.index_document(doc, namespace=f\"user:{user_id}\")\nresults = await vector_store.search(\n    SearchQuery(vector=query_emb, k=5, namespace=f\"user:{user_id}\")\n)\n\n# \u274c BAD: All users share same namespace\nawait vector_store.index_document(doc)  # Default namespace\n# Risk: Users can search other users' documents!\n</code></pre> <ol> <li>Set Similarity Thresholds: Filter low-quality results with threshold</li> </ol> <pre><code># \u2705 GOOD: Filter low-relevance results\nquery = SearchQuery(\n    vector=query_emb,\n    k=10,\n    threshold=0.7  # Only results with &gt;0.7 similarity\n)\n\n# \u274c BAD: Return all results regardless of relevance\nquery = SearchQuery(vector=query_emb, k=10)\n# May return completely irrelevant results\n</code></pre> <ol> <li>Use Metadata Filters for Precision: Combine vector search with metadata filtering</li> </ol> <pre><code># \u2705 GOOD: Combine vector similarity + metadata filters\nquery = SearchQuery(\n    vector=query_emb,\n    k=5,\n    filters={\n        \"category\": \"documentation\",\n        \"version\": \"2.0\",\n        \"language\": \"en\"\n    }\n)\n\n# \u274c BAD: Filter in application code (inefficient)\nall_results = await vector_store.search(SearchQuery(vector=query_emb, k=100))\nfiltered = [r for r in all_results if r.document.metadata.get(\"category\") == \"documentation\"]\n</code></pre> <ol> <li>Batch Index for Performance: Use batch operations for multiple documents</li> </ol> <pre><code># \u2705 GOOD: Batch indexing\nembeddings = await embedding_provider.embed_texts([d.content for d in docs])\ndocs_with_embeddings = [\n    Document(**{**d.model_dump(), \"embedding\": emb})\n    for d, emb in zip(docs, embeddings)\n]\ndoc_ids = await vector_store.index_documents(docs_with_embeddings)\n\n# \u274c BAD: Individual indexing (slow)\nfor doc in docs:\n    embedding = await embedding_provider.embed_text(doc.content)\n    doc_with_emb = Document(**{**doc.model_dump(), \"embedding\": embedding})\n    await vector_store.index_document(doc_with_emb)\n</code></pre>"},{"location":"ports/vector_store/#faqs","title":"FAQs","text":""},{"location":"ports/vector_store/#what-similarity-methods-are-supported","title":"What similarity methods are supported?","text":"<p>Portico supports three similarity methods:</p> <ul> <li>cosine (default): Measures angle between vectors, range -1 to 1 (normalized to 0-1). Best for most use cases.</li> <li>euclidean: Measures distance between vectors, converted to similarity via exponential decay. Good for spatial relationships.</li> <li>dot_product: Raw dot product of vectors. Useful when vectors are normalized.</li> </ul> <p>Recommendation: Use cosine similarity for most semantic search applications.</p> <pre><code>config = VectorStoreConfig(similarity_method=\"cosine\")\n</code></pre>"},{"location":"ports/vector_store/#how-do-i-choose-between-documents-and-documentchunks","title":"How do I choose between Documents and DocumentChunks?","text":"<ul> <li>Use Documents for short content that fits within embedding model token limits (~8000 tokens for OpenAI)</li> <li>Use DocumentChunks for long documents that need to be split into smaller pieces</li> </ul> <p>Rule of thumb: If document is &gt;500 words, use chunking.</p> <pre><code># Short content - use Document\ndoc = Document(content=\"Brief FAQ answer\", embedding=embedding)\n\n# Long content - use DocumentChunk\nchunks = split_into_chunks(long_document, chunk_size=500)\nfor i, chunk in enumerate(chunks):\n    chunk_obj = DocumentChunk(\n        content=chunk,\n        document_id=doc_id,\n        chunk_index=i,\n        start_char=i*500,\n        end_char=(i+1)*500,\n        embedding=await embed(chunk)\n    )\n    await vector_store.index_chunk(chunk_obj)\n</code></pre>"},{"location":"ports/vector_store/#can-i-search-without-providing-a-vector","title":"Can I search without providing a vector?","text":"<p>No, the <code>search()</code> method requires a vector. If you have text, embed it first:</p> <pre><code># \u274c WRONG: SearchQuery with text only\nquery = SearchQuery(text=\"my query\", k=5)\nresults = await vector_store.search(query)  # Raises ValueError\n\n# \u2705 CORRECT: Embed text first\nembedding = await embedding_provider.embed_text(\"my query\")\nquery = SearchQuery(vector=embedding, k=5)\nresults = await vector_store.search(query)\n</code></pre> <p>Note: The RAG Kit's higher-level services handle embedding automatically.</p>"},{"location":"ports/vector_store/#what-happens-if-i-use-different-embedding-dimensions","title":"What happens if I use different embedding dimensions?","text":"<p>You must use consistent embedding dimensions throughout your vector store. Mixing dimensions will cause errors during similarity computation.</p> <pre><code># \u274c WRONG: Inconsistent dimensions\ndoc1 = Document(content=\"Text 1\", embedding=[0.1]*1536)  # 1536 dims\ndoc2 = Document(content=\"Text 2\", embedding=[0.2]*3072)  # 3072 dims - ERROR!\n\n# \u2705 CORRECT: Consistent dimensions\nconfig = VectorStoreConfig(dimensions=1536)\n# All documents use 1536-dimensional embeddings\n</code></pre> <p>When switching embedding models, you must: 1. Clear the vector store 2. Re-embed all documents with the new model 3. Re-index everything</p>"},{"location":"ports/vector_store/#how-do-i-implement-a-custom-vector-store-adapter","title":"How do I implement a custom vector store adapter?","text":"<p>Implement the <code>VectorStore</code> interface:</p> <pre><code>from portico.ports.vector_store import VectorStore, Document, SearchQuery, SearchResult\n\nclass CustomVectorStore(VectorStore):\n    async def index_document(\n        self,\n        document: Document,\n        namespace: Optional[str] = None\n    ) -&gt; str:\n        # Store document in your vector database\n        await your_db.insert(document.id, document.embedding, document.metadata)\n        return document.id\n\n    async def search(self, query: SearchQuery) -&gt; List[SearchResult]:\n        # Perform similarity search\n        results = await your_db.similarity_search(\n            query.vector,\n            limit=query.k,\n            filters=query.filters\n        )\n        return [SearchResult(document=r.doc, score=r.score) for r in results]\n\n    # Implement all other abstract methods...\n</code></pre> <p>Then use it in composition:</p> <pre><code>def rag(**config):\n    from your_module import CustomVectorStore\n    from portico.kits.rag import RAGKit\n\n    def factory(database, events):\n        vector_store = CustomVectorStore(config[\"vector_db_url\"])\n        return RAGKit.create(database, events, config, vector_store=vector_store)\n\n    return factory\n</code></pre>"}]}